<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cocoapods使用过程中遇到的问题</title>
    <link href="/2022/04/08/Cocoapods%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/04/08/Cocoapods%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Unable-to-create-a-source-with-URL-103-105-116-x40-x67-105-x74-104-x75-98-46-x63-111-x6d-CocoaPods-Specs-git"><a href="#一、Unable-to-create-a-source-with-URL-103-105-116-x40-x67-105-x74-104-x75-98-46-x63-111-x6d-CocoaPods-Specs-git" class="headerlink" title="一、Unable to create a source with URL &#103;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;:CocoaPods/Specs.git"></a>一、Unable to create a source with URL <a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;">&#103;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#46;&#x63;&#111;&#x6d;</a>:CocoaPods/Specs.git</h3><p>场景：</p><p>新装的cocoapods，在使用pod install 的时候报错误<code>Unable to create a source with URL git@github.com:CocoaPods/Specs.git</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Command</span></span><br><br>```<br>/usr/local/bin/pod install<br>```<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Report</span></span><br><br>* What did you do?<br><br>* What did you expect to happen?<br><br>* What happened instead?<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Stack</span></span><br><br>```<br>   CocoaPods : 1.11.3<br>        Ruby : ruby 2.6.8p205 (2021-07-07 revision 67951) [universal.arm64e-darwin21]<br>    RubyGems : 3.0.3.1<br>        Host : macOS 12.1 (21C52)<br>       Xcode : 13.3 (13E113)<br>         Git : git version 2.32.0 (Apple Git-132)<br>Ruby lib dir : /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib<br>Repositories : cocoapods - git - git@github.com:CocoaPods/Specs.git @ 13ae4e07a79a8d86e62f4fc627107e6c7c61f18f<br><br>               master - git - git@github.com:CocoaPods/Specs.git @ 58dcd4c8b08c75f2e6e05354a14f8e501ed3dcd6<br><br>```<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Plugins</span></span><br><br>```<br>cocoapods-deintegrate : 1.0.5<br>cocoapods-plugins     : 1.0.0<br>cocoapods-search      : 1.0.1<br>cocoapods-trunk       : 1.6.0<br>cocoapods-try         : 1.2.0<br>```<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Podfile</span></span><br><br>```ruby<br>source &#x27;git@github.com:CocoaPods/Specs.git&#x27;<br><br>platform :ios, &#x27;11.0&#x27;<br><br>use_modular_headers!<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">---- Swift libs</span><br>pod &#x27;Moya&#x27;,      &#x27;~&gt; 13.0.0&#x27;<br>pod &#x27;Kingfisher&#x27;,  &#x27;~&gt; 5.7.1&#x27;<br>pod &#x27;HandyJSON&#x27;,  &#x27;~&gt; 5.0.0&#x27;<br>pod &#x27;SnapKit&#x27;,    &#x27;~&gt; 5.0.1&#x27;<br>pod &#x27;IQKeyboardManagerSwift&#x27;, &#x27;~&gt; 6.4.2&#x27;<br>pod &#x27;KeychainAccess&#x27;, &#x27;~&gt; 3.2.0&#x27;<br>pod &#x27;HYToolKit&#x27;, :git =&gt; &quot;https://github.com/xtyHY/HYToolKit.git&quot;, :commit =&gt; &quot;48972ebc8de9bb169e23d13806a81eb896c5aee2&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">---- OBJC libs</span><br>pod &#x27;MBProgressHUD&#x27;, &#x27;~&gt; 1.1.0&#x27;<br>pod &#x27;WebViewJavascriptBridge&#x27;<br>pod &#x27;SGQRCode&#x27;, &#x27;~&gt; 3.0.1&#x27;<br>pod &#x27;TZImagePickerController&#x27;, &#x27;~&gt; 3.5.7&#x27;<br><br>pod &#x27;NIMSDK&#x27;, &#x27;~&gt; 6.9.1&#x27;<br>pod &#x27;Qiniu&#x27;, &#x27;~&gt; 7.2.6&#x27;<br>pod &#x27;MJRefresh&#x27;, &#x27;~&gt; 3.2.3&#x27;<br><br>pod &#x27;CryptoSwift&#x27;<br><br>target &#x27;MHCWarehouseStaffApp&#x27; do<br>end<br><br>target &#x27;MHCWarehouseStaffAppDev&#x27; do<br>end<br>```<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Error</span></span><br><br>```<br>RuntimeError - Unable to create a source with URL git@github.com:CocoaPods/Specs.git<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/sources_manager.rb:61:in `create_source_with_url&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/sources_manager.rb:22:in `find_or_create_source_with_url&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/analyzer.rb:178:in `block in sources&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/analyzer.rb:177:in `map&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/analyzer.rb:177:in `sources&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/analyzer.rb:1077:in `block in resolve_dependencies&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/user_interface.rb:64:in `section&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/analyzer.rb:1076:in `resolve_dependencies&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer/analyzer.rb:124:in `analyze&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer.rb:416:in `analyze&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer.rb:241:in `block in resolve_dependencies&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/user_interface.rb:64:in `section&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer.rb:240:in `resolve_dependencies&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/installer.rb:161:in `install!&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/command/install.rb:52:in `run&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/claide-1.1.0/lib/claide/command.rb:334:in `run&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:52:in `run&#x27;<br>/Library/Ruby/Gems/2.6.0/gems/cocoapods-1.11.3/bin/pod:55:in `&lt;top (required)&gt;&#x27;<br>/usr/local/bin/pod:23:in `load&#x27;<br>/usr/local/bin/pod:23:in `&lt;main&gt;&#x27;<br>```<br><br>――― TEMPLATE END ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――<br><br>[!] Oh no, an error occurred.<br><br>Search for existing GitHub issues similar to yours:<br>https://github.com/CocoaPods/CocoaPods/search?q=Unable+to+create+a+source+with+URL+git%40github.com%3ACocoaPods%2FSpecs.git&amp;type=Issues<br><br>If none exists, create a ticket, with the template displayed above, on:<br>https://github.com/CocoaPods/CocoaPods/issues/new<br><br>Be sure to first read the contributing guide for details on how to properly submit a ticket:<br>https://github.com/CocoaPods/CocoaPods/blob/master/CONTRIBUTING.md<br><br>Don&#x27;t forget to anonymize any private data!<br><br>Looking for related issues on cocoapods/cocoapods...<br> - [!] Unable to add a source with url `https://github.com/CocoaPods/Specs.git` named `master`.<br>   https://github.com/CocoaPods/CocoaPods/issues/4293 [closed] [96 comments]<br>   14 May 2021<br><br> - Using SSH URL in source command for master repo results in timeouts<br>   https://github.com/CocoaPods/CocoaPods/issues/9408 [closed] [31 comments]<br>   28 Jun 2020<br><br> - Issues Cloning Spec repo - GitHub taking a very long time to download changes to the Specs Repo<br>   https://github.com/CocoaPods/CocoaPods/issues/4989 [closed] [73 comments]<br>   15 Nov 2019<br><br>and 4 more at:<br>https://github.com/cocoapods/cocoapods/search?q=Unable%20to%20create%20a%20source%20with%20URL%20git%40github.com%3ACocoaPods%2FSpecs.git&amp;type=Issues&amp;utf8=✓<br></code></pre></td></tr></table></figure><p>解决方法：</p><p> </p>]]></content>
    
    
    
    <tags>
      
      <tag>Cocoapods</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>item2安装优化过程中遇到的问题</title>
    <link href="/2022/04/08/item2%E5%AE%89%E8%A3%85%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/04/08/item2%E5%AE%89%E8%A3%85%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="一、安装item2及优化"><a href="#一、安装item2及优化" class="headerlink" title="一、安装item2及优化"></a>一、安装item2及优化</h3><p>参考：<a href="https://segmentfault.com/a/1190000014992947">iTerm2 + Oh My Zsh 打造舒适终端体验</a></p><h3 id="二、item2常用快捷键"><a href="#二、item2常用快捷键" class="headerlink" title="二、item2常用快捷键"></a>二、item2常用快捷键</h3><ol><li><p>分屏</p><p>水平分屏：command + d</p><p>垂直分屏：command + shift + d </p></li><li><p>中断</p><p>ctrl +c</p></li></ol><h3 id="三、curl-7-Failed-to-connect-to-raw-githubusercontent-com-port-443-Connection-refused"><a href="#三、curl-7-Failed-to-connect-to-raw-githubusercontent-com-port-443-Connection-refused" class="headerlink" title="三、curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused"></a>三、curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</h3><p>参考:  <a href="https://github.com/hawtim/hawtim.github.io/issues/10">Failed to connect to raw.githubusercontent.com port 443</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成SSH key并添加到Github账户</title>
    <link href="/2022/04/07/%E7%94%9F%E6%88%90SSH-key%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0Github%E8%B4%A6%E6%88%B7/"/>
    <url>/2022/04/07/%E7%94%9F%E6%88%90SSH-key%E5%B9%B6%E6%B7%BB%E5%8A%A0%E5%88%B0Github%E8%B4%A6%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<p><font color= orange>本文摘自<a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh">Github Docs</a></font></p><h3 id="一、检查是否存在SSH-key"><a href="#一、检查是否存在SSH-key" class="headerlink" title="一、检查是否存在SSH key"></a>一、检查是否存在SSH key</h3><ol><li><p>打开终端，输入<code>ls -al ~/.ssh</code>命令，查看是否已经存在SSH key。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ls -al ~/.ssh</span><br><span class="hljs-meta">#</span><span class="bash"> 如果存在的话，会列出.ssh中的文件的</span><br></code></pre></td></tr></table></figure></li><li><p>默认情况下公钥的文件名是以下几种形式之一。</p><ul><li><em>id_rsa.pub</em></li><li><em>id_ecdsa.pub</em></li><li><em>id_ed25519.pub</em></li></ul></li></ol><h3 id="二、生成SSH-key"><a href="#二、生成SSH-key" class="headerlink" title="二、生成SSH key"></a>二、生成SSH key</h3><ol><li><p>打开终端输入下面命令。创建一个新的SSH密钥，并使用提供的电子邮件作为标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ssh-keygen -t ed25519 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> 如果你的系统不支持ed25519算法，使用下面命令</span><br><span class="hljs-meta">$</span><span class="bash"> ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your_email@example.com&quot;</span></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">-t 指定密钥类型，默认是rsa，可以省略</span><br><span class="hljs-meta">#</span><span class="bash">-C 设置注释文字，比如邮箱</span><br></code></pre></td></tr></table></figure></li><li><p>输入空格，设置默认的文件位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> Generating public/private ed25519 key pair.</span><br><span class="hljs-meta">&gt;</span><span class="bash"> Enter file <span class="hljs-keyword">in</span> <span class="hljs-built_in">which</span> to save the key (/Users/tianyanqing/.ssh/id_ed25519):</span><br></code></pre></td></tr></table></figure></li><li><p>输入密钥密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):</span><br><span class="hljs-meta">&gt;</span><span class="bash"> Enter same passphrase again:</span><br></code></pre></td></tr></table></figure><p>通过输入以下命令，可以更改现有私钥的密码而无需重新生成密钥对：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ssh-keygen -p -f ~/.ssh/id_ed25519</span><br><span class="hljs-meta">&gt;</span><span class="bash"> Enter old passphrase: [Type old passphrase]</span><br><span class="hljs-meta">&gt;</span><span class="bash"> Key has comment <span class="hljs-string">&#x27;your_email@example.com&#x27;</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"> Enter new passphrase (empty <span class="hljs-keyword">for</span> no passphrase): [Type new passphrase]</span><br><span class="hljs-meta">&gt;</span><span class="bash"> Enter same passphrase again: [Repeat the new passphrase]</span><br><span class="hljs-meta">&gt;</span><span class="bash"> Your identification has been saved with the new passphrase.</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="三、将SSH-key添加到ssh-agent"><a href="#三、将SSH-key添加到ssh-agent" class="headerlink" title="三、将SSH key添加到ssh-agent"></a>三、将SSH key添加到ssh-agent</h3><ol><li><p>在后台启动ssh代理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"> Agent pid 59566</span><br></code></pre></td></tr></table></figure></li><li><p>如果您使用的是MacOS Sierra 10.12.2或更高版本，则需要修改<code>〜/.ssh/config</code>文件以自动将键加载到SSH-Agent中，并在钥匙串中存储密码</p><ul><li><p>检查默认位置是否存在<code>~/.ssh/config</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> open ~/.ssh/config</span><br><span class="hljs-meta">&gt;</span><span class="bash"> The file /Users/you/.ssh/config does not exist.</span><br></code></pre></td></tr></table></figure></li><li><p>如果不存在，创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> touch ~/.ssh/config</span><br></code></pre></td></tr></table></figure></li><li><p>打开~/.ssh/config，按照下面修改文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host *<br>  AddKeysToAgent yes<br>  UseKeychain yes<br>  IdentityFile ~/.ssh/id_ed25519<br></code></pre></td></tr></table></figure></li></ul></li><li><p>将SSH私钥添加到SSH-Agent并在钥匙串中存储密码。如果您创建了不同名称的密钥，或者您要添加不同名称的现有密钥，请将命令中的 <em>id_ed25519</em> 替换为您的私钥文件的名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ssh-add -K ~/.ssh/id_ed25519</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><p>MacOS Monterey (12.0), the <code>-K</code> and <code>-A</code> flags are deprecated and have been replaced by the <code>--apple-use-keychain</code> and <code>--apple-load-keychain</code> flags, respectively.</p></blockquote></li></ol><h3 id="四、将SSH-key添加到Github账户"><a href="#四、将SSH-key添加到Github账户" class="headerlink" title="四、将SSH key添加到Github账户"></a>四、将SSH key添加到Github账户</h3><ol><li><p>将SSH公钥复制到剪贴板。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> pbcopy &lt; ~/.ssh/id_ed25519.pub</span><br></code></pre></td></tr></table></figure><blockquote><p>提示：如果pbcopy 不可用，可找到隐藏的.ssh文件夹，在常用的文本编辑器中打开该文件，并将其复制到剪贴板。</p></blockquote></li><li><p>在页面的右上角，单击您的个人资料照片，然后单击 <strong>Settings</strong>，在右侧列表的Access中找到*<em>SSH and GPG keys</em>。</p></li><li><p>点击<strong>New SSH key</strong>。</p></li><li><p>在“Title”标题中，为新密钥添加表属性标签。看自己喜好随便写就好。</p></li><li><p>将密钥粘贴到”Key”中。</p></li><li><p>点击<strong>Add SSH key</strong>添加密钥。</p></li></ol><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202204071721383.png" alt="添加SSH" style="zoom:50%;margin-left:10px" /><h3 id="五、测试SSH链接"><a href="#五、测试SSH链接" class="headerlink" title="五、测试SSH链接"></a>五、测试SSH链接</h3><ol><li><p>打开终端输入下面命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ssh -T git@github.com</span><br></code></pre></td></tr></table></figure><p>你可能会看到下面的警告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> The authenticity of host <span class="hljs-string">&#x27;github.com (IP ADDRESS)&#x27;</span> can<span class="hljs-string">&#x27;t be established.</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> Are you sure you want to continue connecting (yes/no)?</span></span><br></code></pre></td></tr></table></figure></li><li><p>验证所看到消息中的指纹是否匹配，如果是输入<code>yes</code>即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hi GHTYQ! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.<br></code></pre></td></tr></table></figure><blockquote><p>公钥指纹：公钥指纹可用于验证与远程服务器的连接</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown的基本用法</title>
    <link href="/2022/03/30/Markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <url>/2022/03/30/Markdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、标题（一共六级标题）"><a href="#一、标题（一共六级标题）" class="headerlink" title="一、标题（一共六级标题）"></a>一、标题（一共六级标题）</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">#一级标题<br>##二级标题<br>###三级标题<br>####四级标题<br>#####五级标题<br>######六级标题<br></code></pre></td></tr></table></figure><h3 id="二、斜体-加粗"><a href="#二、斜体-加粗" class="headerlink" title="二、斜体/加粗"></a>二、斜体/加粗</h3><ol><li><p>斜体<br>在文字前后各家一个<code>*</code>就👌<br><em>斜体</em></p></li><li><p>加粗<br>在文字前后各加两个<code>**</code><br><strong>加粗</strong></p></li><li><p>斜体加粗<br>在文字前后各加<code>***</code><br><em><strong>斜体加粗</strong></em></p></li></ol><h3 id="三、删除"><a href="#三、删除" class="headerlink" title="三、删除"></a>三、删除</h3><p>在要删除的文字前后加~~<br><del>要删除的文字</del></p><h3 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h3><p>分割线的三种形式<br>***  —  ****</p><hr><h3 id="五、引用"><a href="#五、引用" class="headerlink" title="五、引用"></a>五、引用</h3><ul><li>使用&gt;+引用的话，效果如下<blockquote><p>这是一段引用的话</p></blockquote></li><li>使用两个`</li></ul><p><code>引用</code></p><h3 id="六、区块引用"><a href="#六、区块引用" class="headerlink" title="六、区块引用"></a>六、区块引用</h3><p>使用两个``` 包含要引用的区域</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">```<br>### 七、表格<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>第一项</th><th>第二项</th></tr></thead><tbody><tr><td>第一项内容</td><td>第二项内容</td></tr></tbody></table><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir">|   第一项   |   第二项   |<br>| <span class="hljs-symbol">:--------</span>: | <span class="hljs-symbol">:--------</span>: |<br>| 第一项内容 | 第二项内容 |<br><br><span class="hljs-comment">### 八、添加链接</span><br><br></code></pre></td></tr></table></figure><p>图片链接：![image](图片地址）<br>网址链接：<a href="%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">显示名称</a> 或者使用&lt;网址链接&gt;</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gams">[我的GitHub地址](https:<span class="hljs-comment">//github.com/GHTYQ)</span><br>&lt;https:<span class="hljs-comment">//github.com/GHTYQ&gt;</span><br>  &lt;img src=<span class="hljs-string">&quot;https://upload-images.jianshu.io/upload_images/4189530-a85d923709d9dcf2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;</span> alt=<span class="hljs-string">&quot;timg.jpg&quot;</span> style=<span class="hljs-string">&quot;zoom: 200%; margin-left: 0px;&quot;</span> /&gt; <br><br>### 九、数学公式<br><br>&gt; 如果使用的是Typora，请确定设置中内联公式是开启状态<br><br><span class="hljs-number">1.</span> 平方<br><br>   <span class="hljs-symbol">$</span>\<span class="hljs-built_in">sqrt</span> [a]&#123;b&#125;<span class="hljs-symbol">$</span><br><br>   ```latex<br>   <span class="hljs-symbol">$</span>\<span class="hljs-built_in">sqrt</span> [a]&#123;b&#125;<span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>上标与下标</p><p>$a^n$</p><p>$a_n$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">$a^n$<br>$a_n$<br></code></pre></td></tr></table></figure></li><li><p>分式</p><p>$\frac ab$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">\$frac ab$<br></code></pre></td></tr></table></figure></li><li><p>对数</p><p>$\log_2(x)$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">$\log_2(x)$<br></code></pre></td></tr></table></figure></li></ol><p>这里简单列举几个，后面用到其他的会继续增添。</p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2022/03/30/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2022/03/30/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><p>快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在O(log n)的时间内计算a^n的小技巧</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://oi-wiki.org/math/quick-pow/">OI Wiki 快速幂</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDWebImage</title>
    <link href="/2022/03/20/iOS/%E5%A4%87%E8%80%83/%E4%B8%89%E6%96%B9%E5%BA%93/SDWebImage/"/>
    <url>/2022/03/20/iOS/%E5%A4%87%E8%80%83/%E4%B8%89%E6%96%B9%E5%BA%93/SDWebImage/</url>
    
    <content type="html"><![CDATA[<p>1.下载图片且需要获取下载进度</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Third</tag>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2022/03/18/iOS/%E5%A4%87%E8%80%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/18/iOS/%E5%A4%87%E8%80%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>单例模式的作用：</p><ul><li>可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问</li><li>方便控制实例个数，节约系统资源</li></ul><p>一般应用中的单例写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 伪代码<br>+(instancetype)shareInstance&#123;<br>    static Category *instance;<br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^&#123;<br>        instance = [[Category alloc] init];<br>    &#125;);<br>    return  instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个写法只能保证使用shareInstance方法创建出来的对象是同一个对象，为了保证所有的创建方法创建出来的是一个对象，可以才用下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;Foundation/Foundation.h&gt;<br><br>NS_ASSUME_NONNULL_BEGIN<br><br>@interface TTool : NSObject&lt;NSCopying,NSMutableCopying&gt;<br>+(instancetype)share;<br>@end<br><br>NS_ASSUME_NONNULL_END<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &quot;TTool.h&quot;<br>@implementation TTool<br>static TTool * _instance;<br>+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123;<br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^&#123;<br>        _instance = [super allocWithZone:zone];<br>    &#125;);<br>    return  _instance;<br>&#125;<br>+ (instancetype)share&#123;<br>    return  [[self alloc] init];<br>&#125;<br>- (nonnull id)copyWithZone:(nullable NSZone *)zone &#123;<br>    return _instance;<br>&#125;<br>- (nonnull id)mutableCopyWithZone:(nullable NSZone *)zone &#123;<br>    return _instance;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">TTool *t1 = [[TTool alloc] init];<br>TTool *t2 = [TTool share];<br>TTool *t3 = [t1 copy];<br>TTool *t4 = [t1 mutableCopy];<br>NSLog(@&quot;t1:%p--t2:%p--t3:%p--t4:%p&quot;,t1,t2,t3,t4);<br>// log<br>t1:0x6000029084f0--t2:0x6000029084f0--t3:0x6000029084f0--t4:0x6000029084f0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2022/03/17/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/17/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>常见排序算法总结</p><p>时间复杂度：</p><p>空间复杂度：</p><p>稳定性：</p><h3 id="一、冒泡排序（Bubble-Sort）"><a href="#一、冒泡排序（Bubble-Sort）" class="headerlink" title="一、冒泡排序（Bubble Sort）"></a>一、冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法，它重复地走访要排序的数列，每次比较相邻的两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复进行直到没有需要交换。这个算法的名字由来是因为越小的元素会经过交换慢慢“浮”到数列的顶端。</p><h4 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h4><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻的元素作同样的工作，从开始第一对到结尾的最后一对。这步完成后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ul><h4 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h4><img src="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" alt="冒泡排序" style="zoom:120%;margin-left:10px" /><h4 id="3-OC语言实现"><a href="#3-OC语言实现" class="headerlink" title="3. OC语言实现"></a>3. OC语言实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(NSArray*)bobble_sort:(NSArray*)array&#123;<br>    NSMutableArray * mutArr = [[NSMutableArray alloc]initWithArray:array];<br>  // 需要比较多少趟<br>    for (int i = 0; i&lt;mutArr.count-1; i++) &#123;<br>       // 每一趟比较多少次<br>        for (int j = 0; j&lt;mutArr.count-1-i; j++) &#123;<br>            if ([mutArr[j] intValue]&gt;[mutArr[j+1] intValue]) &#123;<br>                [mutArr exchangeObjectAtIndex:j withObjectAtIndex:j+1];<br>            &#125;<br>        &#125;<br>    &#125;<br>    return  [mutArr copy];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-时间复杂度：O-N-2"><a href="#4-时间复杂度：O-N-2" class="headerlink" title="4. 时间复杂度：O(N^2)"></a>4. 时间复杂度：O(N^2)</h4><h4 id="5-空间复杂度：O-1"><a href="#5-空间复杂度：O-1" class="headerlink" title="5. 空间复杂度：O(1)"></a>5. 空间复杂度：O(1)</h4><h3 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h3><p>选择排序是一种直观的排序算法</p><h4 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h4><ul><li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p></li><li><p>再从剩余未排序元素中寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>以此类推，知道所有元素排序完毕。</p></li></ul><h4 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h4><img src="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" alt="选择排序" style="zoom:120%;margin-left:10px" /><h4 id="3-OC语言实现-1"><a href="#3-OC语言实现-1" class="headerlink" title="3. OC语言实现"></a>3. OC语言实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(NSArray*)selection_sort:(NSArray*)array&#123;<br>    NSMutableArray * mutArr = [[NSMutableArray alloc]initWithArray:array];<br>    for (int i = 0; i&lt;mutArr.count - 1; i++) &#123;<br>        int min = i;<br>        for (int j = i+1; j&lt;mutArr.count; j++) &#123;<br>            if([mutArr[min] intValue] &gt; [mutArr[j] intValue])&#123;<br>                min = j;<br>            &#125;<br>        &#125;<br>        [mutArr exchangeObjectAtIndex:i withObjectAtIndex:min];<br>    &#125;<br>    return  mutArr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-时间复杂度：O-N-2-1"><a href="#4-时间复杂度：O-N-2-1" class="headerlink" title="4. 时间复杂度：O(N^2)"></a>4. 时间复杂度：O(N^2)</h4><h4 id="5-空间复杂度：O-1-1"><a href="#5-空间复杂度：O-1-1" class="headerlink" title="5. 空间复杂度：O(1)"></a>5. 空间复杂度：O(1)</h4><h3 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法的时间复杂度和空间复杂度</title>
    <link href="/2022/03/17/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <url>/2022/03/17/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、时间复杂度"><a href="#一、时间复杂度" class="headerlink" title="一、时间复杂度"></a>一、时间复杂度</h3><h3 id="二、空间复杂度"><a href="#二、空间复杂度" class="headerlink" title="二、空间复杂度"></a>二、空间复杂度</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCD</title>
    <link href="/2022/03/12/iOS/%E5%A4%87%E8%80%83/%E5%A4%9A%E7%BA%BF%E7%A8%8B/GCD/"/>
    <url>/2022/03/12/iOS/%E5%A4%87%E8%80%83/%E5%A4%9A%E7%BA%BF%E7%A8%8B/GCD/</url>
    
    <content type="html"><![CDATA[<h3 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h3><h4 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h4><ol><li><p>进程</p><p>进程是指系统中<font color=orange>正在运行</font>的一个应用程序</p><p>每个进程之间是相互独立的，每个进程均运行在专用且受保护的内存空间内</p><p>比如同时打开迅雷、Xcode，系统就会分别启动两个进程</p></li><li><p>线程</p><p>1个进程想要执行任务，必须得有线程（每1个进程至少有一条线程）</p><p>一个进程（程序）中的所有任务都是在线程中执行</p></li><li><p>线程的串行</p><p>1条线程中的任务是<font color=orange>串行</font>执行的（如果一个线程中执行多个任务，那么只能一个一个的按顺序执行）</p></li><li><p>进程与线程的比较</p><p>线程是CPU调用（执行任务）的最小单位</p><p>进程是CPU分配资源和调度的单位</p><p>一个程序可以对应多个进程，一个进程中可以有多个线程（至少要有一个线程）</p><p>同一个进程内的线程共享进程的资源</p></li></ol><h4 id="2-多线程"><a href="#2-多线程" class="headerlink" title="2. 多线程"></a>2. 多线程</h4><p>1个进程中可以开启多条线程，多条线程可以<font color= orange>并行</font>执行不同的任务（单个线程内任务的执行是串行的）</p><p>多线程的原理（单CPU）：</p><ol><li>同一时间，CPU只能处理1条线程</li><li>多线程并发执行，其实是CPU快速的在多条线程之间调度（切换）</li><li>如果CPU调度线程的时间足够快，就造成了多线程并发的假象。</li></ol><p>多线程的优点：</p><ol><li>能够适当提高程序的执行效率</li><li>能适当提高资源利用率（CPU、内存利用率）</li></ol><p>多线程的缺点：</p><ol><li>创建线程都是有开销的，iOS下主要成本包括：内核数据结构（大约1KB）、栈空间（子线程512KB、主线程1M），创建线程大约需要90毫秒的创建时间</li><li>如果开启大量线程，会降低程序的性能</li><li>线程越多，CPU在调度线程上开销就越大</li><li>程序设计更加复杂，比如线程之间的通信、多线程的数据共享</li></ol><h4 id="3-主线程"><a href="#3-主线程" class="headerlink" title="3. 主线程"></a>3. 主线程</h4><p>一个iOS程序运行后，默认会开启1条线程，成为<font color=orange>主线程</font>或<font color=orange>UI线程</font></p><p>主线程的组要作用：</p><ol><li>显示/刷新UI界面</li><li>处理UI事件</li></ol><p>主线程的使用注意：</p><ol><li>别将比较耗时的操作放到主线程中</li><li>耗时操作会卡主主线程，严重影响UI的流畅度</li></ol><h3 id="二、iOS中多线程的实现方案"><a href="#二、iOS中多线程的实现方案" class="headerlink" title="二、iOS中多线程的实现方案"></a>二、iOS中多线程的实现方案</h3><table><thead><tr><th>技术方案</th><th>简介</th><th>语言</th><th>线程声明周期</th><th>使用频率</th></tr></thead><tbody><tr><td>pthread</td><td>一套通用的多线程API 、适用于Unic\Linux\Windows等系统、跨平台\可移植</td><td>C</td><td>程序员管理</td><td>几乎不用</td></tr><tr><td>NSThread</td><td>使用更加面向对象、简单易用可直接操作线程对象</td><td>OC</td><td>程序员管理（只管创建）</td><td>偶尔使用</td></tr><tr><td>GCD</td><td>旨在替代NSTread等线程技术、充分利用设备多核</td><td>C</td><td>自动管理</td><td>经常使用</td></tr><tr><td>NSOperation</td><td>基于GCD（底层是GCD）、比GCD多了些更简单实用的功能 、更加面向对象</td><td>OC</td><td>自动管理</td><td>经常使用</td></tr></tbody></table><h4 id="1-NSTread"><a href="#1-NSTread" class="headerlink" title="1. NSTread"></a>1. NSTread</h4><h5 id="1-1-NSThread创建线程的三种方法："><a href="#1-1-NSThread创建线程的三种方法：" class="headerlink" title="1.1 NSThread创建线程的三种方法："></a>1.1 NSThread创建线程的三种方法：</h5><ol><li><p>alloc init 创建线程，需要手动启动线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/**<br> 第一个参数：目标对象 self<br> 第二个参数：方法选择器 调用的方法<br> 第三个参数：前面调用方法需要传递的参数<br>*/<br>NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@&quot;123&quot;];<br>// 设置属性<br>thread.name = @&quot;子线程1&quot;;<br>// 设置优先级 取值范围 0.0~1.0 默认优先级是0.5<br>thread.threadPriority = 1.0;<br>// 启动线程<br>[thread start];<br><br>-(void)run:(NSString*)param&#123;<br>    NSLog(@&quot;%@--%@&quot;,param,[NSThread currentThread]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>类方法 ，分离出子线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;123&quot;];<br></code></pre></td></tr></table></figure></li><li><p>创建后台线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">[self performSelectorInBackground:@selector(run:) withObject:@&quot;123&quot;];<br></code></pre></td></tr></table></figure></li></ol><p>后面两种方法可以更加快速的创建线程，但是无法拿到线程对象，对线程进行更详细的设置。</p><h5 id="1-2-线程的生命周期："><a href="#1-2-线程的生命周期：" class="headerlink" title="1.2 线程的生命周期："></a>1.2 线程的生命周期：</h5><ol><li><p>启动线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 新建状态-&gt;就绪状态（可调度线程池）-&gt;运行状态-&gt;阻塞状态-&gt;死亡状态。当前线程执行完毕，自动进入死亡状态<br>// 运行状态<br>- (void)start;<br></code></pre></td></tr></table></figure></li><li><p>阻塞（暂停）线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 进入阻塞状态<br>+ (void)sleepUntilDate:(NSDate*)date;<br>+ (void)sleepForTimeInterval:(NSTimeInterval)ti;<br></code></pre></td></tr></table></figure></li><li><p>强制停止线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 进入死亡状态<br>+ (void)exit;<br></code></pre></td></tr></table></figure><blockquote><p>注意：一旦线程停止了，就不能再次启动线程</p></blockquote></li></ol><h5 id="1-3-原子和非原子属性"><a href="#1-3-原子和非原子属性" class="headerlink" title="1.3 原子和非原子属性"></a>1.3 原子和非原子属性</h5><ol><li><p>OC在定义属性时有noatomic和atomic两种选择</p><p>atomic：原子属性，为setter方法加锁（默认使用）</p><p>noatomic：非原子属性 ，不会为setter方法加锁</p></li><li><p>原子和非原子属性的选择</p><p>atomic：线程安全，需要消耗大量资源</p><p>noatomic：非线程安全，但是我们一般还是会选择使用noatomic（app体量决定了我们很少会遇到多线程资源抢夺的问题）</p></li></ol><h5 id="1-4-线程间通讯"><a href="#1-4-线程间通讯" class="headerlink" title="1.4 线程间通讯"></a>1.4 线程间通讯</h5><ol><li><p>什么叫线程间通讯</p><p>在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通讯</p></li><li><p>线程间通讯的体现</p><p>1个线程传递数据给另1个线程</p><p>在1个线程中执行完待定任务后，转到另1个线程中继续执行任务</p></li><li><p>线程间通讯常用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;<br>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-GCD"><a href="#2-GCD" class="headerlink" title="2. GCD"></a>2. GCD</h4><h5 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h5><ol><li><p>什么是GCD?</p><p>全称Grand Central Dispatch，纯C语言，提供了非常多且强大的函数</p></li><li><p>GCD的优势？</p><p>GCD是苹果公司为多核和并行运算提出的解决方案</p><p>GCD会自动利用更多的CPU内核（比如双核、四核）</p><p>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</p><p>程序员只需要告诉GCD想要执行什么任务，不需要编写任务线程管理代码</p></li></ol><h5 id="2-2-任务和队列"><a href="#2-2-任务和队列" class="headerlink" title="2.2 任务和队列"></a>2.2 任务和队列</h5><p><font>任务和队列是GCD中2个核心概念：</font></p><ul><li><p>任务：执行什么操作</p></li><li><p>队列：用来存放任务</p></li></ul><p>GCD的使用就两个步骤：</p><ul><li><p>定制任务</p><p>确定要做的事情</p></li><li><p>将任务添加到队列中</p><p>GCD会自动将队列中的任务取出，放到对应的线程中执行</p><p>任务的取出遵循队列的FIFO原则</p></li></ul><h6 id="2-2-1-GCD中有两个执行任务常用的函数："><a href="#2-2-1-GCD中有两个执行任务常用的函数：" class="headerlink" title="2.2.1 GCD中有两个执行任务常用的函数："></a>2.2.1 GCD中有两个执行任务常用的函数：</h6><ol><li>用同步的方式执行任务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);<br></code></pre></td></tr></table></figure><ol start="2"><li>用异步的方式来执行任务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);<br></code></pre></td></tr></table></figure><ol start="3"><li>同步和异步的主要影响：能不能开启新的线程</li></ol><p>同步：只能在当前线程中执行任务，不具备开启新的线程的能力。</p><p>异步：可以在新的线程中执行，具备开启新的线程的能力。</p><h6 id="2-2-2-队列的类型"><a href="#2-2-2-队列的类型" class="headerlink" title="2.2.2 队列的类型"></a>2.2.2 队列的类型</h6><p>GCD的队列可以分为两大类型：</p><ol><li><p>并发队列</p><p>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</p><blockquote><p>注意：并发功能只在异步函数下才有效</p></blockquote><p>创建并发队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">第一个参数：C语言字符串，标签</span><br><span class="hljs-comment">第二个参数：队列的类型 1. DISPATCH_QUEUE_CONCURRENT（并发）2.DISPATCH_QUEUE_SERIAL（串行）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">dispatch_queue_t</span> <span class="hljs-built_in">queue</span> = dispatch_queue_create(<span class="hljs-string">&quot;myQueue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);<br></code></pre></td></tr></table></figure><p>GCD默认已经提供了全局并发队列，供整个应用使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">第一个参数：队列的优先级</span><br><span class="hljs-comment">第二个参数：传0即可</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">dispatch_queue_t</span> globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>串行队列</p><p>让任务一个接一个的执行（一个任务执行完毕后，才会执行下一个任务）</p><p>创建串行队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment">第一个参数：C语言字符串，标签</span><br><span class="hljs-comment">第二个参数：队列的类型 1. DISPATCH_QUEUE_CONCURRENT（并发）2.DISPATCH_QUEUE_SERIAL（串行）</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">dispatch_queue_t</span> <span class="hljs-built_in">queue</span> = dispatch_queue_create(<span class="hljs-string">&quot;myQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);<br></code></pre></td></tr></table></figure><p>主队列：</p><p>主队列是GCD自带的一种特殊的串行队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">dispatch_queue_t</span> <span class="hljs-built_in">queue</span> = dispatch_get_main_queue();<br></code></pre></td></tr></table></figure><blockquote><p>注意：放在主队列中的任务，都会放到主线程中执行</p></blockquote></li><li><p>并发和串行主要影响：任务的执行方式</p></li></ol><h6 id="2-2-3-各种队列的执行效果"><a href="#2-2-3-各种队列的执行效果" class="headerlink" title="2.2.3 各种队列的执行效果"></a>2.2.3 各种队列的执行效果</h6><table><thead><tr><th></th><th>并发队列</th><th>手动创建的串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步（sync）</td><td>没有开启新的线程、串行执行任务</td><td>没有开启新的线程、串行执行任务</td><td>死锁</td></tr><tr><td>异步（async）</td><td>有开启新的线程、并行执行任务</td><td>开启了一条线程、串行执行任务</td><td>没有开启新的线程、串行执行任务</td></tr></tbody></table><blockquote><p>注意：使用sync函数往当前串行队列添加任务，会卡住当前串行队列</p></blockquote><h5 id="2-3-GCD常用函数"><a href="#2-3-GCD常用函数" class="headerlink" title="2.3 GCD常用函数"></a>2.3 GCD常用函数</h5><h6 id="2-3-1-延迟执行"><a href="#2-3-1-延迟执行" class="headerlink" title="2.3.1 延迟执行"></a>2.3.1 延迟执行</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//1.performSelector<br>[self performSelector:@selector(task) withObject:nil afterDelay:2.0];<br>//2.NSTimer<br>[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(task) userInfo:nil repeats:NO];<br>-(void)task&#123;<br>    NSLog(@&quot;2s后执行&quot;);<br>&#125;<br>//3.GCD<br>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;<br>   NSLog(@&quot;2s后执行&quot;);<br>&#125;);<br></code></pre></td></tr></table></figure><h6 id="2-3-2-一次性执行"><a href="#2-3-2-一次性执行" class="headerlink" title="2.3.2 一次性执行"></a>2.3.2 一次性执行</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">static dispatch_once_t onceToken;<br>dispatch_once(&amp;onceToken, ^&#123;<br>  NSLog(@&quot;只执行一次&quot;);<br>&#125;);<br></code></pre></td></tr></table></figure><h6 id="2-3-3-栅栏函数"><a href="#2-3-3-栅栏函数" class="headerlink" title="2.3.3 栅栏函数"></a>2.3.3 栅栏函数</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 作用：控制多线程异步执行顺序(任务1、2执行完成后才会执行3)<br>dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);<br>dispatch_async(queue, ^&#123;<br>NSLog(@&quot;任务1---%@&quot;,[NSThread currentThread]);<br>&#125;);<br>dispatch_async(queue, ^&#123;<br>NSLog(@&quot;任务2---%@&quot;,[NSThread currentThread]);<br>&#125;);<br>dispatch_barrier_async(queue, ^&#123;<br>NSLog(@&quot;++++&quot;);<br>&#125;);<br>dispatch_async(queue, ^&#123;<br>NSLog(@&quot;任务3---%@&quot;,[NSThread currentThread]);<br>&#125;);<br></code></pre></td></tr></table></figure><blockquote><p>注意：全局并发队列不能使用栅栏函数</p></blockquote><h6 id="2-3-4-快速迭代"><a href="#2-3-4-快速迭代" class="headerlink" title="2.3.4 快速迭代"></a>2.3.4 快速迭代</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/**<br>第一个参数：遍历次数<br>第二个参数：队列（并发队列）<br>第三个参数：index 索引<br>*/<br>//开子线程，和主线程一起完成遍历任务，任务执行是并发的<br>dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index) &#123;<br>NSLog(@&quot;%ld--%@&quot;,index,[NSThread currentThread]);<br>&#125;);<br></code></pre></td></tr></table></figure><h6 id="2-3-5-队列组"><a href="#2-3-5-队列组" class="headerlink" title="2.3.5 队列组"></a>2.3.5 队列组</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 创建全局队列<br>dispatch_queue_t queue = dispatch_get_global_queue(0, 0);<br>// 创建队列组<br>dispatch_group_t group = dispatch_group_create();<br>/**<br>1. 封装任务<br>2. 把任务添加到队列<br>3. 监听任务的执行情况，通知group<br>*/<br>dispatch_group_async(group, queue, ^&#123;<br>NSLog(@&quot;任务1--%@&quot;,[NSThread currentThread]);<br>&#125;);<br>dispatch_group_async(group, queue, ^&#123;<br>NSLog(@&quot;任务2--%@&quot;,[NSThread currentThread]);<br>&#125;);<br>dispatch_group_async(group, queue, ^&#123;<br>NSLog(@&quot;任务3--%@&quot;,[NSThread currentThread]);<br>&#125;);<br>// 拦截通知，当队列组中所有任务都执行完毕的时候进入下面的方法<br>dispatch_group_notify(group, queue, ^&#123;<br>NSLog(@&quot;任务完成&quot;);<br>&#125;);<br>NSLog(@&quot;--end---&quot;);<br><br>// log <br>--end---<br>任务2--&lt;NSThread: 0x600001e79ec0&gt;&#123;number = 6, name = (null)&#125;<br>任务1--&lt;NSThread: 0x600001e66440&gt;&#123;number = 7, name = (null)&#125;<br>任务3--&lt;NSThread: 0x600001e7aec0&gt;&#123;number = 8, name = (null)&#125;<br>任务完成<br></code></pre></td></tr></table></figure><h4 id="3-NSOperation"><a href="#3-NSOperation" class="headerlink" title="3. NSOperation"></a>3. NSOperation</h4><p><code>NSOperation</code>配合<code>NSOperationQueue</code>也能实现多线程编程</p><p><code>NSOperation</code>和<code>NSOperationQueue</code>实现多线程的具体步骤：</p><ul><li>先将需要执行的操作封装到一个<code>NSOperation</code>对象中</li><li>然后将<code>NSOperation</code>对象添加到<code>NSOperationQueue</code>中</li><li>系统会自动将<code>NSOperationQueue</code>中的<code>NSOperation</code>取出来</li><li>将取出的<code>NSOperation</code>封装的操作放到一条新线程中执行</li></ul><h5 id="3-1-NSOperation的子类"><a href="#3-1-NSOperation的子类" class="headerlink" title="3.1 NSOperation的子类"></a>3.1 NSOperation的子类</h5><p>NSOperation是一个抽象类，并不具备封装操作的能力，必须使用它的子类</p><p>使用NSOperation子类的方式有3中：</p><ul><li>NSInvocationOperation</li><li>NSBLockOperation</li><li>自定义子类继承NSOperation，实现内部相应的方法</li></ul><h6 id="3-1-1-NSInvocationOperation"><a href="#3-1-1-NSInvocationOperation" class="headerlink" title="3.1.1 NSInvocationOperation"></a>3.1.1 NSInvocationOperation</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 创建操作封装任务<br>/**<br>第一个参数：目标对象<br>第二个参数：调用方法的名称<br>第三个参数：前面方法需要接收的参数<br>*/<br>NSInvocationOperation *op = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(task) object:nil];<br>// 执行操作<br>[op start];<br><br>-(void)task&#123;<br>    NSLog(@&quot;%s--%@&quot;,__func__,[NSThread currentThread]);<br>&#125;<br><br>// log <br>-[ViewController task]--&lt;_NSMainThread: 0x6000039c4040&gt;&#123;number = 1, name = main&#125;<br></code></pre></td></tr></table></figure><p>和NSOperationQueue一起使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 创建操作封装任务<br>NSInvocationOperation *op1 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(task1) object:nil];<br> NSInvocationOperation *op2 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(task2) object:nil];<br>NSInvocationOperation *op3 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(task3) object:nil];<br>// 创建队列<br>/**<br>主队列：[NSOperationQueue mainQueue]和GCD主队列一样，串行执行<br>非主队列：[[NSOperationQueue alloc]init] 非常特殊（同时具备串行和并发的功能）默认情况下非主队列是并发队列<br>*/<br>NSOperationQueue *queue = [[NSOperationQueue alloc]init];<br>[queue addOperation:op1]; //内部调用了[op1 start]<br>[queue addOperation:op2];<br>[queue addOperation:op3];<br><br>-(void)task1&#123;<br>    NSLog(@&quot;%s--%@&quot;,__func__,[NSThread currentThread]);<br>&#125;<br>-(void)task2&#123;<br>    NSLog(@&quot;%s--%@&quot;,__func__,[NSThread currentThread]);<br>&#125;<br>-(void)task3&#123;<br>    NSLog(@&quot;%s--%@&quot;,__func__,[NSThread currentThread]);<br>&#125;<br><br>// log<br>-[ViewController task1]--&lt;NSThread: 0x600003d04880&gt;&#123;number = 7, name = (null)&#125;<br>-[ViewController task2]--&lt;NSThread: 0x600003d16340&gt;&#123;number = 8, name = (null)&#125;<br>-[ViewController task3]--&lt;NSThread: 0x600003d002c0&gt;&#123;number = 9, name = (null)&#125;<br></code></pre></td></tr></table></figure><h6 id="3-1-2-NSBlockOperation"><a href="#3-1-2-NSBlockOperation" class="headerlink" title="3.1.2 NSBlockOperation"></a>3.1.2 NSBlockOperation</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 创建操作<br>NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;<br>NSLog(@&quot;任务1--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;<br>NSLog(@&quot;任务2--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;<br>NSLog(@&quot;任务3--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>// 追加任务<br>// 注意：如果一个操作的任务数量大于1，那么会开子线程并发执行<br>// 注意：不一定是子线程，有可能是主线程<br>[op3 addExecutionBlock:^&#123;<br>NSLog(@&quot;任务4--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>[op3 addExecutionBlock:^&#123;<br>NSLog(@&quot;任务5--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>[op3 addExecutionBlock:^&#123;<br>NSLog(@&quot;任务6--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>    <br>[op1 start];<br>[op2 start];<br>[op3 start];<br>// log<br>任务1--&lt;_NSMainThread: 0x60000116c1c0&gt;&#123;number = 1, name = main&#125;<br>任务2--&lt;_NSMainThread: 0x60000116c1c0&gt;&#123;number = 1, name = main&#125;<br>任务5--&lt;_NSMainThread: 0x60000116c1c0&gt;&#123;number = 1, name = main&#125;<br>任务3--&lt;NSThread: 0x600001177a00&gt;&#123;number = 4, name = (null)&#125;<br>任务4--&lt;NSThread: 0x60000113d2c0&gt;&#123;number = 7, name = (null)&#125;<br>任务6--&lt;NSThread: 0x600001122640&gt;&#123;number = 6, name = (null)&#125;<br></code></pre></td></tr></table></figure><p>和NSOperationQueue一起使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 创建操作<br>NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;<br>NSLog(@&quot;任务1--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;<br>NSLog(@&quot;任务2--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;<br>NSLog(@&quot;任务3--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>[op3 addExecutionBlock:^&#123;<br>NSLog(@&quot;任务4--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>[op3 addExecutionBlock:^&#123;<br>NSLog(@&quot;任务5--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>[op3 addExecutionBlock:^&#123;<br>NSLog(@&quot;任务6--%@&quot;,[NSThread currentThread]);<br>&#125;];<br>// 创建队列<br>NSOperationQueue *queue = [[NSOperationQueue alloc]init];<br>// 将操作添加到队列中<br>[queue addOperation:op1];<br>[queue addOperation:op2];<br>[queue addOperation:op3];<br><br>// log<br>任务3--&lt;NSThread: 0x600001b282c0&gt;&#123;number = 5, name = (null)&#125;<br>任务2--&lt;NSThread: 0x600001b32640&gt;&#123;number = 6, name = (null)&#125;<br>任务1--&lt;NSThread: 0x600001b67680&gt;&#123;number = 4, name = (null)&#125;<br>任务4--&lt;NSThread: 0x600001b2cb40&gt;&#123;number = 3, name = (null)&#125;<br>任务5--&lt;NSThread: 0x600001b3fc80&gt;&#123;number = 7, name = (null)&#125;<br>任务6--&lt;NSThread: 0x600001b62340&gt;&#123;number = 8, name = (null)&#125;<br><br>// 简单使用<br>[queue addOperationWithBlock:^&#123;// 相当于创建操作后将操作添加到队列中<br>NSLog(@&quot;任务7--%@&quot;,[NSThread currentThread]);<br>&#125;];<br></code></pre></td></tr></table></figure><h6 id="3-1-3-自定义子类"><a href="#3-1-3-自定义子类" class="headerlink" title="3.1.3 自定义子类"></a>3.1.3 自定义子类</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 继承NSOperation，重写mian方法<br>/**<br> 告知要执行的任务<br> 1. 有利于代码隐藏<br> 2. 复用性<br> */<br>- (void)main&#123;<br>    NSLog(@&quot;main---%@&quot;,[NSThread currentThread]);<br>&#125;<br>---------------------------------------<br>TOperation *op1 = [[TOperation alloc]init];<br>TOperation *op2 = [[TOperation alloc]init];<br>NSOperationQueue *queue = [[NSOperationQueue alloc]init];<br>[queue addOperation:op1];<br>[queue addOperation:op2];<br><br>// log<br>main---&lt;NSThread: 0x60000149acc0&gt;&#123;number = 7, name = (null)&#125;<br>main---&lt;NSThread: 0x600001496580&gt;&#123;number = 8, name = (null)&#125;<br></code></pre></td></tr></table></figure><h5 id="3-2-NSOperation的其它用法"><a href="#3-2-NSOperation的其它用法" class="headerlink" title="3.2 NSOperation的其它用法"></a>3.2 NSOperation的其它用法</h5><h6 id="3-2-1-最大并发数"><a href="#3-2-1-最大并发数" class="headerlink" title="3.2.1 最大并发数"></a>3.2.1 最大并发数</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 同一时间最多有多少任务可以执行<br>// maxConcurrentOperationCount &gt; 1 并发队列<br>// maxConcurrentOperationCount == 1 串行队列<br>// maxConcurrentOperationCount == 0 不会执行<br>// maxConcurrentOperationCount == -1 特殊意义 最大值 表示不受限制<br>queue.maxConcurrentOperationCount = 1;<br>// 注意：串行执行任务 != 只开一条线程（线程同步）<br></code></pre></td></tr></table></figure><h6 id="3-2-2-暂停"><a href="#3-2-2-暂停" class="headerlink" title="3.2.2 暂停"></a>3.2.2 暂停</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 不能暂停当前正在处于执行状态的任务<br>[queue setSuspended:YES];<br></code></pre></td></tr></table></figure><h6 id="3-2-3-恢复"><a href="#3-2-3-恢复" class="headerlink" title="3.2.3 恢复"></a>3.2.3 恢复</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">[queue setSuspended:NO];<br></code></pre></td></tr></table></figure><h6 id="3-2-4-取消"><a href="#3-2-4-取消" class="headerlink" title="3.2.4 取消"></a>3.2.4 取消</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 取消，不可恢复<br>[queue cancelAllOperations];<br></code></pre></td></tr></table></figure><blockquote><p>注意自定义的<code>NSOperation</code>，<code>mian</code>函数的多个任务是无法被暂停的，它对于<code>queue</code>来说这个<code>main</code>函数里面是一个任务。</p><p>可以通过判断<code>isCancelled</code>的状态，取消任务（<code>if(self.isCancelled) Return</code>）</p></blockquote><h6 id="3-2-5-操作依赖和监听"><a href="#3-2-5-操作依赖和监听" class="headerlink" title="3.2.5 操作依赖和监听"></a>3.2.5 操作依赖和监听</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 添加操作依赖 可以夸队列依赖<br>[op1 addDependency:op2];<br></code></pre></td></tr></table></figure><blockquote><p>注意：不能循环依赖</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 操作监听<br>op1.completionBlock = ^&#123;<br>NSLog(@&quot;操作完成&quot;);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="三、多线程安全隐患及解决方案"><a href="#三、多线程安全隐患及解决方案" class="headerlink" title="三、多线程安全隐患及解决方案"></a>三、多线程安全隐患及解决方案</h3><ul><li><p>资源共享</p><p>一块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</p></li><li><p>当多个线程访问同一块资源，很容易引起数据错乱和数据安全问题</p></li></ul><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203151723521.png" alt="安全隐患" style="zoom:40%;margin-left:10px" /><p>解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后次序进行）</p><p>常见的线程同步技术是：加锁</p><p>互斥锁</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203151726535.png" alt="互斥锁" style="zoom: 25%;margin-left:10px" /><p>互斥锁使用前提：多条线程抢用同一块资源</p><p>互斥锁使用格式：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 是对mutex recursive的封装 <br>@synchronized (锁对象（一般是self）) &#123;// 需要锁定的代码&#125;<br></code></pre></td></tr></table></figure><p>互斥锁的优缺点：</p><ul><li>优点：能有效防止因多线程抢夺资源造成的数据安全问题</li><li>缺点：需要消耗大量的CPU资源</li></ul><p>另外介绍接种锁🔐：</p><h4 id="1-OSSpinLock"><a href="#1-OSSpinLock" class="headerlink" title="1. OSSpinLock"></a>1. OSSpinLock</h4><p>OSSpinLock叫做“自旋锁”，等待所的线程会处于忙等（busy-wait）状态，一直占用着CPU资源 </p><blockquote><p>注意：目前已经不再安全，可能会出现优先级反转问题（如果等待锁的线程优先级比较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;libkern/OSAtomic.h&gt;<br><br>// 初始化<br>OSSpinLock lock = OS_SPINLOCK_INIT;<br>// 尝试加锁（如果需要等待就不加锁，直接返回false；如果不需要等待就加锁，返回true）<br>bool result = OSSpinLockTry(&amp;lock)；<br>// 加锁<br>OSSpinLockLock(&amp;lock);<br>// 解锁<br>OSSpinLockUnlock(&amp;lock);<br></code></pre></td></tr></table></figure><h4 id="2-os-unfair-lock"><a href="#2-os-unfair-lock" class="headerlink" title="2. os_unfair_lock"></a>2. os_unfair_lock</h4><p>os_unfair_lock用于取代不安全的NSSpinLock，从iOS10 才开始支持</p><p>从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;os/lock.h&gt;<br><br>// 初始化<br>os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;<br>// 尝试加锁<br>os_unfair_lock_trylock(&amp;lock);<br>// 加锁<br>os_unfair_lock_lock(&amp;lock);<br>// 解锁<br>os_unfair_lock_unlock(&amp;lock);<br></code></pre></td></tr></table></figure><h4 id="3-pthread-mutex"><a href="#3-pthread-mutex" class="headerlink" title="3. pthread_mutex"></a>3. pthread_mutex</h4><p>mutex叫做<font color=orange>互斥锁</font>，等待锁的线程会处于休眠状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;pthread.h&gt;<br><br>@property(nonatomic, assign) pthread_mutex_t mutex;<br><br>// 初始化锁的属性<br>pthread_mutexattr_t attr;<br>pthread_mutexattr_init(&amp;attr);<br>// 设置属性<br>/**<br>Mutex type attributes<br>#define PTHREAD_MUTEX_NORMAL        0<br>#define PTHREAD_MUTEX_ERRORCHECK    1<br>#define PTHREAD_MUTEX_RECURSIVE        2  //递归锁<br>#define PTHREAD_MUTEX_DEFAULT        PTHREAD_MUTEX_NORMAL<br>*/<br>pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);<br>// 初始化锁<br>pthread_mutex_init(&amp;_mutex, &amp;attr);<br><br>// 尝试加锁<br>pthread_mutex_trylock(&amp;_mutex);<br>// 加锁<br>pthread_mutex_lock(&amp;_mutex);<br>// 解锁<br>pthread_mutex_unlock(&amp;_mutex);<br>// 销毁相关资源<br>pthread_mutexattr_destroy(&amp;attr);<br>pthread_mutex_destroy(&amp;_mutex);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 条件<br>// 初始化锁<br>pthread_mutex_t mutex;<br>// NULL岱庙使用默认属性<br>pthread_mutex_init(&amp;mutex, NULL);<br>// 初始化条件<br>pthread_cond_t cond;<br>pthread_cond_init(&amp;cond，NULL);<br>// 等待条件(进入休眠状态，放开mutex锁；被唤醒后，会再次对mutex加锁)<br>pthread_cond_wait(cond，&amp;mutex);<br>// 激活一个等待该条件的线程<br>pthread_cond_signal(&amp;cond);<br>// 激活所有等待该条件的线程<br>pthread_cond_broadcast(&amp;cond);<br>// 销毁资源<br>pthread_mutex_destroy(&amp;mutex);<br>pthread_cond_destory(&amp;cond);<br><br></code></pre></td></tr></table></figure><h4 id="4-NSLock、NSRecursiveLock、NSCondition"><a href="#4-NSLock、NSRecursiveLock、NSCondition" class="headerlink" title="4. NSLock、NSRecursiveLock、NSCondition"></a>4. NSLock、NSRecursiveLock、NSCondition</h4><p>NSLock是对mutex普通锁的封装。</p><p>NSRecursiveLock是对mutex递归锁的封装，API跟NSLock基本一致。</p><p>NSCondition是对mutex和condition的封装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 初始化锁<br>NSLock *lock = [[NSlock alloc] init];<br>// 尝试加锁<br>[lock tryLock];<br>// 加锁<br>[lock lock];<br>// 解锁<br>[lock unlock];<br></code></pre></td></tr></table></figure><h4 id="5-dispatch-queue"><a href="#5-dispatch-queue" class="headerlink" title="5. dispatch_queue"></a>5. dispatch_queue</h4><p>直接使用GCD的串行队列，也可以实现线程同步</p><h4 id="6-dispatch-semaphore"><a href="#6-dispatch-semaphore" class="headerlink" title="6. dispatch_semaphore"></a>6. dispatch_semaphore</h4><ul><li>semaphore叫做”信号量“</li><li>信号量的初始值，可以用来控制线程并发访问的最大数量</li><li>信号量初始值为1，代表同时只允许一条线程访问资源，保证线程同步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 信号量的初始值<br>int value = 1;<br>dispatch_semaphore_t semaphore = dispatch_semophore_creat(value);<br>// 如果信号量的值&lt;=0，当前线程就会及如休眠状态（直到信号量的值&gt;0）<br>// 如果信号量的值&gt;0，就减1，然后往下执行后面的代码<br>dispatch_semaphore_wait(semaphore,DISAPTCH_TIME_FOREVER)；<br>// 让信号量的值加1<br>dispatch_semaphore_signal(semaphore);<br></code></pre></td></tr></table></figure><h3 id="四、iOS中读写安全方案"><a href="#四、iOS中读写安全方案" class="headerlink" title="四、iOS中读写安全方案"></a>四、iOS中读写安全方案</h3><p>经典场景“多读单写”</p><h4 id="1-pthread-rwlock"><a href="#1-pthread-rwlock" class="headerlink" title="1. pthread_rwlock"></a>1. pthread_rwlock</h4><p>读写锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &quot;pthread.h&quot;<br><br>@property(nonatomic, assign) pthread_rwlock_t lock;<br><br>// 初始化锁<br>pthread_rwlock_t lock;<br>// 读-加锁<br>pthread_rwlock_rdlock(&amp;_lock);<br>// 读-尝试加锁<br>pthread_rwlock_tryrdlock(&amp;_lock);<br>// 写-加锁<br>pthread_rwlock_wrlock(&amp;_lock);<br>// 写-尝试加锁<br>pthread_rwlock_trywrlock(&amp;_lock);<br>// 解锁<br>pthread_rwlock_unlock(&amp;_lock);<br>// 销毁<br>pthread_rwlock_destroy(&amp;_lock);<br></code></pre></td></tr></table></figure><h4 id="2-dispatch-barrrier-async"><a href="#2-dispatch-barrrier-async" class="headerlink" title="2. dispatch_barrrier_async"></a>2. dispatch_barrrier_async</h4><p>异步栅栏调用</p><ul><li>这个函数传入的并发队列必须是自己通过dispatch_queue_create创建的</li><li>如果传入的是一个串行或是一个全局的并发队列，那这个函数等同于dispatch_async函数的结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);<br>// 读<br>dispatch_async(queue, ^&#123;<br><br>&#125;);<br>// 写<br>dispatch_barrier_async(queue, ^&#123;<br><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li><p>下面代码打印结果是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);<br>dispatch_async(queue, ^&#123;<br>   NSLog(@&quot;1&quot;);<br>   [self performSelector:@selector(test) withObject:nil afterDelay:.0];<br>   NSLog(@&quot;3&quot;);<br>&#125;);<br><br>-(void)test&#123;<br>    NSLog(@&quot;2&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：1、3</p><p>原因：</p><p>performSelect:withObject:afterDely:的本质是往runloop中添加定时器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 在GNUStep中查看performSelect的底层实现<br>- (void) performSelector: (SEL)aSelector<br>      withObject: (id)argument<br>      afterDelay: (NSTimeInterval)seconds<br>&#123;<br>  NSRunLoop*loop = [NSRunLoop currentRunLoop];<br>  GSTimedPerformer*item;<br><br>  item = [[GSTimedPerformer alloc] initWithSelector: aSelector<br>     target: self<br>   argument: argument<br>      delay: seconds];<br>  [[loop _timedPerformers] addObject: item];<br>  RELEASE(item);<br>  [loop addTimer: item-&gt;timer forMode: NSDefaultRunLoopMode];<br>&#125;<br></code></pre></td></tr></table></figure><p>子线程默认是没有开启runloop的</p><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);<br>    dispatch_async(queue, ^&#123;<br>        NSLog(@&quot;1&quot;);<br>        [self performSelector:@selector(test) withObject:nil afterDelay:.0];<br>        NSLog(@&quot;3&quot;);<br>        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];<br>    &#125;);<br><br>-(void)test&#123;<br>    NSLog(@&quot;2&quot;);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p> 下面代码的执行结果？</p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSThread *thread = [[NSThread alloc]initWithBlock:^&#123;<br>NSLog(@&quot;1&quot;);<br>&#125;];<br>[thread start];<br>[self performSelector:@selector(test) onThread:thread withObject:nil waitUntilDone:YES];<br><br>-(void)test&#123;<br>    NSLog(@&quot;2&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>   执行结果：打印1; 抛出<code>target thread exited while waiting for the perform</code>异常</p><p>   原因：子线程在完成block中的代码后，退出了</p><p>   解决方法：</p>   <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSThread</span> *thread = [[<span class="hljs-built_in">NSThread</span> alloc]initWithBlock:^&#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>[[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="hljs-built_in">NSPort</span> alloc]init] forMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span>];<br>[[<span class="hljs-built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="hljs-built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="hljs-built_in">NSDate</span> distantFuture]];<br>&#125;];<br>[thread start];<br>[<span class="hljs-keyword">self</span> performSelector:<span class="hljs-keyword">@selector</span>(test) onThread:thread withObject:<span class="hljs-literal">nil</span> waitUntilDone:<span class="hljs-literal">YES</span>];<br><br>-(<span class="hljs-keyword">void</span>)test&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>如何使用GCD实现以下功能，异步并发执行任务1和任务2，都执行完成之后回到主线程执行任务3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 创建队列组<br>dispatch_group_t group = dispatch_group_create();<br>// 创建并发队列<br>dispatch_queue_t queue = dispatch_queue_create(&quot;my_queue&quot;, DISPATCH_QUEUE_CONCURRENT);<br>// 添加异步任务<br>dispatch_group_async(group, queue, ^&#123;<br>    NSLog(@&quot;任务1&quot;);<br>&#125;);<br>dispatch_group_async(group, queue, ^&#123;<br>    NSLog(@&quot;任务2&quot;);<br>&#125;);<br>// 回到主队列<br>dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;<br>NSLog(@&quot;任务3&quot;);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_RunLoop</title>
    <link href="/2022/03/08/iOS/%E5%A4%87%E8%80%83/Runtime&amp;Runloop/iOS_Runloop/"/>
    <url>/2022/03/08/iOS/%E5%A4%87%E8%80%83/Runtime&amp;Runloop/iOS_Runloop/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是RunLoop"><a href="#一、什么是RunLoop" class="headerlink" title="一、什么是RunLoop"></a>一、什么是RunLoop</h3><p>顾名思义运行循环，在程序运行中循环做一些事情</p><p>应用范畴：</p><ul><li>定时器（Timer）、PerformSelector</li><li>GCD  Async Main Queue</li><li>事件响应、手势识别、界面刷新</li><li>网络请求</li><li>AutoreleasePool</li></ul><p>RunLoop的基本作用：</p><ul><li>保持程序的持续运行（没有runloop程序会马上退出）</li><li>处理App中的各种事件（比如触摸事件、定时器事件）</li><li>节省CPU资源，提高程序性能（需要做事的时候做事，没事做的时候休息 ）</li><li>等等</li></ul><h3 id="二、RunLoop对象"><a href="#二、RunLoop对象" class="headerlink" title="二、RunLoop对象"></a>二、RunLoop对象</h3><p>iOS中有两套API来访问和使用<code>RunLoop</code>，<code>Foundation</code>框架下的<code>NSRunLoop</code>和<code>Core Foundation</code>框架下的<code>CFRunLoopRef</code>，它们都代表着<code>RunLoop</code>对象。其中<code>NSRunLoop</code>是基于<a href="https://opensource.apple.com/tarballs/CF/">CFRunLoopRef</a>的一层OC包装。</p><p>获取RunLoopd对象：</p><ol><li><p>Foundation</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 获取当前线程runloop<br>[NSRunLoop currentRunLoop];<br>// 获取主线程runloop<br>[NSRunLoop mainRunLoop];<br></code></pre></td></tr></table></figure></li><li><p>CoreFoundation</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 获取当前线程runloop<br>CFRunLoopGetCurrent();<br>// 获取主线程runloop<br>CFRunLoopGetMain();<br></code></pre></td></tr></table></figure></li></ol><h3 id="三、RunLoop与线程"><a href="#三、RunLoop与线程" class="headerlink" title="三、RunLoop与线程"></a>三、RunLoop与线程</h3><ol><li>每条线程都有唯一的一个与之对应的<code>RunLoop</code>对象</li><li><code>RunLoop</code>保存在一个全局的<code>Dictionary</code>中，线程作为key，<code>RunLoop</code>作为value</li><li>线程刚创建的时候并没有<code>RunLoop</code>对象，<code>RunLoop</code>对象会在第一次获取它的时候创建</li><li><code>RunLoop</code>会在线程结束时销毁</li><li>主线程的<code>RunLoop</code>已经自动获取（创建），子线程默认没有开启<code>RunLoop</code></li></ol><h3 id="四、RunLoop相关的类"><a href="#四、RunLoop相关的类" class="headerlink" title="四、RunLoop相关的类"></a>四、RunLoop相关的类</h3><p>Core Foundation中关于RunLoop的五个类：</p><ul><li>CFRunLoopRef</li><li>CFRunLoopModeRef</li><li>CFRunLoopScorceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopRef</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoop</span>&#123;</span><br>  <span class="hljs-keyword">pthread_t</span> _pthread; <br>  CFMutableSetRef _commonModes;<br>  CFMutableSetRef _commonModeItems;<br>  CFRunLoopModeRef _currentMoode;<br>  CFMutableSetRef _modes;<br>&#125;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopMode</span> *<span class="hljs-title">CFRunLoopModeRef</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">CFRunLoopMode</span>&#123;</span><br>  CFStringRef _name;<br>  CFMutableSetRef _sources0;<br>  CFMutableSetRef _sources1;<br>  CFMutableArrayRef _Observers;<br>  CFMutableArrayRef _timers;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-CFRunLoopModeRef"><a href="#1-CFRunLoopModeRef" class="headerlink" title="1. CFRunLoopModeRef"></a>1. CFRunLoopModeRef</h4><ul><li>CFRunLoopModeRef代表RunLoop的运行模式</li><li>一个RunLoop包含若干个Mode，每个Mode又包含若干个Sources0/Sources1/Timer/Observer</li><li>RunLoop启动时只能选择其中一个Mode，作为当前的currentMode</li><li>如果要切换Mode，只能退出当前的loop，重新选择一个Mode进入（不同组的Sources0/Source1/Timer/Observer能分割开来，互不影响）</li><li>如果Mode里面没有任何的Sources0/Sources1/Timer/Obsercer，RunLoop会立马退出</li></ul><p>常见的两种CFRunLoopModeRef：</p><ul><li><p>kCFRunLoopDefeaultMode（NSDefeaultRunLoopMode）</p><p>App的默认Mode，通常主线程是在这个Mode下运行的</p></li><li><p>UITrackingRunLoopMode</p><p>界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不收其他Mode的影响</p></li></ul><h4 id="2-CFRunLoopObserverRef"><a href="#2-CFRunLoopObserverRef" class="headerlink" title="2. CFRunLoopObserverRef"></a>2. CFRunLoopObserverRef</h4><p>RunLoop的所有状态枚举</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">CF_OPTIONS</span><span class="hljs-params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;<br>    kCFRunLoopEntry = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">0</span>),<span class="hljs-comment">// 即将进入runloop</span><br>    kCFRunLoopBeforeTimers = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">1</span>),    <span class="hljs-comment">// 即将处理Timer</span><br>    kCFRunLoopBeforeSources = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">2</span>),   <span class="hljs-comment">// 即将处理Source</span><br>    kCFRunLoopBeforeWaiting = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">5</span>),   <span class="hljs-comment">// 即将进入休眠</span><br>    kCFRunLoopAfterWaiting = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">6</span>),    <span class="hljs-comment">// 刚从休眠中唤醒</span><br>    kCFRunLoopExit = (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">7</span>),<span class="hljs-comment">// 即将退出runloop</span><br>    kCFRunLoopAllActivities = <span class="hljs-number">0x0FFFFFFF</span>U<br>&#125;;<br></code></pre></td></tr></table></figure><p>添加Observer监听RunLoop的所有状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;<br>    switch (activity) &#123;<br>        case kCFRunLoopEntry:<br>            NSLog(@&quot;kCFRunLoopEntry&quot;);<br>            break;<br>        case kCFRunLoopBeforeTimers:<br>            NSLog(@&quot;kCFRunLoopBeforeTimers&quot;);<br>            break;<br>        case kCFRunLoopBeforeSources:<br>            NSLog(@&quot;kCFRunLoopBeforeSources&quot;);<br>            break;<br>        case kCFRunLoopBeforeWaiting:<br>            NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;);<br>            break;<br>        case kCFRunLoopAfterWaiting:<br>            NSLog(@&quot;kCFRunLoopAfterWaiting&quot;);<br>            break;<br>       case kCFRunLoopExit:<br>            NSLog(@&quot;kCFRunLoopExit&quot;);<br>            break;        <br>        default:<br>            break;<br>    &#125;<br>&#125;);<br>CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopCommonModes);<br>CFRelease(observer);<br></code></pre></td></tr></table></figure><h3 id="五、RunLoop的运行逻辑"><a href="#五、RunLoop的运行逻辑" class="headerlink" title="五、RunLoop的运行逻辑"></a>五、RunLoop的运行逻辑</h3><ol><li>通知Observers：进入runloop</li><li>通知Observers：即将处理Timers</li><li>通知Observers：即将处理Sources</li><li>处理Blocks</li><li>处理Source0（可能会再次处理Blocks）</li><li>如果存在Sources1，就跳到第8步</li><li>通知Observers：开始休眠（等待消息唤醒） </li><li>通知Observers：结束休眠（被某个消息唤醒）<ul><li>处理Timer</li><li>处理GCD Async To Main Queue</li><li>处理Source1</li></ul></li><li>处理Blocks</li><li>根据前面的执行结果，决定如何操作<ul><li>回到第二步</li><li>退出runloop</li></ul></li><li>通知Observers：退出runloop</li></ol><h4 id="Sources0"><a href="#Sources0" class="headerlink" title="Sources0"></a>Sources0</h4><ul><li>触摸事件处理</li><li>performSelector:onThread:</li></ul><h4 id="Sources1"><a href="#Sources1" class="headerlink" title="Sources1"></a>Sources1</h4><ul><li>基于Port的线程间通信</li><li>系统事件捕捉</li></ul><h4 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h4><ul><li>NSTimer</li><li>perfromSelector:withObject:afterDelay:</li></ul><h4 id="Observers"><a href="#Observers" class="headerlink" title="Observers"></a>Observers</h4><ul><li>用于监听runloop的刷新状态</li><li>UI刷新（BeforeWaiting）</li><li>Autorelease pool （BeforWaiting）</li></ul><h3 id="六、实际应用"><a href="#六、实际应用" class="headerlink" title="六、实际应用"></a>六、实际应用</h3><h4 id="1-解决NSTimer在滑动时停止工作的问题"><a href="#1-解决NSTimer在滑动时停止工作的问题" class="headerlink" title="1. 解决NSTimer在滑动时停止工作的问题"></a>1. 解决NSTimer在滑动时停止工作的问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">static int a = 1;<br>NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;<br>    NSLog(@&quot;%d&quot;,a++);<br>&#125;];<br>//定时器默认工作在NSDefaultRunLoopMode模式下，当我们对控制器中视图进行拖拽的时候，currentMode会进入到UITrackingRunLoopMode模式下，导致定时器在拖拽过程中不运行<br>// 解决方法是，将timer放到NSRunLoopCommonModes 模式下。但是这里的NSRunLoopCommonModes并不是真正的模式，它只是一个标记<br>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; <br></code></pre></td></tr></table></figure><h4 id="2-控制线程生命周期（线程保活）"><a href="#2-控制线程生命周期（线程保活）" class="headerlink" title="2. 控制线程生命周期（线程保活）"></a>2. 控制线程生命周期（线程保活）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;Foundation/Foundation.h&gt;<br><br>NS_ASSUME_NONNULL_BEGIN<br><br>typedef void (^TPermenantThreadTask)(void);<br><br>@interface TPermenantThread : NSObject<br>/**<br> 开启一个线程<br> */<br>-(void)run;<br>/**<br> 结束一个线程<br> */<br>-(void)stop;<br>/**<br> 执行一个任务<br> */<br>-(void)executeTask:(TPermenantThreadTask)task;<br><br>@end<br><br>NS_ASSUME_NONNULL_END<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &quot;TPermenantThread.h&quot;<br>@interface TPermenantThread()<br>@property(nonatomic, strong)NSThread *innerThread;<br>@property(nonatomic, assign, getter=isStopped)BOOL stopped;<br>@end<br><br>@implementation TPermenantThread<br><br>- (instancetype)init&#123;<br>    if (self = [super init]) &#123;<br>        self.stopped = NO;<br>        self.innerThread = [[NSThread alloc]initWithBlock:^&#123;<br>            // 添加port<br>            NSLog(@&quot;---begain--&quot;);<br>            [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc]init] forMode:NSDefaultRunLoopMode];<br>            __weak typeof(self) weakSelf = self;<br>            // 线程保活<br>            while(weakSelf &amp;&amp; !weakSelf.isStopped) &#123;<br>                // 启动runloop<br>                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];<br>            &#125;<br>            NSLog(@&quot;---end--&quot;);<br>        &#125;];<br>        [self.innerThread start];<br>    &#125;<br>    return  self;;<br>&#125;<br><br>- (void)run&#123;<br>    [self.innerThread start];<br>&#125;<br><br>- (void)stop&#123;<br>    if (!self.innerThread) return;<br>    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];<br>&#125;<br><br>- (void)executeTask:(TPermenantThreadTask)task&#123;<br>    if (!self.innerThread || !task) return;<br>    <br>    if (!self.innerThread.isExecuting) &#123;<br>        [self.innerThread start];<br>    &#125;<br>    <br>    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:task waitUntilDone:NO];<br>&#125;<br><br>- (void)dealloc&#123;<br>    [self stop];<br>&#125;<br><br>- (void)__stop&#123;<br>    self.stopped = YES;<br>    CFRunLoopStop(CFRunLoopGetCurrent());<br>    self.innerThread = nil;<br>&#125;<br><br>- (void)__executeTask:(TPermenantThreadTask)task&#123;<br>    task();<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2022/03/02/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2022/03/02/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p>所谓的位运算就是对一个比特（bit）位进行操作。bit是一个电子元器件，8个bit构成一个字节（Byte），它是粒度最小的可操作单元。</p><p>C和OC中常见类型及它们所占字节数：</p><table><thead><tr><th>C语言类型</th><th>所占字节(bit)</th><th>OC语言类型</th><th>所占字节(bit)</th></tr></thead><tbody><tr><td>int</td><td>4</td><td>NSInter</td><td>8</td></tr><tr><td>float</td><td>4</td><td>CGFloat</td><td>8</td></tr><tr><td>double</td><td>8</td><td>double</td><td>8</td></tr><tr><td>char</td><td>1</td><td>NSString</td><td>8</td></tr></tbody></table><p>C语言提供了六种位运算：</p><table><thead><tr><th>运算符</th><th>&amp;</th><th>|</th><th>^</th><th>-</th><th>&lt;&lt;</th><th>&gt;&gt;</th></tr></thead><tbody><tr><td>说明</td><td>按位与</td><td>按位或</td><td>按位异或</td><td>取反</td><td>左移</td><td>右移</td></tr></tbody></table><h3 id="一、按位与运算-（-amp-）"><a href="#一、按位与运算-（-amp-）" class="headerlink" title="一、按位与运算 （&amp;）"></a>一、按位与运算 （&amp;）</h3><p>一个bit位只有0和1两个取值，只有参与<code>&amp;</code>运算的两个位都为1时，结果才为1，否则为0。<code>&amp;</code>两边的操作数可以是十进制、八进制、十六进制，它们在内存中最终都是以二进制的形式存储。<code>&amp;</code>就是这些内存中的二进制位进行运算。例如<code>1&amp;1</code>为1，<code>1&amp;0</code>为0，<code>0&amp;0</code>为0。</p><p>例如，9&amp;5</p><p>​    0000 1001 （9的二进制）</p><p>&amp;  0000 0101（5的二进制）</p><hr><p>​    0000 0001</p><p>也就是说<code>9&amp;5</code>的结果为1。</p><h3 id="二、按位或运算（-）"><a href="#二、按位或运算（-）" class="headerlink" title="二、按位或运算（|）"></a>二、按位或运算（|）</h3><p>参与<code>|</code>运算的两个二进制位有一个为1时，结果为1。例如<code>0|1</code>为1，<code>1|1</code>为1，<code>0|0</code>为0。</p><p>例如，<code>9|5</code></p><p>​    0000 1001 （9的二进制）</p><p>|   0000 0101（5的二进制）</p><hr><p>​    0000 1101</p><p><code>9|5</code>的结果是13。</p><h3 id="三、按位异或运算（-）"><a href="#三、按位异或运算（-）" class="headerlink" title="三、按位异或运算（^）"></a>三、按位异或运算（^）</h3><p>参与^运算的两个二进制位不同的时，结果为1，例如<code>0^1</code>为1，<code>0^0</code>为0，1^1为0。</p><p>例如，<code>9^5</code></p><p>​    0000 1001 （9的二进制）</p><p>|   0000 0101（5的二进制）</p><hr><p>​    0000 1100</p><p><code>9^5</code>的结果是12。</p><h3 id="四、取反运算（-）"><a href="#四、取反运算（-）" class="headerlink" title="四、取反运算（~）"></a>四、取反运算（~）</h3><p>取反运算符<code>~</code>为单目运算符，作用是对参与运算的二进制位取反，例如：<code>~1</code>为0。</p><p>例如，<code>~9</code></p><p>~  0000 1001 （9的二进制）</p><hr><p>​    1111 0110 </p><p><code>~9</code>的结果为-10</p><blockquote><p>-9的二进制表达为9的二进制位（0000 1001）按位取反再+1，结果为1111 0111</p><p>1111 0110 代表的是负几的计算方式是，先-1得到1111 0101再按位取反得到0000 1010（10），所以最终结果为-10</p></blockquote><h3 id="五、左移运算（-lt-lt-）"><a href="#五、左移运算（-lt-lt-）" class="headerlink" title="五、左移运算（&lt;&lt;）"></a>五、左移运算（&lt;&lt;）</h3><p>左移运算符<code>&lt;&lt;</code>用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补0。</p><p>例如：<code>9&lt;&lt;2</code></p><p>&lt;&lt;  0000 1001 （9的二进制）</p><hr><p>​      0010 0100</p><p><code>9&lt;&lt;2</code>的结果为 36。</p><h3 id="六、右移运算（-gt-gt-）"><a href="#六、右移运算（-gt-gt-）" class="headerlink" title="六、右移运算（&gt;&gt;）"></a>六、右移运算（&gt;&gt;）</h3><p>右移运算符<code>&gt;&gt;</code>用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补0或1。如果数据的最高为为0，那么就补0；如果数据的最高位为1，那么就补1。</p><p>例如：<code>9&gt;&gt;2</code></p><p><em>&gt;&gt;</em>  0000 1001 （9的二进制）</p><hr><p>​      0000 0010</p><p><code>9&gt;&gt;2</code>的结果为2</p><p><font color= orange>声明：本文摘自&lt;C语言位运算&gt;</font></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://c.biancheng.net/cpp/html/101.html">C语言位运算</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_Runtime</title>
    <link href="/2022/03/01/iOS/%E5%A4%87%E8%80%83/Runtime&amp;Runloop/iOS_Runtime/"/>
    <url>/2022/03/01/iOS/%E5%A4%87%E8%80%83/Runtime&amp;Runloop/iOS_Runtime/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概念介绍"><a href="#一、概念介绍" class="headerlink" title="一、概念介绍"></a>一、概念介绍</h3><p>在学习 <code>runtime</code>之前，首先要了解它的底层的一些常用的数据结构，比如<code>isa</code>指针</p><ul><li>在<code>arm64</code>架构之前，<code>isa</code>就是一个普通的指针，存储着<code>class</code>、<code>meta-class</code>对象的内存地址</li><li>在<code>arm64</code>架构之后，对<code>isa</code>进行了优化，变成了一个共同体（<code>union</code>）结构，还使用位域来存储更多的信息</li></ul><h4 id="1-共同体"><a href="#1-共同体" class="headerlink" title="1. 共同体"></a>1. 共同体</h4><p>我们知道结构体（<code>Struct</code>）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做<em>共用体（<code>union</code>）</em>，它的定义格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> 共用体名&#123;</span><br>成员列表<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>共用体也被成为联合体</p></blockquote><p>结构体和共用体的区别：</p><p>结构体的各个成员会占用不同的内存，互相之间没有影响。而共用体所有成员共用一段内存，修改一个成员会影响其余所有成员。</p><p>结构体占用的内存大于等于所有成员占用的内存之和（成员之间可能会存在缝隙）。共用体占用的内存等于最长的成员占用的内存。共用体使用的是内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值就会把原来成员呢的值覆盖掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">union Bits &#123;<br>    int a;<br>    double b;<br>&#125;;<br><br>union Bits bits;<br>bits.a = 1;<br>bits.b = 2.0;<br>NSLog(@&quot;bits size= %ld&quot;,sizeof(bits));<br>NSLog(@&quot;a address = %p,b address = %p&quot;,&amp;bits.a,&amp;bits.b);<br>NSLog(@&quot;a = %d, b = %f&quot;,bits.a,bits.b);<br><br>// log <br>bits size= 8<br>a address = 0x7ff7b085bf68,b address = 0x7ff7b085bf68<br>a = 0, b = 2.000000<br></code></pre></td></tr></table></figure><h4 id="2-位域"><a href="#2-位域" class="headerlink" title="2. 位域"></a>2. 位域</h4><p>有些数据在存储时并不需要占用一个完整的字节，只需要占用就一个或者几个二进制位即可。例如开关只有通电和断点两种状态，用0和1表示足以，也就是用一个二进制位。正是基于这种考虑，C语言又提供了一种叫做位域的数据结构。</p><p>在定义结构体时，我们可以指定某个成员变量所占用的二进制位数（<code>Bit</code>）,这就是<em><strong>位域</strong></em>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bs</span> &#123;</span><br>  <span class="hljs-keyword">unsigned</span> m;<br>  <span class="hljs-keyword">unsigned</span> n:<span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> ch: <span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>:</code>后面的数字来限定成员变量占用的位数。</p><h4 id="3-isa详解"><a href="#3-isa详解" class="headerlink" title="3. isa详解"></a>3. isa详解</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">isa_t</span> </span><br><span class="hljs-class">&#123;</span><br>    Class cls;<br>    <span class="hljs-keyword">uintptr_t</span> bits;<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-keyword">uintptr_t</span> nonpointer        : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">uintptr_t</span> has_assoc         : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">uintptr_t</span> has_cxx_dtor      : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">uintptr_t</span> shiftcls          : <span class="hljs-number">33</span>; <span class="hljs-comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span><br>        <span class="hljs-keyword">uintptr_t</span> magic             : <span class="hljs-number">6</span>;<br>        <span class="hljs-keyword">uintptr_t</span> weakly_referenced : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">uintptr_t</span> deallocating      : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">uintptr_t</span> has_sidetable_rc  : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">uintptr_t</span> extra_rc          : <span class="hljs-number">19</span>;<br>    &#125;;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li><p>nonpointer</p><p>0，代表普通指针，存储着class、meta-class对象的内存地址</p><p>1，代表优化过，使用位域存储更多的信息</p></li><li><p>has_assoc</p><p>是否有设置过关联对象，如果没有释放时会更快</p></li><li><p>has_cxx_dtor</p><p>是否有c++的析构函数，如果没有释放时会更快</p></li><li><p>shiftcls</p><p>存储着class、meta-calss对象的内存地址信息</p></li><li><p>magic</p><p>用于在调试时分辨对象是否完成初始化</p></li><li><p>weakly_referenced</p><p>是否被弱引用指向过，若果没有，释放时更快</p></li><li><p>deallocating</p><p>对象是否正在释放</p></li><li><p>has_sidetable_rc</p><p>引用计数器是否过大无法存储在isa中</p><p>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</p></li><li><p>extra_rc</p><p>里面存储的值是引用计数器减1</p></li></ul><h4 id="4-class的结构"><a href="#4-class的结构" class="headerlink" title="4. class的结构"></a>4. class的结构</h4><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203032148241.png" alt="class的结构" style="zoom:67%;margin-left:10px" /><h5 id="4-1-calss-rw-t"><a href="#4-1-calss-rw-t" class="headerlink" title="4.1 calss_rw_t"></a>4.1 <strong>calss_rw_t</strong></h5><p><em>calss_rw_t</em>的<code>methods</code>、<code>properties</code>、<code>protocols</code>是二维数组，是可读可写的，包含了类的初始内容、分类的内容</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203032152900.png" alt="calss_rw_t" style="zoom:50%;margin-left:10px" /><h5 id="4-2-class-ro-t"><a href="#4-2-class-ro-t" class="headerlink" title="4.2 class_ro_t"></a>4.2 class_ro_t</h5><p><em>class_ro_t</em>的<code>baseMethodList</code>、<code>baseProperties</code>、<code>baseProtocols</code>、<code>ivars</code>是一维数组，是可读的，包含了类的初始内容</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203032157596.png" alt="class_ro_t" style="zoom:50%;margin-left:10px" /><h5 id="4-3-method-t"><a href="#4-3-method-t" class="headerlink" title="4.3 method_t"></a>4.3 method_t</h5><p><em>method_t</em>是对方法/函数的封装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">method_t</span>&#123;</span><br>SEL name;<span class="hljs-comment">// 函数名</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *types;<span class="hljs-comment">// 编码（返回值类型、参数类型）</span><br>  IMP imp; <span class="hljs-comment">// 指向函数的指针（函数地址）</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><em>IMP</em>代表函数的具体实现</p></li><li><p><em>SEL</em>代表方法/函数名，一般叫做选择器，底层结构跟<code>char*</code>类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;objc/runtime.h&gt;<br><br>//前提：已创建一个带有test方法的类<br>// 获取SEL<br>SEL sel1 = @selector(test);<br>SEL sel2 = sel_registerName(&quot;test&quot;);<br>// 获取SEL名称<br>NSString *sel1Name = NSStringFromSelector(sel1);<br>const char * sel2Name = sel_getName(sel2);<br>    <br>NSLog(@&quot;%p, %p&quot;,sel1,sel2);<br>NSLog(@&quot;%@, %s&quot;,sel1Name,sel2Name);<br>// log <br>0x7fff6e2268ec, 0x7fff6e2268ec<br>test, test<br></code></pre></td></tr></table></figure><ul><li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li><li>可以通过<code>NSStringFromSelector()</code>和<code>sel_getName()</code>转成字符串</li><li>不同类中相同名字的方法，所对应的方法选择器是相同的</li></ul></li><li><p>types</p><p>types包含了函数返回值、参数编码的字符串</p><table><thead><tr><th>返回值</th><th>参数1</th><th>参数2</th><th>…</th><th>参数n</th></tr></thead></table><p>iOS提供了一种叫做<font color=orange>@encode</font>的指令，可以将具体类型表示为字符串编码。</p><p>下面是部分Type-Encoding，更多内容可以参考官网<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a>。</p><table><thead><tr><th>Code</th><th>Meaning</th></tr></thead><tbody><tr><td>c</td><td>A char</td></tr><tr><td>i</td><td>An int</td></tr><tr><td>s</td><td>A short</td></tr><tr><td>l</td><td>A long, l is treated as a 32-bit quantity on 64-bit programs.</td></tr><tr><td>q</td><td>A long long</td></tr><tr><td>C</td><td>An unsigned char</td></tr><tr><td>I</td><td>An unsigned int</td></tr><tr><td>S</td><td>An unsigned short</td></tr><tr><td>L</td><td>An unsigned long</td></tr><tr><td>Q</td><td>An unsigned long long</td></tr><tr><td>f</td><td>A float</td></tr><tr><td>d</td><td>A double</td></tr><tr><td>B</td><td>A C++ bool or a C99 _Bool</td></tr><tr><td>v</td><td>A void</td></tr></tbody></table></li></ol><h4 id="5-方法缓存"><a href="#5-方法缓存" class="headerlink" title="5. 方法缓存"></a>5. 方法缓存</h4><p>Class内部结构有一个方法缓存<font color=orange>Cache_t</font>，用散列表来缓存曾经调用过的方法，可以提高方法的查找速度。（用空间换时间）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cache_t</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bucket_t</span> *<span class="hljs-title">buckets</span>;</span> <span class="hljs-comment">// 散列表</span><br>    <span class="hljs-keyword">mask_t</span> _mask; <span class="hljs-comment">// 散列表的长度-1</span><br>    <span class="hljs-keyword">mask_t</span> _occupied; <span class="hljs-comment">// 已经缓存的方法数量</span><br>&#125;；<br>  <br>  <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bucket_t</span>&#123;</span><br>    <span class="hljs-keyword">cache_key_t</span> _key; <span class="hljs-comment">// SEL作为key</span><br>    IMP imp; <span class="hljs-comment">// 函数的内存地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="二、objc-msgSend"><a href="#二、objc-msgSend" class="headerlink" title="二、objc_msgSend"></a>二、objc_msgSend</h3><p>OC的方法调用，其实都是转化为<code>objc_msgSend</code>函数的调用。</p><p><code>objc_msgSend</code>的执行流程可以分为三大阶段：</p><h4 id="1-消息发送"><a href="#1-消息发送" class="headerlink" title="1. 消息发送"></a>1. 消息发送</h4><p>消息发送流程：</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203041618222.png" alt="消息发送流程" style="zoom:20%;margin-left:10px" /><h4 id="2-动态方法解析"><a href="#2-动态方法解析" class="headerlink" title="2. 动态方法解析"></a>2. 动态方法解析</h4><p>动态方法解析流程：</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203041705547.png" alt="动态方法解析流程" style="zoom:30%;margin-left:60px" /><p>如果一个对象的<code>instance</code>，去调用一个没有实现的<code>instance</code>方法的话，会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">unrecognized selector sent to instance<br></code></pre></td></tr></table></figure><p>解决这个错误的一个方法就是动态添加实例方法的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(void)other&#123;<br>    NSLog(@&quot;%s&quot;,__func__);<br>&#125;<br>// 为test方法动态添加方法的实现<br>+(BOOL)resolveInstanceMethod:(SEL)sel&#123;<br>    if (sel == @selector(test)) &#123;<br> Method method = class_getInstanceMethod(self, @selector(other));<br>        class_addMethod(self, sel, method_getImplementation(method), method_getTypeEncoding(method));<br>        return  YES;<br>    &#125;<br>    return [super resolveInstanceMethod:sel];<br>&#125; <br></code></pre></td></tr></table></figure><p><code>+resolveInstanceMethod</code>和<code>+resolveClassMethod</code>的区别在于，前者是动态的向class中添加实例方法，后者是动态的向meta-calss中添加类方法。</p><h4 id="3-消息转发"><a href="#3-消息转发" class="headerlink" title="3. 消息转发"></a>3. 消息转发</h4><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203071128975.png" alt="消息转发流程" style="zoom:40%;margin-left:60px"/><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &quot;TPerson.h&quot;<br>#import &lt;objc/runtime.h&gt;<br>#import &quot;TStudent.h&quot;<br>@implementation TPerson<br>- (id)forwardingTargetForSelector:(SEL)aSelector&#123;//不调用的话默认返回值为nil<br>    if (aSelector == @selector(test)) &#123;<br>//        return  [[TStudent alloc]init];<br>        return  nil;<br>    &#125;<br>    return [super forwardingTargetForSelector:aSelector];<br>&#125;<br><br>// 方法签名<br>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;<br>    if (aSelector == @selector(test)) &#123;<br>        return  [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];<br>      // return  [[[TStudent alloc]init] methodSignatureForSelector:@selector(test)];<br>    &#125;<br>    return  [super methodSignatureForSelector:aSelector];<br>&#125;<br><br>// NSInvocation 封装了一个方法调用，包括方法调用者、方法名、方法参数<br>- (void)forwardInvocation:(NSInvocation *)anInvocation&#123;<br>    NSLog(@&quot;123&quot;);<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><h3 id="三、Runtime-API"><a href="#三、Runtime-API" class="headerlink" title="三、Runtime API"></a>三、Runtime API</h3><h4 id="1-类："><a href="#1-类：" class="headerlink" title="1. 类："></a>1. 类：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取isa指向的Class</span><br><span class="hljs-built_in">object_getClass</span>(&lt;<span class="hljs-meta">#id  _Nullable obj#&gt;)</span><br><span class="hljs-comment">// 设置isa指向的Class</span><br><span class="hljs-built_in">object_setClass</span>(&lt;<span class="hljs-meta">#id  _Nullable obj#&gt;, <span class="hljs-meta-string">&lt;#Class  _Nonnull __unsafe_unretained cls#&gt;</span>)</span><br><span class="hljs-comment">// 判断一个OC对象是否是Class</span><br><span class="hljs-built_in">object_isClass</span>(&lt;<span class="hljs-meta">#id  _Nullable obj#&gt;)</span><br><span class="hljs-comment">// 判断一个Class是否为元类</span><br><span class="hljs-built_in">class_isMetaClass</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;)<br><span class="hljs-comment">// 获取父类</span><br><span class="hljs-built_in">class_getSuperclass</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;)<br><span class="hljs-comment">// 动态创建一个类（参数：父类、类名、额外的内存空间）</span><br><span class="hljs-built_in">objc_allocateClassPair</span>(&lt;#Class  _Nullable __unsafe_unretained superclass#&gt;, &lt;<span class="hljs-meta">#const char * _Nonnull name#&gt;, <span class="hljs-meta-string">&lt;#size_t extraBytes#&gt;</span>)</span><br><span class="hljs-comment">// 注册一个类</span><br><span class="hljs-built_in">objc_registerClassPair</span>(&lt;#Class  _Nonnull __unsafe_unretained cls#&gt;)<br><span class="hljs-comment">// 销毁一个类</span><br><span class="hljs-built_in">objc_disposeClassPair</span>(&lt;#Class  _Nonnull __unsafe_unretained cls#&gt;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">void run(id self, SEL _cmd)&#123;<br>    NSLog(@&quot;%@--%@&quot;,self,NSStringFromSelector(_cmd));<br>&#125;<br><br>// 创建类<br>Class newClass =  objc_allocateClassPair([NSObject class], &quot;TStudent&quot;, 0);<br>// 添加成员变量<br>class_addIvar(newClass, &quot;_age&quot;, 4, 1, @encode(int));<br>// 添加方法<br>class_addMethod(newClass, @selector(run), (IMP)run, &quot;v@:&quot;);<br>// 注册类<br>// 类对象一旦注册完毕就不能再添加成员变量（成员变量时ro只读的）但是可以再添加方法（方法时rw）<br>objc_registerClassPair(newClass);<br>id student = [[newClass alloc]init];<br>[student setValue:@10 forKey:@&quot;age&quot;];<br>[student run];<br>    <br>NSLog(@&quot;%@&quot;,[student valueForKey:@&quot;age&quot;]);<br></code></pre></td></tr></table></figure><h4 id="2-成员变量"><a href="#2-成员变量" class="headerlink" title="2. 成员变量"></a>2. 成员变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取一个实例变量信息</span><br><span class="hljs-built_in">class_getInstanceVariable</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;<span class="hljs-meta">#const char * _Nonnull name#&gt;)</span><br><span class="hljs-comment">// 拷贝实例变量列表（最后需要调用free释放）</span><br><span class="hljs-built_in">class_copyIvarList</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;<span class="hljs-meta">#unsigned int * _Nullable outCount#&gt;)</span><br><span class="hljs-comment">// 设置和获取成员变量的值</span><br><span class="hljs-built_in">object_setIvar</span>(&lt;<span class="hljs-meta">#id  _Nullable obj#&gt;, <span class="hljs-meta-string">&lt;#Ivar  _Nonnull ivar#&gt;</span>, <span class="hljs-meta-string">&lt;#id  _Nullable value#&gt;</span>)</span><br><span class="hljs-built_in">object_getIvar</span>(&lt;<span class="hljs-meta">#id  _Nullable obj#&gt;, <span class="hljs-meta-string">&lt;#Ivar  _Nonnull ivar#&gt;</span>)</span><br><span class="hljs-comment">// 动态添加成员变量（已经注册的类不能动态添加成员变量）</span><br><span class="hljs-built_in">class_addIvar</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;<span class="hljs-meta">#const char * _Nonnull name#&gt;, <span class="hljs-meta-string">&lt;#size_t size#&gt;</span>, <span class="hljs-meta-string">&lt;#uint8_t alignment#&gt;</span>, <span class="hljs-meta-string">&lt;#const char * _Nullable types#&gt;</span>)</span><br><span class="hljs-comment">// 获取成员变量的相关信息</span><br><span class="hljs-built_in">ivar_getName</span>(&lt;#Ivar  _Nonnull v#&gt;)<br><span class="hljs-built_in">ivar_getTypeEncoding</span>(&lt;#Ivar  _Nonnull v#&gt;)<br></code></pre></td></tr></table></figure><h4 id="3-属性"><a href="#3-属性" class="headerlink" title="3. 属性"></a>3. 属性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取一个属性</span><br><span class="hljs-built_in">class_getProperty</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;<span class="hljs-meta">#const char * _Nonnull name#&gt;)</span><br><span class="hljs-comment">// 拷贝属性列表（最后需要调用free释放）</span><br><span class="hljs-built_in">class_copyPropertyList</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;<span class="hljs-meta">#unsigned int * _Nullable outCount#&gt;)</span><br><span class="hljs-comment">// 动态添加属性</span><br><span class="hljs-built_in">class_addProperty</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;<span class="hljs-meta">#const char * _Nonnull name#&gt;, <span class="hljs-meta-string">&lt;#const objc_property_attribute_t * _Nullable attributes#&gt;</span>, <span class="hljs-meta-string">&lt;#unsigned int attributeCount#&gt;</span>)</span><br><span class="hljs-comment">// 动态替换属性</span><br><span class="hljs-built_in">class_replaceProperty</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;<span class="hljs-meta">#const char * _Nonnull name#&gt;, <span class="hljs-meta-string">&lt;#const objc_property_attribute_t * _Nullable attributes#&gt;</span>, <span class="hljs-meta-string">&lt;#unsigned int attributeCount#&gt;</span>)</span><br><span class="hljs-comment">// 获取属性的一些信息</span><br><span class="hljs-built_in">property_getName</span>(&lt;#<span class="hljs-keyword">objc_property_t</span>  _Nonnull property#&gt;)<br><span class="hljs-built_in">property_getAttributes</span>(&lt;#<span class="hljs-keyword">objc_property_t</span>  _Nonnull property#&gt;)<br></code></pre></td></tr></table></figure><h4 id="4-方法"><a href="#4-方法" class="headerlink" title="4. 方法"></a>4. 方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取一个实例方法、类方法</span><br><span class="hljs-built_in">class_getInstanceMethod</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL  _Nonnull name#&gt;)<br><span class="hljs-built_in">class_getClassMethod</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL  _Nonnull name#&gt;)<br><span class="hljs-comment">// 方法实现相关操作</span><br><span class="hljs-built_in">class_getMethodImplementation</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL  _Nonnull name#&gt;)<br><span class="hljs-built_in">method_setImplementation</span>(&lt;#Method  _Nonnull m#&gt;, &lt;#IMP  _Nonnull imp#&gt;)<br><span class="hljs-built_in">method_exchangeImplementations</span>(&lt;#Method  _Nonnull m1#&gt;, &lt;#Method  _Nonnull m2#&gt;)<br><span class="hljs-comment">// 拷贝方法列表</span><br><span class="hljs-built_in">class_copyMethodList</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;<span class="hljs-meta">#unsigned int * _Nullable outCount#&gt;)</span><br><span class="hljs-comment">// 动态添加方法</span><br><span class="hljs-built_in">class_addMethod</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL  _Nonnull name#&gt;, &lt;#IMP  _Nonnull imp#&gt;, &lt;<span class="hljs-meta">#const char * _Nullable types#&gt;)</span><br><span class="hljs-comment">// 动态替换方法</span><br><span class="hljs-built_in">class_replaceMethod</span>(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL  _Nonnull name#&gt;, &lt;#IMP  _Nonnull imp#&gt;, &lt;<span class="hljs-meta">#const char * _Nullable types#&gt;)</span><br><span class="hljs-comment">// 获取方法的相关信息（带有copy的需要调用free释放）</span><br><span class="hljs-built_in">method_getName</span>(&lt;#Method  _Nonnull m#&gt;)<br><span class="hljs-built_in">method_getImplementation</span>(&lt;#Method  _Nonnull m#&gt;)<br><span class="hljs-built_in">method_getTypeEncoding</span>(&lt;#Method  _Nonnull m#&gt;)<br><span class="hljs-built_in">method_getNumberOfArguments</span>(&lt;#Method  _Nonnull m#&gt;)<br><span class="hljs-built_in">method_copyReturnType</span>(&lt;#Method  _Nonnull m#&gt;)<br><span class="hljs-built_in">method_copyArgumentType</span>(&lt;#Method  _Nonnull m#&gt;, &lt;<span class="hljs-meta">#unsigned int index#&gt;)</span><br></code></pre></td></tr></table></figure><h3 id="三、面试题"><a href="#三、面试题" class="headerlink" title="三、面试题"></a>三、面试题</h3><h4 id="1-讲一下OC的消息机制？"><a href="#1-讲一下OC的消息机制？" class="headerlink" title="1. 讲一下OC的消息机制？"></a>1. 讲一下OC的消息机制？</h4><p>oc的方法调用其实都是objc_msgSend函数的调用，给reciver（调用者）发送一条消息（selector方法名）</p><p>objc_msgSend底层有3大阶段：消息发送（当前类、父类查找）、动态方法解析、消息转发</p><h4 id="2-消息转发机制流程？"><a href="#2-消息转发机制流程？" class="headerlink" title="2. 消息转发机制流程？"></a>2. 消息转发机制流程？</h4><h4 id="3-什么是Runtime-平时项目中有用过么？"><a href="#3-什么是Runtime-平时项目中有用过么？" class="headerlink" title="3. 什么是Runtime?平时项目中有用过么？"></a>3. 什么是Runtime?平时项目中有用过么？</h4><p>OC是一门动态性比较强的编程语言，允许很多操作推迟到程序运行时再进行，OC的动态性就是由<code>Runtime</code>支撑来实现的，<code>Runtime</code>是一套C语言的API，封装了很多动态性相关的函数。平时我们编写的OC代码，底层都是转换成<code>Runtime</code> API进行调用。</p><p>具体应用：</p><ul><li>利用关联对象（AssociatedObject）给分类添加属性。</li><li>遍历类的所有成员变量（修改textfield的占位颜色、字典转模型、自动归档解档）。</li><li>交换方法实现（交换系统的方法）。</li><li>利用消息转发机制解决方法找不到的异常问题。</li></ul><h4 id="4-self-class-和-super-class-的区别？"><a href="#4-self-class-和-super-class-的区别？" class="headerlink" title="4. [self class]和[super class]的区别？"></a>4. [self class]和[super class]的区别？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//已知<br>@interface TPerson: NSObject;<br>@end<br>@interface TStudent: TPerson;<br>@end<br>  <br>#import &quot;TStudent.h&quot;  <br>@implementation<br>// 求下面init中的输出?<br>-(instancetype)init&#123;<br>    if (self = [super init]) &#123;<br>        NSLog(@&quot;[self class] = %@&quot;,[self class]);// TStudent<br>        NSLog(@&quot;[self superclass] = %@&quot;,[self superclass]);// TPerson<br>        NSLog(@&quot;[super class] = %@&quot;,[super class ]);// TStudent<br>        NSLog(@&quot;[super superclass] = %@&quot;,[super superclass]);// TPerson<br>    &#125;<br>    return  self;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><p>上面这段init代码的底层实现如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">static</span> instancetype _I_TStudent_init(TStudent * self, SEL _cmd) &#123;<br>    <span class="hljs-keyword">if</span> (self = ((TStudent *(*)(__rw_objc_super *, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)<span class="hljs-built_in">class_getSuperclass</span>(<span class="hljs-built_in">objc_getClass</span>(<span class="hljs-string">&quot;TStudent&quot;</span>))&#125;, <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-string">&quot;init&quot;</span>))) &#123;<br>      <br>      <span class="hljs-built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_dr_y6z2zsxs4m9bxrqxwcdchsnw0000gn_T_TStudent_7e015b_mi_0,((<span class="hljs-built_in">Class</span> (*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)self, <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-string">&quot;class&quot;</span>)));<br>      <br>      <span class="hljs-built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_dr_y6z2zsxs4m9bxrqxwcdchsnw0000gn_T_TStudent_7e015b_mi_1,((<span class="hljs-built_in">Class</span> (*)(id, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSend)((id)self, <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-string">&quot;superclass&quot;</span>)));<br>      <br>      <span class="hljs-built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_dr_y6z2zsxs4m9bxrqxwcdchsnw0000gn_T_TStudent_7e015b_mi_2,((<span class="hljs-built_in">Class</span> (*)(__rw_objc_super *, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)<span class="hljs-built_in">class_getSuperclass</span>(<span class="hljs-built_in">objc_getClass</span>(<span class="hljs-string">&quot;TStudent&quot;</span>))&#125;, <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-string">&quot;class&quot;</span>)));<br>        <br>      <span class="hljs-built_in">NSLog</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_dr_y6z2zsxs4m9bxrqxwcdchsnw0000gn_T_TStudent_7e015b_mi_3,((<span class="hljs-built_in">Class</span> (*)(__rw_objc_super *, SEL))(<span class="hljs-keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)<span class="hljs-built_in">class_getSuperclass</span>(<span class="hljs-built_in">objc_getClass</span>(<span class="hljs-string">&quot;TStudent&quot;</span>))&#125;, <span class="hljs-built_in">sel_registerName</span>(<span class="hljs-string">&quot;superclass&quot;</span>)));<br>    &#125;<br>    <span class="hljs-keyword">return</span> self;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到<code>[super class]</code>底层调用的是<code>objc_msgSendSuper</code>方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">objc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)<br></code></pre></td></tr></table></figure><p>我们进入<code>objc4</code>源码可以看到<code>objc_msgSendSuper</code>方法的两个参数：</p><ul><li><p>struct objc_super</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_super</span> &#123;</span><br>    <span class="hljs-comment">/// Specifies an instance of a class.</span><br>    __unsafe_unretained _Nonnull id receiver;<br><br>    <span class="hljs-comment">/// Specifies the particular superclass of the instance to message. </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br>    <span class="hljs-comment">/* For compatibility with old objc-runtime.h header */</span><br>    __unsafe_unretained _Nonnull Class <span class="hljs-class"><span class="hljs-keyword">class</span>;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    __unsafe_unretained _Nonnull Class super_class;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-comment">/* super_class is the first class to search */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>reciver</code>: 消息接收者</p><p><code>super_class</code> : 告诉编译器方法查找从<code>superClass</code>开始（正常的话是<code>class</code>-&gt;<code>superClass</code>）</p></li><li><p>SEL</p></li></ul><p>从init的底层源码中我们可以看到：</p><ol><li><p><code>[super class]</code>、<code>[super superclass]</code>的消息接收者始终都是<code>self</code>。</p></li><li><p><code>objc_msgSendSuper</code>方法通过传入的<code>super_class</code>只是让编译器知道从哪个地方进行方法查找。</p></li></ol><p>结论：</p><p><code>[self class]</code>、[super calss]接收消息的对象都是<code>self</code>，只是查找方法的起始位置不同，最终都是找到<code>NSObject</code>的<code>class</code>方法。因此返回的都是父类<code>TPerson</code>。</p><p><code>[self superclass]</code>、<code>[super supercalss]</code>同理。</p><h4 id="5-isKindOfClass和isMemberOfClass的区别？"><a href="#5-isKindOfClass和isMemberOfClass的区别？" class="headerlink" title="5. isKindOfClass和isMemberOfClass的区别？"></a>5. isKindOfClass和isMemberOfClass的区别？</h4><p>对象方法底层实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 实例对象的类 是否等于cls<br>- (BOOL)isMemberOfClass:(Class)cls &#123;<br>    return [self class] == cls;<br>&#125;<br>// 实例对象的类、父类、父类的父类等是否等于cls<br>- (BOOL)isKindOfClass:(Class)cls &#123;<br>    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123;<br>        if (tcls == cls) return YES;<br>    &#125;<br>    return NO;<br>&#125;<br></code></pre></td></tr></table></figure><p>类方法的底层实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//类的meta-class是否等于cls<br>+ (BOOL)isMemberOfClass:(Class)cls &#123;<br>    return object_getClass((id)self) == cls;<br>&#125;<br>// 类meta-calss、父类的meta-class、父类的父类的meta-class等是否等于cls<br>+ (BOOL)isKindOfClass:(Class)cls &#123;<br>    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123;<br>        if (tcls == cls) return YES;<br>    &#125;<br>    return NO;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSLog(@&quot;%d&quot;,[NSObject isKindOfClass:[NSObject class]]);<br>// 1<br>//NSObject的meta-calss的superclass指向了NSObject<br></code></pre></td></tr></table></figure><p><font color=orange>本篇内容出自小码哥视频,只为方便自己以后查阅！</font></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://c.biancheng.net/cpp/html/2932.html">C语言中文网</a></li><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encoding</a></li><li><a href="">小码哥视频</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_OC对象的本质</title>
    <link href="/2022/02/23/iOS/%E5%A4%87%E8%80%83/OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/iOS_OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
    <url>/2022/02/23/iOS/%E5%A4%87%E8%80%83/OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/iOS_OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、OC对象的本质"><a href="#一、OC对象的本质" class="headerlink" title="一、OC对象的本质"></a>一、OC对象的本质</h3><p>我们平时编写的Object-C代码，底层实现其实都是基于C/C++代码，所以Object-C的面向对象都是基于C/C++的数据结构实现的。那它到底是基于什么数据结构实现的呢？</p><p>我们知道，OC中所有对象基本上都是继承自NSObject的，所以可以通过窥探NSObject的底层实现，确定OC对象的本质。</p><p>我们在xcode中通过commad点击进入NSObject中可以看到NSObject头文件中对其的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// NSObject 的定义<br>@interface NSObject &lt;NSObject&gt; &#123;<br>#pragma clang diagnostic push<br>#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;<br>    Class isa  OBJC_ISA_AVAILABILITY;<br>#pragma clang diagnostic pop<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc OC源文件 -o 输出的CPP文件</code>将OC代码转化为C/C++代码，窥探NSObject的底层实现，可以发现NSObject对象在C/C++中就是一个结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NSObject_IMPL</span> &#123;</span><br>Class isa;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">objc_class</span> *<span class="hljs-title">Class</span>;</span><br></code></pre></td></tr></table></figure><p>所以可以说OC对象的本质是在C/C++内存中的结构体。</p><h3 id="二、OC对象的分类"><a href="#二、OC对象的分类" class="headerlink" title="二、OC对象的分类"></a>二、OC对象的分类</h3><p>OC对象主要分为三类：</p><ol><li><p>instance对象</p><p>instance对象就是通过alloc出来的对象，每次调用alloc都会产生一个新的instance对象，它们占用着不同的内存地址。</p><p>instance对象在内存中主要存储的信息包括：</p><ul><li><p>isa指针</p></li><li><p>其他成员变量（成员变量实际的值）</p></li></ul></li><li><p>class对象</p><p>calss对象的获取方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;objc/runtime.h&gt;<br>NSObject *obj = [[NSObject alloc]init];<br>// 获取class对象的方法<br>//1.<br>Class objClass1 = [obj class];<br>//2.<br>Class objClass2 = [NSObject class];<br>//3.runtime方法<br>Class objClass3 = object_getClass(obj);<br></code></pre></td></tr></table></figure><p>class对象在内存中存储的信息：</p><ul><li>isa指针</li><li>superclass指针</li><li>类的属性信息（@property）、类的对象方法信息（-(void)）</li><li>类的协议信息（protocol）、类的成员变量信息（ivar）(成员变量的名称、类型)</li></ul></li><li><p>meta-class对象</p><p>meta-class 获取方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;objc/runtime.h&gt;<br><br>Class objcMetaClass = object_getClass([NSObject class]);<br></code></pre></td></tr></table></figure><p>每个类在内存中有且只有一个meta-class对象</p><p>meta-class对象和class对象的内存结构是一样的，只是meta-class对象内存中存储的信息是：</p><ul><li>isa指针</li><li>superclass指针</li><li>类的类方法信息（+(void)）</li></ul><p>查看Class对象是否为原类对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;objc/runtime.h&gt;<br><br>BOOL result = class_isMetaClass([NSObject class]);<br></code></pre></td></tr></table></figure></li></ol><h3 id="三、isa指针"><a href="#三、isa指针" class="headerlink" title="三、isa指针"></a>三、isa指针</h3><p>这里用一张图解释isa指针的作用：</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203011714702.png" alt="isa指针" style="zoom:100%;margin-left:10px" /><h4 id="1-isa的本质"><a href="#1-isa的本质" class="headerlink" title="1. isa的本质"></a>1. isa的本质</h4><p>在64bit中：</p><p>instance对象isa指针指向的内存地址&amp;ISA_MASK=class对象的内存地址</p><p>class对象isa指针指向的内存地址&amp;ISA_MASK=meta-class对象的内存地址</p><p>补充：</p><p>class、meta-class对象的本质结构都是struct objc_class，其内部结构如图：  </p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203011733312.png" alt="struct objc_class的结构" style="zoom:97%;margin-left:10px" /><h4 id="2-isa、superclass总结"><a href="#2-isa、superclass总结" class="headerlink" title="2. isa、superclass总结"></a>2. isa、superclass总结</h4><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202203011720602.png" alt="image-20220301172044495" style="zoom:70%;margin-left:10px" /><h5 id="2-1-isa"><a href="#2-1-isa" class="headerlink" title="2.1. isa"></a>2.1. isa</h5><ul><li>instance的isa指向class</li><li>calss的isa指向meta-calss</li><li>meta-calss的isa指针指向基类的meta-class</li></ul><h5 id="2-2-superclass"><a href="#2-2-superclass" class="headerlink" title="2.2. superclass"></a>2.2. superclass</h5><ul><li>class的superclass指向父类的class，如果没有父类，superclass指向nil</li><li>meta-class的superclass指向父类的meta-class，基类的meta-class的spuerclass指向基类的class</li></ul><h5 id="2-3-方法调用轨迹"><a href="#2-3-方法调用轨迹" class="headerlink" title="2.3. 方法调用轨迹"></a>2.3. 方法调用轨迹</h5><ul><li><p>instance调用对象方法的轨迹</p><p>isa找到class，方法不存在，就通过superclass找父类</p></li><li><p>class调用类方法的轨迹</p><p>isa找到meta-class，方法不存在，通过superclass找父类</p></li></ul><h3 id="四、面试题："><a href="#四、面试题：" class="headerlink" title="四、面试题："></a>四、面试题：</h3><ol><li><p>一个NSObject对象占多少内存？</p><p>我们可以通过以下两个方法进行计算：</p><ul><li><p>创建一个实例对象，至少需要多少内存？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span><br><span class="hljs-built_in">class_getInstanceSize</span>([NSObject class])<br></code></pre></td></tr></table></figure></li><li><p>创建一个实例对象，实际分配的内存？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;malloc/malloc.h&gt;</span></span><br><span class="hljs-built_in">malloc_size</span>((__bridge <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)obj)<br></code></pre></td></tr></table></figure></li></ul><p>可以得出系统分配了16个字节给NSObject对象，但是NSObject对象内部只使用了8个字节的空间（64bit环境下）  </p></li><li><p>对象的isa指针指向哪里？</p><ul><li>instance的isa指针指向clas对象</li><li>calss对象的isa指针指向meta-calss对象</li><li>meta-class的isa指向基类的meta-calss对象</li></ul></li><li><p>OC类信息存放在哪里？</p><ul><li>对象方法、属性、成员变量、协议信息存放在类对象中</li><li>类方法存放在meta-class对象中</li><li>成员变量的具体值存放在instance对象中</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_属性关键字</title>
    <link href="/2022/01/19/iOS/%E5%A4%87%E8%80%83/OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/iOS_%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2022/01/19/iOS/%E5%A4%87%E8%80%83/OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/iOS_%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、属性和成员变量"><a href="#一、属性和成员变量" class="headerlink" title="一、属性和成员变量"></a>一、属性和成员变量</h3><h4 id="1、成员变量"><a href="#1、成员变量" class="headerlink" title="1、成员变量"></a>1、成员变量</h4><p>成员变量的声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface ViewController ()<br>&#123;<br>    NSString *name;// 成员变量<br>  UIButton *btn;//实例变量<br>  id userId;//实例变量<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><p>实例变量：class类进行实例化出来的对象。id是一种特殊的class，是OC特有的对象。</p><p>成员变量：{ }内声明的变量，都是成员变量，实例变量是成员变量的一种。</p><h4 id="2、-属性"><a href="#2、-属性" class="headerlink" title="2、 属性"></a>2、 属性</h4><p>属性的声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface ViewController ()<br>@property(nonatomic, copy) NSString* name;<br>@end<br></code></pre></td></tr></table></figure><p>属性的本质：</p><p>@property = 成员变量+setter+getter ，属性声明时，编译器会自动为我们声明一个带下划线的成员变量，同时会声明setter和getter方法。</p><h3 id="二、关键字"><a href="#二、关键字" class="headerlink" title="二、关键字"></a>二、关键字</h3><p>作用：用来修饰属性</p><h4 id="1、读取权限"><a href="#1、读取权限" class="headerlink" title="1、读取权限"></a>1、读取权限</h4><ul><li><p>readonly</p><p>readonly修饰的属性不会生成setter方法，不能对属性进行修改</p></li><li><p>readwrite (默认)</p><p>readwrite修饰的属性，会生成setter和getter方法</p></li></ul><h4 id="2、原子操作"><a href="#2、原子操作" class="headerlink" title="2、原子操作"></a>2、原子操作</h4><ul><li><p>atomic</p><p>原子性，在多线程中同一个变量可能被多个线程访问甚至更改，进而造成数据污染，因此为了安全，OC默认是atomic，即会对setter方法加锁，相应的也会付出维护原子性（数据加锁解锁等）的系统资源代价。</p></li><li><p>nonatomic</p><p>非原子性，不会对setter方法加锁，应用中如果不是特殊情况（多线程间的通信编码），那么一般还是使用nonatomic来修饰变量的，不会对setter方法加锁，以提高多线程并发访问时的性能。</p></li></ul><h4 id="3、引用计数"><a href="#3、引用计数" class="headerlink" title="3、引用计数"></a>3、引用计数</h4><ul><li><p>strong</p><p>指向并拥有该对象，其修饰的对象引用计数会+1。该对象只有引用计数不为0就不会被销毁。可以通过将对象设置为nil将其强行销毁。</p></li><li><p>assign</p><ul><li><p>修饰基本数据类型，如int、Bool等</p></li><li><p>修饰对象的时候，指向并不拥有该对象，不会使该对象引用计数＋1</p></li><li><p>修饰的对象被释放后，指针仍然指向原来的内存地址， 这时候如果再通过assign指针继续访问对象的话，会因为悬垂指针的原因导致内存泄露或者程序异常</p></li></ul><blockquote><p>悬垂指针：指针所指向的对象已经被释放或者回收，但是指向该对象的指针没有作任何的修改，仍旧指向已经回收的内存地址</p></blockquote></li><li><p>weak</p><ul><li><p>只能修饰对象</p></li><li><p>不改变被修饰对象的引用计数</p></li><li><p>所指向对象在被释放后会自动置为nil</p></li></ul><blockquote><p>weak修饰的对象什么时候会被释放？</p></blockquote></li><li><p>copy</p><p>浅拷贝：</p><ul><li>浅拷贝只是对内存地址的赋值，不会增加内存空间的。 </li><li>会增加被拷贝对象的引用计数+1</li></ul><p>深拷贝：</p><ul><li>会产生新的内存分配</li><li>不会增加被拷贝对象的引用计数</li></ul><p>对比：</p><table><thead><tr><th align="left">源对象类型</th><th>拷贝方式</th><th>目标对象类型</th><th>拷贝类型（深、浅）</th></tr></thead><tbody><tr><td align="left">可变对象</td><td>copy</td><td>不可变</td><td>深拷贝</td></tr><tr><td align="left">可变对象</td><td>mutableCopy</td><td>可变</td><td>深拷贝</td></tr><tr><td align="left">不可变对象</td><td>copy</td><td>不可变</td><td>浅拷贝</td></tr><tr><td align="left">不可变对象</td><td>mutableCopy</td><td>可变</td><td>深拷贝</td></tr></tbody></table><p>总结：</p><ul><li><p>使用copy修饰的目标对象都是不可变的。</p></li><li><p>使用mutableCopy修饰的目标对象都是可变的。</p></li><li><p>只有不可变对象使用copy修饰才是浅拷贝，其他的都是深拷贝。</p></li></ul></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://juejin.cn/post/6844903527815331854">iOS中atomich和nonatomic区别及内部实现 </a></p></li><li><p><a href="https://www.jianshu.com/p/5d138efee024">NSMutableString不要用copy</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_KVO与KVC</title>
    <link href="/2022/01/19/iOS/%E5%A4%87%E8%80%83/OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/iOS-KVO%E4%B8%8EKVC/"/>
    <url>/2022/01/19/iOS/%E5%A4%87%E8%80%83/OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/iOS-KVO%E4%B8%8EKVC/</url>
    
    <content type="html"><![CDATA[<h3 id="一-KVC"><a href="#一-KVC" class="headerlink" title="一. KVC"></a>一. KVC</h3><h4 id="1-什么是KVC"><a href="#1-什么是KVC" class="headerlink" title="1. 什么是KVC?"></a>1. 什么是KVC?</h4><p>键值编码（KVC）是一种在NSKeyValueCoding非正式协议下使用字符串标志间接访问对象属性的一种机制。</p><blockquote><p>注意：KVC可以暴力访问对象的任何变量，无论是否是private私有类型的变量、</p></blockquote><h4 id="2-KVC的使用场景有哪些？"><a href="#2-KVC的使用场景有哪些？" class="headerlink" title="2. KVC的使用场景有哪些？"></a>2. KVC的使用场景有哪些？</h4><p>在iOS开发中，允许开发者通过key名间接的访问对象的属性，或者直接给对象的属性赋值，而不需要调用对象的存取方法。这样就可以在运行时动态的访问和修改对象的属性值。</p><p>在OC中，NSObject类及其子类默认都实现NSKeyValueCoding协议，这个协议定义了所有实现KVC的方法。下面列举KVC中最为重要的4个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 直接通过key来取值<br>- (nullable id )valueForKey:(NSString*)key；<br>// 通过key来设值<br>-（void）setValue:(nullable id)value forKey:(NSString*)key;<br>// 通过keyPath来取值<br>- (nullable id )valueForKeyPath:(NSString*)keyPath;<br>// 通过keyPath来设值<br>-（void）setValue:(nullable id)value forKeyPath:(NSString*)keyPath;<br></code></pre></td></tr></table></figure><p>KVC的一般应用场景：</p><ol><li><p>动态的取值和设值</p><p>KVC最常用的也是最基础的用途</p></li><li><p>利用KVC来访问、修改对象的私有属性</p><p>对于类中的私有属性，无法通过普通的设置和取值方法直接访问，但是KVC是可以的，如iOS13之前UITextField中的修改占位符字体颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];<br></code></pre></td></tr></table></figure><blockquote><p>键路径：就是键值编码中某个属性的key，一个由连续键名组成的字符串，键名即属性名，键名之间用点隔开，用于指定一个链接在一起的对象性质序列。</p></blockquote></li><li><p>利用KVC进行model和字典之间的转换</p><p>使用KVC提供的<code>setValuesForKeysWithDictionary:</code>，可以将字典映射到一个对象，不需要一一的为对象赋值而直接从字典中初始化即可。</p></li><li><p>利用KVC实现高阶消息传递</p><p>当对容器类（如NSArray类）使用KVC时，<code>valueForKey：</code>将会被传递给容器中的每一个对象，而不是对容器本身进行操作。相应的结果会被添加进返回的容器中，这样可以很方便地操作集合来返回另一个集合。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSArray *array = @[@&quot;tom&quot;,@&quot;jim&quot;,@&quot;taylor&quot;];<br>NSArray *result = [array valueForKey:@&quot;capitalizedString&quot;];<br>NSLog(@&quot;%@&quot;,result);<br><br>// 输出<br>22-02-15 17:43:41.470604+0800 KVC[14923:610897] (<br>    Tom,<br>    Jim,<br>    Taylor<br>)<br><br></code></pre></td></tr></table></figure></li></ol><h4 id="3-setValue：ForKey：方法的底层实现是什么？"><a href="#3-setValue：ForKey：方法的底层实现是什么？" class="headerlink" title="3. setValue：ForKey：方法的底层实现是什么？"></a>3. setValue：ForKey：方法的底层实现是什么？</h4><p>当一个对象发送<code>setValue:forKey：</code>消息时，方法内部会做以下操作：</p><ol><li>查找类中是否存在 <code>setKey:</code> 或者<code>_setKey:</code>,如果找到，传递参数，调用方法</li><li>没有找到 <code>setKey:</code> 或者<code>_setKey:</code>方法，查看<code>accessInstanceVariablesDirectly</code>方法的返回值，如果返回为<code>NO</code>，调用<code>setValue:forUndefinedKey:</code>并抛出异常<code>NSUnkonownKeyException</code>。</li><li>如果<code>accessInstanceVariablesDirectly</code>返回为<code>YES</code>,按照 <code>_key</code>、<code>_isKey</code>、<code>key</code>、<code>isKey</code>的顺序查找成员变量，如果查找到成员变量，则直接赋值，如果没有查找到则调用<code>setValue:forUndefinedKey:</code>并抛出异常<code>NSUnkonownKeyException</code>。</li></ol><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202202161737178.png" alt="setValue:forKey:实现原理"></p><blockquote><p>accessInstanceVariablesDirectly：这个方法默认的返回值就是YES</p></blockquote><h4 id="4-valueForKey-的原理？"><a href="#4-valueForKey-的原理？" class="headerlink" title="4.valueForKey:的原理？"></a>4.valueForKey:的原理？</h4><p>  取值的原理与赋值类似，只是在第一步是按照<code>getKey：</code>、<code>key：</code>、<code>isKey：</code>、<code>_key：</code>的顺序查找，后面的过程跟赋值过程唯一不同是一个赋值一个取值。 </p><h4 id="5-问题？"><a href="#5-问题？" class="headerlink" title="5.问题？"></a>5.问题？</h4><ol><li><p>通过KVC修改属性值是否会触发KVO?</p><p>可以，即使是直接为成员变量赋值，也是会触发KVO，因为KVC调用setValue:forKey:方法的时候会调用下面两个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">[self willChangeValueForKey:@&quot;key&quot;];<br>[self didChangeValueForKey:@&quot;key&quot;]；<br></code></pre></td></tr></table></figure></li><li><p>setValueforKey:和setObjectForKey:的区别</p><ul><li><code>setObjectForKey:</code>是<code>NSMutableDictionary</code>类特有的，只有<code>NSMutableDdictionary</code>类及其子类的实例化对象能够使用，而<code>setValue:forKey:</code>方法是KVC的主要方法，只要遵循NSCoding协议的对象都能够使用。</li><li><code>setValue:forKey:</code>中的key的参数只能够是NSString类型，而<code>setObject:forKey:</code>的key可以是任何类型的对象类型。</li><li><code>setObject:forKey:</code>方法中参数value不能为nil，否则会抛出异常。而<code>setValue:forKey:</code>中value可以为nil，只是当value为nil的时候会自动调用<code>removeObject:forKey:</code>方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSMutableDictionary *dict = [[NSMutableDictionary alloc] initWithDictionary:@&#123;@&quot;age&quot;:@&quot;10&quot;&#125;];<br>[dict setObject:@&quot;11&quot; forKey:@&quot;age&quot;];<br>NSLog(@&quot;%@&quot;,dict);<br>[dict setValue:@&quot;12&quot; forKey:@&quot;age&quot;];<br>NSLog(@&quot;%@&quot;,dict);<br>[dict setValue:nil forKey:@&quot;age&quot;];<br>NSLog(@&quot;%@&quot;,dict);<br>[dict setObject:nil forKey:@&quot;age&quot;]; // 警告⚠️ Null passed to a callee that requires a non-null argument<br>// 输出结果<br>2022-02-17 11:37:45.451375+0800 KVC[25119:1226604] &#123;<br>    age = 11;<br>&#125;<br>2022-02-17 11:37:45.451569+0800 KVC[25119:1226604] &#123;<br>    age = 12;<br>&#125;<br>2022-02-17 11:37:45.451698+0800 KVC[25119:1226604] &#123;<br>&#125;<br>2022-02-17 11:38:50.827182+0800 KVC[25144:1228282] *** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason: &#x27;*** -[__NSDictionaryM setObject:forKey:]: object cannot be nil (key: age)&#x27;<br><br></code></pre></td></tr></table></figure><blockquote><p>注意：当对字典赋值的时候需要先对赋值的value做判空处理，防止crash</p></blockquote></li></ol><h3 id="二-KVO"><a href="#二-KVO" class="headerlink" title="二. KVO"></a>二. KVO</h3><h4 id="1-KVO的定义"><a href="#1-KVO的定义" class="headerlink" title="1. KVO的定义"></a>1. KVO的定义</h4><p>键值观察（<code>KVO</code>）是key-value observing的缩写，是基于键值编码实现的一种观察者机制，提供了观察某一属性变化的监听方法。</p><p>apple使用isa混写（isa-swizzling）来实现KVO</p><p>Isa 混写技术的标志：系统会在运行时动态创建NSKVONotifying_A </p><blockquote><p>isa是什么？</p></blockquote><h4 id="2-KVO的简单使用"><a href="#2-KVO的简单使用" class="headerlink" title="2. KVO的简单使用"></a>2. KVO的简单使用</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// KVO是OC语言特性，这里需要继承自NSObject</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>: <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-keyword">import</span> UIKit<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> p <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>()<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span>()</span> &#123;<br>        <span class="hljs-keyword">super</span>.viewDidLoad()<br>      <span class="hljs-comment">// 注册成为观察者</span><br>        p.addObserver(<span class="hljs-keyword">self</span>, forKeyPath: <span class="hljs-string">&quot;age&quot;</span>, options: .new, context: <span class="hljs-literal">nil</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">touchesBegan</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">touches</span>: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">UITouch</span>&gt;, <span class="hljs-params">with</span> <span class="hljs-params">event</span>: <span class="hljs-type">UIEvent</span>?)</span> &#123;<br>      <span class="hljs-comment">// 设置需要被观察对象的属性</span><br>        p.age <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">observeValue</span>(<span class="hljs-params">forKeyPath</span> <span class="hljs-params">keyPath</span>: <span class="hljs-type">String</span>?, <span class="hljs-params">of</span> <span class="hljs-params">object</span>: <span class="hljs-keyword">Any</span><span class="hljs-operator">?</span>, <span class="hljs-params">change</span>: [<span class="hljs-params">NSKeyValueChangeKey</span> : <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span>, <span class="hljs-params">context</span>: <span class="hljs-type">UnsafeMutableRawPointer</span>?)</span> &#123;<br>      <span class="hljs-comment">// 在回调方法中处理变更通知</span><br>        <span class="hljs-built_in">print</span>(change<span class="hljs-operator">!</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-如何使用KVO设置键值观察依赖键"><a href="#3-如何使用KVO设置键值观察依赖键" class="headerlink" title="3. 如何使用KVO设置键值观察依赖键"></a>3. 如何使用KVO设置键值观察依赖键</h4><p>很多情况下对象的属性之间是相互关联的，对象的一个属性值依赖于另一个对象的一个或多个属性，如果被依赖对象属性中的任意一个值发生改变，那么对象的属性的值也会相应发生改变。实例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;Foundation/Foundation.h&gt;<br><br>NS_ASSUME_NONNULL_BEGIN<br><br>@interface Person : NSObject<br>@property(nonatomic, copy) NSString *name;<br>@property(nonatomic, assign) NSInteger age;<br>@end<br><br>@interface Student : NSObject<br>@property(nonatomic, copy) NSString *infomation;<br>@property(nonatomic, strong) Person *p;<br>@end<br><br>NS_ASSUME_NONNULL_END<br></code></pre></td></tr></table></figure><p>此时需要观察Student类实例中infomation属性值的变化，而information属性值依赖于Person属性的值，如何确定这种依赖关系呢？</p><ol><li><p>手动实现information的setter和getter方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(void)setInfomation:(NSString *)infomation<br>&#123;<br>    NSArray *array = [infomation componentsSeparatedByString:@&quot;#&quot;];<br>    [self.p setName:[array objectAtIndex:0]];<br>    [self.p setAge: [[array objectAtIndex:1] integerValue]];<br>&#125;<br><br>-(NSString *)infomation<br>&#123;<br>    return [NSString stringWithFormat:@&quot;%@#%ld&quot;,self.p.name,self.p.age];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现<code>+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key</code>方法</p><p>这个方法告诉系统infomation属性依赖于其它哪些属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">+(NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key<br>&#123;<br>    if ([key isEqualToString:@&quot;infomation&quot;]) &#123;<br>        return [NSSet setWithObjects:@&quot;p.name&quot;,@&quot;p.age&quot;, nil];<br>    &#125;<br>    return  nil;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>控制器中添加观察者和实现KVO回调</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(void)viewDidLoad<br>&#123;<br>   self.stu = [[Student alloc] init];<br>    Person *p = [[Person alloc] init];<br>    self.stu.p = p;<br>    <br>    self.stu.infomation = @&quot;a#1&quot;;<br>    NSLog(@&quot;%@&quot;,self.stu.infomation);<br>    [self.stu addObserver:self forKeyPath:@&quot;infomation&quot; options:NSKeyValueObservingOptionNew |   NSKeyValueObservingOptionOld context:nil];<br>&#125;<br><br>-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context<br>&#123;<br>    if ([keyPath isEqualToString:@&quot;infomation&quot;]) &#123;<br>        NSLog(@&quot;%@&quot;,self.stu.infomation);<br>    &#125;<br>&#125;<br><br>-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event<br>&#123;<br>    self.stu.p.name = @&quot;abc&quot;;<br>    self.stu.p.age = 2;<br>&#125;<br>//  log <br>a#1<br>abc#1<br>abc#2<br></code></pre></td></tr></table></figure><p>当分别设置Person的name和age属性时，infomation的值都会发生变化，所以会打印两次infomation的信息。</p></li></ol><h4 id="4-KVO的本质"><a href="#4-KVO的本质" class="headerlink" title="4. KVO的本质"></a>4. KVO的本质</h4><ul><li><p>未使用KVO监听的对象</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202202151622862.png" alt="未使用KVO监听的对象" style="zoom:50%;margin-left:10px" /></li><li><p>使用KVO监听的对象</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202202151622219.png" alt="使用KVO监听的对象" style="zoom:50%;margin-left:10px" /></li></ul><p>通过上面两幅图片我们可以看出，当某个类(<code>Person</code>)的对象第一次被观察时，系统会在运行时动态的创建对应于该类的一个派生类（如：<code>NSKVONotifying_DelegateDemo.Person</code>），在这个派生类中，系统会重写父类中被观察属性的<code>setter</code>方法。在重写的setter方法中实现真正的通知机制，类似下面的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// _NSSetIntValueAndNotify方法的伪代码实现<br>-(void)setAge:(int)age&#123;<br>  //`NSKVONotifying_DelegateDemo.Person`类重写了`setAge`方法的实现，它会调用`Foundation`框架中的`_NSSetxxxValueAndNotify`方法<br>  _NSSetIntValueAndNotify()<br>&#125;<br><br>-(void)_NSSetIntValueAndNotify&#123;<br>  [self willChangeValueForKey:@&quot;age&quot;];<br>  [super setAge:age];<br>  [self didChangeValueForKey:@&quot;age&quot;]；<br>&#125;<br><br>-(void)didChangeValueForKey:(NSString*)key&#123;<br>  // 通知监听器，某属性发生了改变<br>  [oberser oberserValueForKeyPath:key ofObject:self change:nil context:nil];<br>&#125;<br><br></code></pre></td></tr></table></figure><p>要通过<code>KVO</code>来实现观察者模式，必须遵循<code>KVO</code>的属性设置方式（<code>KVC</code>或者<code>setter</code>方法）来改变属性值，如果仅是直接修改属性对应的成员变量，那么是无法实现<code>KVO</code>的。</p><p>当系统在运行时创建派生类的同时，派生类还重写了<code>class</code>的方法，让开发者以为正在调用的类还是原始类。然后系统会将这个对象的isa指针指向新创建的派生类，因此这个对象就成了该派生类的对象，因而当开发者调用属性的setter方法时，实际上是调用重写后的<code>setter</code>方法，从而实现了键值通知的机制。此外，派生类还重写了<code>dealloc</code>方法来释放内存资源。</p><h4 id="5-问题"><a href="#5-问题" class="headerlink" title="5. 问题"></a>5. 问题</h4><ol><li><p>在什么情况下会触发KVO?</p><p>KVC或者调用了<code>setter</code>方法</p></li><li><p>如何手动触发KVO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 以上面的age属性为例, 手动触发KVO<br>// 在需要触发KVO的地方滴啊用<br>[self willChangeValueForKey:@&quot;age&quot;];<br>[self didChangeValueForKey:@&quot;age&quot;]；<br><br></code></pre></td></tr></table></figure></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="">iOS程序员面试笔试宝典</a></li><li><a href="">小马哥视频</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_消息传递方式</title>
    <link href="/2022/01/19/iOS/%E5%A4%87%E8%80%83/OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/iOS_%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/01/19/iOS/%E5%A4%87%E8%80%83/OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/iOS_%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们通常都是用什么方式，实现iOS不同界面的消息传递呢？系统到底为我们提供了多少种方式呢？怀着这样的想法，在此对常用的消息传递的方式做了个简单的总结。</p><h3 id="一、代理"><a href="#一、代理" class="headerlink" title="一、代理"></a>一、代理</h3><h4 id="1-代理的定义？"><a href="#1-代理的定义？" class="headerlink" title="1. 代理的定义？"></a>1. 代理的定义？</h4><p>代理是一种软件设计模式，在iOS当中以<code>@protocal</code>形式体现，实现消息一对一的传递</p><h4 id="2-代理的实现"><a href="#2-代理的实现" class="headerlink" title="2. 代理的实现"></a>2. 代理的实现</h4><p>代理有三部分组成：</p><ul><li><p>协议</p><p>定义属性和方法</p><p>协议方法有两个修饰符<code>@Required</code>和<code>@Optional</code>，被<code>@Required</code>修饰的方法，必须要实现，而<code>@Optional</code>修饰的方法可以实现也可以不实现。</p></li><li><p>委托方</p><p>按照协议，告知代理方需要实现的方法</p></li><li><p>代理方</p><p>遵守协议，实现协议方法（有的需要完成委托方需求的同时，返回处理结果）</p></li></ul><p>图示：</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202202151007480.png" alt="代理图解"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> UIKit<br><span class="hljs-comment">// 协议</span><br><span class="hljs-keyword">@objc</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TestViewDelegate</span>:<span class="hljs-title">NSObjectProtocol</span></span>&#123; <br>   <span class="hljs-keyword">@objc</span> <span class="hljs-keyword">optional</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testViewSelected</span>(<span class="hljs-params">testView</span>: <span class="hljs-type">TestView</span>)</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestView</span>: <span class="hljs-title">UIView</span> </span>&#123;<br>    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> delegate:<span class="hljs-type">TestViewDelegate</span>?<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">touchesBegan</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">touches</span>: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">UITouch</span>&gt;, <span class="hljs-params">with</span> <span class="hljs-params">event</span>: <span class="hljs-type">UIEvent</span>?)</span> &#123;<br>        <span class="hljs-keyword">self</span>.delegate<span class="hljs-operator">?</span>.testViewSelected<span class="hljs-operator">?</span>(testView: <span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br><span class="hljs-operator">---------------------------------------------------------------------------------</span><br><span class="hljs-keyword">import</span> UIKit<br><span class="hljs-comment">// 遵守协议</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span>,<span class="hljs-title">TestViewDelegate</span> </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidLoad</span>()</span> &#123;<br>        <span class="hljs-keyword">super</span>.viewDidLoad()<br>        <span class="hljs-keyword">let</span> testV <span class="hljs-operator">=</span> <span class="hljs-type">TestView</span>.<span class="hljs-keyword">init</span>(frame: <span class="hljs-type">UIScreen</span>.main.bounds)<br>        testV.backgroundColor <span class="hljs-operator">=</span> <span class="hljs-type">UIColor</span>.red<br>        <span class="hljs-comment">// 设置代理</span><br>        testV.delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><br>        <span class="hljs-keyword">self</span>.view.addSubview(testV)<br>    &#125;<br>    <span class="hljs-comment">//实现协议方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testViewSelected</span>(<span class="hljs-params">testView</span>: <span class="hljs-type">TestView</span>)</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;实现协议&quot;</span>)<br>    &#125;<br>&#125;                   <br></code></pre></td></tr></table></figure><h4 id="3-为什么设置代理属性需要用weak？"><a href="#3-为什么设置代理属性需要用weak？" class="headerlink" title="3. 为什么设置代理属性需要用weak？"></a>3. 为什么设置代理属性需要用weak？</h4><p>以在控制器中使用<code>tableview</code>为例，我们在控制器中通过<code>alloc</code>、<code>new</code>等方式创建<code>tableview</code>视图对象的时候，当前控制器会强引用着<code>tableview</code>。如果我们修饰<code>tableview</code>的代理用的是<code>strong</code>，在设置代理的时候， 代理对象往往会设置成<code>self</code>即当前控制器，导致<code>tableview</code>又强引用这控制器。这就造成了循环引用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift">tableView.delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><br><span class="hljs-keyword">self</span> -&gt; tableView -&gt; delegate -&gt; <span class="hljs-keyword">self</span><br></code></pre></td></tr></table></figure><p>循环引用的危害：</p><ul><li>会使内存消耗过高，导致内存泄露</li><li>性能变差</li><li>可能会出现闪退</li></ul><h4 id="4-代理的原理"><a href="#4-代理的原理" class="headerlink" title="4. 代理的原理"></a>4. 代理的原理</h4><p><font color=orange># warning 后面补充</font></p><h3 id="二、通知（NSNotification）"><a href="#二、通知（NSNotification）" class="headerlink" title="二、通知（NSNotification）"></a>二、通知（NSNotification）</h3><h4 id="1-什么是通知"><a href="#1-什么是通知" class="headerlink" title="1. 什么是通知?"></a>1. 什么是通知?</h4><ol><li>通知是使用观察者模式实现的用于跨层传递消息的机制</li><li>传递方式为一对多</li></ol><h4 id="2-如何实现通知机制？"><a href="#2-如何实现通知机制？" class="headerlink" title="2. 如何实现通知机制？"></a>2. 如何实现通知机制？</h4><p>通知中心可能会维护一个<code>map</code>表，<code>key</code>为<code>notificationName</code>  <code>value</code>为<code>observers_list</code>，<code>observers_list</code> 包含通知接收的观察者以及观察者的调用方法</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202202141642268.png" alt="通知机制" style="margin-left: 10px; zoom: 67%;" /><h4 id="3-通知是同步还是异步？"><a href="#3-通知是同步还是异步？" class="headerlink" title="3. 通知是同步还是异步？"></a>3. 通知是同步还是异步？</h4><p><code>NSNotification</code>默认在主线程中通知是<font color=Orange>同步的</font>，当通知产生的时候，通知中心会一直等到所有的观察者都收到并处理通知结束，然后才会返回发送通知的地方继续执行后面的代码。但是可以将通知的发送或者将通知的处理方法放入子线程中来避免线程阻塞。</p><p><strong>验证：</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 自定义消息名称</span><br><span class="hljs-keyword">let</span> notiName <span class="hljs-operator">=</span> <span class="hljs-string">&quot;postNoti&quot;</span><br><span class="hljs-comment">// 发送通知</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;即将发送通知&quot;</span>)<br><span class="hljs-type">NotificationCenter</span>.default.post(name: <span class="hljs-type">NSNotification</span>.<span class="hljs-type">Name</span>(notiName), object: <span class="hljs-literal">nil</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;发送通知后执行&quot;</span>)<br><br><br><span class="hljs-comment">// 注册通知的观察者</span><br><span class="hljs-type">NotificationCenter</span>.default.addObserver(<span class="hljs-keyword">self</span>, selector: #selector(reciveNoti), name: <span class="hljs-type">NSNotification</span>.<span class="hljs-type">Name</span>(notiName), object: <span class="hljs-literal">nil</span>)<br><span class="hljs-comment">// 收到通知</span><br><span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reciveNoti</span>()</span>&#123;<br>    sleep(<span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;收到通知后执行&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 执行结果</span><br>即将发送通知<br>收到通知后执行<br>发送通知后执行<br></code></pre></td></tr></table></figure><p><strong>解决线程阻塞：</strong></p><ol><li><p>将通知发送放入子线程</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 发送通知</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;即将发送通知&quot;</span>)<br><span class="hljs-type">DispatchQueue</span>.global().async &#123;<br><span class="hljs-type">NotificationCenter</span>.default.post(name: <span class="hljs-type">NSNotification</span>.<span class="hljs-type">Name</span>(notiName), object: <span class="hljs-literal">nil</span>)<br>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;发送通知后执行&quot;</span>)<br><br><span class="hljs-comment">// 执行结果</span><br>即将发送通知<br>发送通知后执行<br>收到通知后执行<br></code></pre></td></tr></table></figure></li><li><p>将通知处理方法放入子线程</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 收到通知</span><br><span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reciveNoti</span>()</span>&#123;<br><span class="hljs-type">DispatchQueue</span>.global().async &#123;<br>sleep(<span class="hljs-number">10</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;收到通知后执行&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 执行结果</span><br>即将发送通知<br>发送通知后执行<br>收到通知后执行<br></code></pre></td></tr></table></figure></li><li><p>将通知发送放到通知异步缓冲队列中</p><p><code>NSNotificationQueue</code>是一个通知缓冲队列，通常以FIFO（先进先出）的规则维护通知队列的发送。向缓冲队列添加通知有三个枚举：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">PostingStyle</span> : <span class="hljs-title">UInt</span> </span>&#123;<br>   <span class="hljs-keyword">case</span> whenIdle <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">// 空闲时发送</span><br>   <span class="hljs-keyword">case</span> asap <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-comment">// 尽快发送</span><br>   <span class="hljs-keyword">case</span> now <span class="hljs-operator">=</span> <span class="hljs-number">3</span>  <span class="hljs-comment">// 立即发送</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><br><span class="hljs-comment">// 发送通知</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;即将发送通知&quot;</span>)<br><span class="hljs-keyword">let</span> noti <span class="hljs-operator">=</span> <span class="hljs-type">Notification</span>.<span class="hljs-keyword">init</span>(name: <span class="hljs-type">Notification</span>.<span class="hljs-type">Name</span>(notiName), object: <span class="hljs-literal">nil</span>, userInfo: [<span class="hljs-string">&quot;key&quot;</span>:<span class="hljs-string">&quot;value&quot;</span>])<br><span class="hljs-type">NotificationQueue</span>.default.enqueue(noti, postingStyle: .asap)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;发送通知后执行&quot;</span>)<br><br><span class="hljs-comment">// 执行结果</span><br>即将发送通知<br>发送通知后执行<br>收到通知后执行<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-通知和代理的区别"><a href="#4-通知和代理的区别" class="headerlink" title="4. 通知和代理的区别"></a>4. 通知和代理的区别</h4><ul><li>主要区别是代理传递消息是一对一，通知是一对多</li><li>代理模式中，reciver（接收者）可以返回值给sender（发送者），实现一种回调，而观察者模式不可以</li></ul><h3 id="三、KVO"><a href="#三、KVO" class="headerlink" title="三、KVO"></a>三、KVO</h3><p>​    参考文章<a href="">iOS_KVC与KVO</a></p><h3 id="四、Block"><a href="#四、Block" class="headerlink" title="四、Block"></a>四、Block</h3><h4 id="1-什么是Block？"><a href="#1-什么是Block？" class="headerlink" title="1. 什么是Block？"></a>1. 什么是Block？</h4><p>Block是将函数及其执行上下文封装起来的对象。</p><h4 id="2-Block有哪几种定义的方式？"><a href="#2-Block有哪几种定义的方式？" class="headerlink" title="2. Block有哪几种定义的方式？"></a>2. Block有哪几种定义的方式？</h4><p>在Objective-C中，<code>block</code>定义包含了<code>block</code>的类型声明和实现，基本形式如下：</p><p><font color=orange >返回值类型(^block名称)(参数类型)=^(参数类型和参数名){}</font></p><p>其中，返回值类型和参数都可以为空。如果有参数，那么在定义<code>block</code>的时候，必须标明参数的类型和参数名。所以，<code>block</code>大致有三种定义方式。</p><ul><li><p>没有返回值，没有参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">void (^myBlock)(void) = ^&#123;<br>    // 代码<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>有返回值，没有参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSString* (^myBlock)(void) = ^&#123;<br>    // 代码<br>    return @&quot;返回值&quot;;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>有返回值，有参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSInteger (^myBlock)(NSInteger) = ^(NSInteger a)&#123;<br>    // 代码<br>    return a+1;<br>&#125;;<br></code></pre></td></tr></table></figure><p>像在Objective-C中字符串对象属于<code>NSString</code>类型一样，<code>blcok</code>也有属于自己的类型，<code>block</code>类型的格式就是：</p><p><font color=orange>返回值类型(^)参数类型</font></p><p>也就是说，上面第一种定义方式的block类型就是<code>void(^)(void)</code>，<code>myBlock</code>不是变量名，而是这种<code>block</code>类型的别名。我们可以使用<code>typedef</code>关键字定义block类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">typedef void (^MyBlock)(void);<br>@interface ViewController ()<br>@property(nonatomic,strong)MyBlock myblock;<br>@end<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-在ARC环境下，-是否需要使用copy关键字来修饰block？"><a href="#3-在ARC环境下，-是否需要使用copy关键字来修饰block？" class="headerlink" title="3. 在ARC环境下， 是否需要使用copy关键字来修饰block？"></a>3. 在ARC环境下， 是否需要使用copy关键字来修饰block？</h4><p>block其实包含两个组成部分：</p><ul><li><code>block</code>所执行的代码，这一部分在编译的时候已经确定</li><li><code>block</code>执行时所需要的外部变量值的数据结构</li></ul><p>根据block在内存中的位置，系统将block分为3类：</p><ol><li><p>NSGlobalBlcok</p><p>该类型的<code>block</code>类似函数，内存地址位于内存全局区。<u>只要block没有对作用域中局部变量进行引用</u>，此<code>block</code>会被系统设置为该类。对于<code>NSGlobalBlock</code>类型的<code>block</code>无需做更多的处理，即使使用<code>copy</code>关键字修饰，系统也不会改变<code>block</code>的内存地址，操作无效。</p></li><li><p>NSStackBlock</p><p>该类型的<code>block</code>内存位于栈，其生命周期由函数决定，函数返回后<code>block</code>将无效。</p><p><code>MRC</code>环境下，若<code>block</code>内部引用了局部变量，此<code>block</code>就会被系统设置为该类型。对于<code>NSStackBlock</code>类型的<code>block</code>，使用<code>retain</code>和<code>release</code>操作都是无效的，必须调用<code>Block_copy</code>()方法，或者使用<code>copy</code>修饰，将<code>block</code>的内存地址从栈转移到堆，此时的<code>block</code>就会转变为<code>NSMallocBlock</code>类型，这也是一直使用<code>copy</code>修饰<code>block</code>的原因。</p><p>在<code>ARC</code>环境下，若<code>block</code>内部引用了局部变量，系统会默认使用<code>copy</code>对block进行修饰，使其变成<code>NSMallocBlock</code>类型，所以<u>在ARC环境下，不需要手动使用copy关键字来修饰block。</u></p></li><li><p>NSMallocBlock</p><p>当对<code>NSStackBlock</code>类型的<code>block</code>进行<code>copy</code>操作后，<code>block</code>会被转化为此类型。在<code>MRC</code>环境下，可以使用<code>retain</code>、<code>release</code>等方法手动管理此类型的生命周期。在<code>ARC</code>环境下，系统会帮助我们自动管理此类型<code>block</code>的生命中周期。</p></li></ol><h4 id="4-在block内部如何修改block外部的变量？"><a href="#4-在block内部如何修改block外部的变量？" class="headerlink" title="4. 在block内部如何修改block外部的变量？"></a>4. 在block内部如何修改block外部的变量？</h4><p><code>block</code>内部修改<code>block</code>外部局部变量时，会提示如下错误：</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202202171715864.png" alt="block内部修改外部局部变量" style="zoom: 33%; margin-left: 10px;" /><p>正确的修改方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">__block NSInteger a = 1;<br>void (^myBlock)(NSInteger) = ^(NSInteger b)&#123;<br>    // 代码<br>    a = 2;<br>    NSInteger sum = a+b;<br>    NSLog(@&quot;sum=%ld&quot;,sum);<br>&#125;;<br>myBlock(1);<br></code></pre></td></tr></table></figure><p>当外部变量没有使用<code>__block</code>修饰时，<code>block</code>在截获外部的自动变量时会在内部新创建一个新的变量<code>a1</code>来保存所截获的外部变量的瞬时值，之后再<code>block</code>代码中修改的值是成员变量<code>a1</code>的值。伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">int a = 1;<br>void block()&#123;<br>  int a1 = a;<br>  a1 += 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>当外部使用<code>__block</code>修饰时，此时的<code>block</code>保存了对外部变量的指针引用，因此对指针变量的修改会直接影响外部变量的值。伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">__block int a = 1;<br>void block()&#123;<br>  int *ptr = &amp;a;<br>  *ptr += 1;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：此处讨论的是自动变量，而静态变量由于默认传给block的就是地址值，所以是可以直接修改的。另外，全局变量和静态全局变量由于作用域很广，也是可以在block中直接被修改的。</p></blockquote><h4 id="5-block中使用self关键字是否一定会导致循环引用"><a href="#5-block中使用self关键字是否一定会导致循环引用" class="headerlink" title="5. block中使用self关键字是否一定会导致循环引用?"></a>5. block中使用self关键字是否一定会导致循环引用?</h4><p>在<code>block</code> 中使用<code>self</code>关键字并不总会引起循环引用。事实上只有<code>block</code>和<code>self</code>相互持有时，才会导致循环引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">typedef void (^block)(void);<br>@property(nonatomic,strong)block myblock;<br>@property(nonatomic,copy)NSString *name;<br><br>self.myblock = ^&#123;<br>  // 由于block会对block中的对象进行持有操作，就相当于持有了其中的对象，此时block中的对象又持有了该block,那么就会造成循环引用<br>    NSString *myName = self.name;<br>    NSLog(@&quot;%@&quot;,myName);<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>在实际开发中，主要使用弱引用的方法来避免循环引用的产生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">__weak typeof(self) weakSelf = self;<br>self.myblock = ^&#123;<br>     NSString *myName = weakSelf.name;<br>     NSLog(@&quot;%@&quot;,myName);<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是不会造成循环引用的几种情况：</p><ol><li>大部分GCD方法</li><li>block作为临时变量</li><li>block执行过程中self对象被释放。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="">iOS程序面试笔试宝典</a></p></li><li><p><a href="https://juejin.cn/post/6844904150359080967">IOS Delegate使用及原理实现</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_Category和Extension</title>
    <link href="/2022/01/19/iOS/%E5%A4%87%E8%80%83/OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/iOS-Category%E5%92%8CExtension/"/>
    <url>/2022/01/19/iOS/%E5%A4%87%E8%80%83/OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/iOS-Category%E5%92%8CExtension/</url>
    
    <content type="html"><![CDATA[<h3 id="一-Category（分类）"><a href="#一-Category（分类）" class="headerlink" title="一. Category（分类）"></a>一. Category（分类）</h3><h4 id="1-Category可以添加哪些内容？"><a href="#1-Category可以添加哪些内容？" class="headerlink" title="1. Category可以添加哪些内容？"></a>1. Category可以添加哪些内容？</h4><ol><li>实例方法</li><li>类方法</li><li>协议</li><li>属性（只有<code>setter</code>和<code>getter</code>方法的声明，没有实现，没有成员变量）</li></ol><h4 id="2-Category实现原理"><a href="#2-Category实现原理" class="headerlink" title="2. Category实现原理"></a>2. Category实现原理</h4><p>Category的底层结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">struct category_t &#123;<br>       const char *name;<br>       classref_t cls;<br>       struct method_list_t *instanceMethods;<br>       struct method_list_t *classMethods;<br>       struct protocol_list_t *protocols;<br>       struct property_list_t *instanceProperties;<br>       // Fields below this point are not always present on disk<br>       struct property_list_t *_classsProperties;<br>        <br>       method_list *methodsForMeta(bool isMeta)&#123;<br>           if (isMeta) return classMethods;<br>           else return instanceMethods;<br>       &#125;<br>   &#125;<br>   property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);<br></code></pre></td></tr></table></figure><p>对象方法及类方法调用的本质:</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202202181155272.png" alt="isa指针" style="zoom:110%;margin-left:10px" /><p>那么<code>category_t</code>结构体是什么时候放到<code>class</code>里面的呢? 在objc运行时的源码中我们可以看到，系统为我们做了以下操作：</p><ol><li>通过runtime加载某个类的所有category数据</li><li>把所有category的方法、属性、协议数据，分别合并到一个新的用于存储方法、属性、协议的大数组中（后面参与编译的category数据，会在数组前面）</li><li>将合并后的数据（方法、属性、协议），分别插入到类原有的数据前面</li></ol><p>其中的添加过程的源码如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">void</span> attachLists(List* <span class="hljs-keyword">const</span> * addedLists, uint32_t addedCount) &#123;<br>     <span class="hljs-keyword">if</span> (addedCount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>     <span class="hljs-keyword">if</span> (hasArray()) &#123;<br>         <span class="hljs-comment">// many lists -&gt; many lists</span><br>         uint32_t oldCount = array()-&gt;count;<br>         uint32_t newCount = oldCount + addedCount;<br>         setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));<br>         array()-&gt;count = newCount;<br>        <span class="hljs-comment">//根据所有分类的方法列表的数量addedCount，将类对象原有方法列表的内存地址向后移动addedCount位</span><br>         memmove(array()-&gt;lists + addedCount, array()-&gt;lists, <br>                    oldCount * <span class="hljs-keyword">sizeof</span>(array()-&gt;lists[<span class="hljs-number">0</span>]));<br>       <span class="hljs-comment">//将所有对象的方法列表copy到前addedCount位上</span><br>         memcpy(array()-&gt;lists, addedLists, <br>                   addedCount * <span class="hljs-keyword">sizeof</span>(array()-&gt;lists[<span class="hljs-number">0</span>]));<br>     &#125;<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!list  &amp;&amp;  addedCount == <span class="hljs-number">1</span>) &#123;<br>         <span class="hljs-comment">// 0 lists -&gt; 1 list</span><br>         list = addedLists[<span class="hljs-number">0</span>];<br>     &#125; <br>     <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// 1 list -&gt; many lists</span><br>         List* oldList = list;<br>         uint32_t oldCount = oldList ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>         uint32_t newCount = oldCount + addedCount;<br>         setArray((array_t *)malloc(array_t::byteSize(newCount)));<br>         array()-&gt;count = newCount;<br>         <span class="hljs-keyword">if</span> (oldList) array()-&gt;lists[addedCount] = oldList;<br>         memcpy(array()-&gt;lists, addedLists, <br>               addedCount * <span class="hljs-keyword">sizeof</span>(array()-&gt;lists[<span class="hljs-number">0</span>]));<br>     &#125;<br> &#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="3-Category中load和initialize的区别"><a href="#3-Category中load和initialize的区别" class="headerlink" title="3. Category中load和initialize的区别"></a>3. Category中load和initialize的区别</h4><ol><li><p>+load</p><p>调用时机：</p><p><code>+load</code> 方法会在<code>runtime</code>加载类、分类时调用，每个程序的类、分类的<code>+load</code>，在程序运行过程中只会调用一次</p><p>调用顺序：</p><ul><li><p>先调用类的<code>+load</code>方法</p><p>按照编译顺序先编译先调用</p><p>调用子类的<code>+load</code>方法之前会先调用父类的<code>+load</code>方法</p></li><li><p>再调用分类的<code>+load</code>方法</p><p>按照编译先后顺序代用</p></li></ul></li><li><p>+initialize</p><p>调用时机：</p><ul><li><code>+initialize</code>方法会在类第一次接收消息时调用</li></ul><p>调用顺序：</p><ul><li>先调用父类的<code>+initialize</code>再调用子类的<code>+initialize</code>（先初始化父类，再初始化子类，每个类只会初始化一次）</li><li>分类的<code>+initialize</code>会覆盖类的<code>+initialize</code></li></ul></li><li><p>+initialize与load的区别：</p><p><code>+initialize</code>方法时通过<code>objc_msgSend</code>进行调用的，<code>+load</code>是找到<code>+load</code>方法内存地址直接调用的，所以<code>+initialize</code>方法有以下特点：</p><ul><li>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initialize</code>（所以父类的<code>+initialize</code>方法可能会被调用多次）</li><li>如果分类实现了<code>+initialize</code>，就会覆盖本身的<code>+initialize</code>调用</li></ul></li></ol><h4 id="4-为分类添加成员变量"><a href="#4-为分类添加成员变量" class="headerlink" title="4. 为分类添加成员变量"></a>4. 为分类添加成员变量</h4><ul><li><p>使用关联对象的方法间接添加成员变量:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &quot;Person+test.h&quot;<br>#import &lt;objc/runtime.h&gt;<br><br>@implementation Person (test)<br><br>-(void)setName:(NSString *)name&#123;<br>    /**<br>     object: 需要关联的对象<br>     key: const void * 类型的key(常见写法：1.使用属性名作为key 2. 使用get方法的@selector作为key)<br>     value：关联值<br>     objc_AssociationPolicy:关联策略<br>     */<br>    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>&#125;<br><br>-(NSString*)name&#123;<br>    return  objc_getAssociatedObject(self, _cmd);<br>&#125;<br><br>@end<br>  <br>// 移除name<br>objc_setAssociatedObject(self, @selector(name), nil, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>// 移除self的所有关联对象<br>objc_removeAssociatedObjects(self)<br></code></pre></td></tr></table></figure></li><li><p>关联对象的原理：</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202202231652896.png" alt="关联对象的原理" style="zoom:110%;margin-left:10px" /></li></ul><h3 id="二、Extension（类扩展）"><a href="#二、Extension（类扩展）" class="headerlink" title="二、Extension（类扩展）"></a>二、Extension（类扩展）</h3><h4 id="1-扩展的用途？"><a href="#1-扩展的用途？" class="headerlink" title="1. 扩展的用途？"></a>1. 扩展的用途？</h4><ul><li>声明私有属性</li><li>声明私有成员变量</li><li>声明私有方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface ViewController ()<br>&#123;<br>    NSString *name;<br>&#125;<br>@property(nonatomic,assign)NSInteger age;<br>-(void)test;<br><br>@end<br></code></pre></td></tr></table></figure><h4 id="2-category和extension的区别是什么？"><a href="#2-category和extension的区别是什么？" class="headerlink" title="2. category和extension的区别是什么？"></a>2. category和extension的区别是什么？</h4><ul><li>category是运行时决议，extension是编译是决议</li><li>category有声明和实现，extension只以声明的形式，实现多数情况下寄生于宿主类的.m中</li><li>category可以为系统类添加分类，extension不能为系统类添加扩展</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol><li>Category的实现原理，以及Category为什么只能加方法，不能加属性</li><li>Category中有load方法么？load方法时什么时候调用的？load方法能继承吗？</li><li>load、initialize在category中的调用顺序，以及出现继承时它们之间的调用过程？ </li><li>load、initialize的区别，以及它们在category重写的时候的调用次序？</li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_图像显示原理</title>
    <link href="/2022/01/18/iOS/%E5%A4%87%E8%80%83/UI%E8%A7%86%E5%9B%BE/iOS_%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86/"/>
    <url>/2022/01/18/iOS/%E5%A4%87%E8%80%83/UI%E8%A7%86%E5%9B%BE/iOS_%E5%9B%BE%E5%83%8F%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在看一些视频，觉得有必要把里面的内容记录下来方便之后复习。</p><h3 id="一、图像的显示原理"><a href="#一、图像的显示原理" class="headerlink" title="一、图像的显示原理"></a>一、图像的显示原理</h3><p> <code>CPU</code>和<code>GPU</code>两个硬件通过总线链接起来，<code>CPU</code>输出的结果(往往是一个位图(<code>bitmap</code>)经由总线传给<code>GPU</code>，<code>GPU</code>拿到位图之后，会对位图做相应的图层的渲染、纹理的合成等处理。之后会把结果放入帧缓冲区(<code>Frame Buffer</code>)当中。然后由视频控制器根据VSync信号在指定时间之前去提取对应帧缓冲区当中的屏幕显示内容，最终显示到屏幕上面。</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202201181755791.png" alt="iOS图像显示原理1" style="zoom:67%;margin-left:10px" /><p>UIView视图渲染的大致过程：</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202201181803337.png" alt="iOS图像显示原理2" style="zoom:67%;margin-left:10px" /><p>当我们创建了一个<code>UIView</code>控件之后，它的显示部分是由<code>CALayer</code>负责的，在<code>CALayer</code>当中有一个<code>contents</code>属性，就是我们最终要绘制到屏幕当中的一个位图。比如说我们创建的是一个<code>UILabel</code>，那么 <code>contents</code>里面放置的就是关于<code>hello world</code>的文字的位图。系统会在合适的时机回调给我们一个<code>DrawRect:</code> 方法，我们可以在此基础之上绘制我们自己想要自定义绘制的内容，绘制好的位图最终会经由<code>Core Animation</code>这个框架提交给<code>GPU</code>部分的<code>OpenGL(ES</code>)渲染管线，进行最终位图的渲染，包括纹理的合成，然后显示到屏幕上面。</p><blockquote><p>根据单一职责原则，UIView是专门负责事件传递和视图响应的，CALayer全权负责视图的显示。</p></blockquote><p>在这个过程中CPU、GPU做了什么呢</p><h4 id="1-CPU的工作"><a href="#1-CPU的工作" class="headerlink" title="1. CPU的工作"></a>1. CPU的工作</h4><ul><li><p>Layoyut </p><p>UI布局、文本计算</p></li><li><p>Display</p><p>绘制</p></li><li><p>Prepare</p><p>如：图片编解码</p></li><li><p>Commit</p><p>提交位图</p></li></ul><h4 id="2-GPU渲染管线"><a href="#2-GPU渲染管线" class="headerlink" title="2. GPU渲染管线"></a>2. GPU渲染管线</h4><ul><li>顶点着色</li><li>图元装配</li><li>光栅化</li><li>片段着色</li><li>片段处理</li></ul><h3 id="二、卡顿和掉帧的原因"><a href="#二、卡顿和掉帧的原因" class="headerlink" title="二、卡顿和掉帧的原因"></a>二、卡顿和掉帧的原因</h3><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202201181152287.png" alt="UI卡顿、掉帧的原因" style="zoom:67%;margin-left:10px" /><p> 一般页面滑动的流畅性是60FPS, 即每一秒有60帧的画面更新。即每间隔16.7ms就会有一帧画面更新。  在规定的16.7ms之内，在下一帧<code>VSync</code>信号到来之前，<code>CPU</code>和<code>GPU</code>并没有共同完成下一帧画面的合成，就会导致卡顿、掉帧。</p><h3 id="三、滑动优化方案"><a href="#三、滑动优化方案" class="headerlink" title="三、滑动优化方案"></a>三、滑动优化方案</h3><h4 id="1-CPU资源消耗分析"><a href="#1-CPU资源消耗分析" class="headerlink" title="1. CPU资源消耗分析"></a>1. CPU资源消耗分析</h4><ul><li><p>对象创建、调整、销毁 </p><p><strong>创建</strong>：对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗<code>CPU</code>资源。尽量采取轻量级对象，尽量放到后台线程处理，尽量推迟对象的创建时间。</p><p><strong>调整</strong>：<code>frame</code>、<code>bounds</code>、<code>transform</code>及视图层次等属性调整很耗费<code>CPU</code>资源。尽量减少不必要属性的修改，尽量避免调整视图层次、添加和移除视图。</p></li><li><p>预排版（布局计算、文本计算）</p><p><strong>布局计算</strong>：随着视图数量的增长，<code>Autolayout</code>带来的<code>CPU</code>消耗会呈指数级增长，所以尽量提前算好布局，在需要时一次性调整好对应属性。</p></li><li><p>预渲染（文本等异步绘制、图片编解码等）</p><p><strong>文本渲染</strong>： 屏幕上能看到的所有文本内容控件，包括UIWebView，在底层都是通过<code>CoreText</code>排版、绘制为位图显示的。常见的文本控件，其排版与绘制都是在主线程进行的，显示大量文本时，<code>CPU</code>压力很大。对此解决方案唯一就是自定义文本控件，用<code>CoreText</code>对文本异步绘制。（很麻烦，开发成本高）。</p><p><strong>图片解码</strong>：当用<code>UIImage</code>或<code>CGImageSource</code>创建图片时，图片数据并不会立刻解码。图片设置到<code>UIImageView</code>或<code>CALayer.contents</code>中去，并且<code>CALayer</code>被提交到<code>GPU</code>前，<code>CGImage</code>中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。<code>SD_WebImage</code>处理方式：在后台线程先把图片绘制到<code>CGBitmapContext</code>中，然后从<code>Bitmap</code>直接创建图片。</p></li></ul><h4 id="2-GPU资源消耗分析"><a href="#2-GPU资源消耗分析" class="headerlink" title="2. GPU资源消耗分析"></a>2. GPU资源消耗分析</h4><ul><li><p>纹理渲染</p><p>尽量减少短时间内大量图片的显示，尽可能将多张图片合成一张进行显示 </p></li><li><p>视图混合 </p><p>尽量减少视图层次和数量，并在不透明的视图里标明<code>opaque</code>属性以避免无用的<code>Alpha</code>通道合成 </p></li><li><p>图形生成</p><p>尽量避免离屏渲染，尽量采用异步绘制，尽量避免使用圆角、阴影、遮罩等属性。必要时用静态图片实现展示效果，也可尝试光栅化缓存复用属性</p></li></ul><h3 id="四、离屏渲染"><a href="#四、离屏渲染" class="headerlink" title="四、离屏渲染"></a>四、离屏渲染</h3><h4 id="1-什么是离屏渲染"><a href="#1-什么是离屏渲染" class="headerlink" title="1. 什么是离屏渲染"></a>1. 什么是离屏渲染</h4><ul><li><p>在屏渲染（<code>On-Screen Rendering</code>）</p><p>指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区内进行</p></li><li><p>离屏渲染（<code>Off-Screen Rendering</code>）</p><p>指的是GPU在当前屏幕的缓冲区以外新开辟一个缓冲区进行渲染</p></li></ul><p>当我们指定了某些UI视图的属性,标记为它在未合成之前，不能用于当前屏幕显示的时候，就会触发离屏渲染，而离屏渲染的概念起源于GPU层面，指的是当前屏幕的缓冲区以外新开辟一个缓冲区进行渲染操作</p><h4 id="2-何时触发"><a href="#2-何时触发" class="headerlink" title="2. 何时触发"></a>2. 何时触发</h4><p><code>CoreGraphics</code>的上下文绘制，<code>drawRect</code>绘制，<code>layer</code>圆角/边框/阴影/抗锯齿/光栅化（<code>shouldRasterize</code>置为YES）</p><h4 id="3-为何要避免"><a href="#3-为何要避免" class="headerlink" title="3. 为何要避免"></a>3. 为何要避免</h4><p>在触发离屏渲染的时候，会增加<code>GPU</code>的工作量，可能导致<code>CPU</code>+<code>GPU</code>的总耗时超出16.7ms，导致UI的卡顿和掉帧。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.noobyard.com/article/p-oyuemyib-nh.html">一文读懂iOS图像显示原理与优化</a></li><li><a href="http://www.cocoachina.com/articles/25294">iOS 图像显示原理</a></li><li>慕课网iOS高级面试</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_frame和bounds的区别</title>
    <link href="/2022/01/17/iOS/%E5%A4%87%E8%80%83/UI%E8%A7%86%E5%9B%BE/iOS-frame%E5%92%8Cbounds%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/01/17/iOS/%E5%A4%87%E8%80%83/UI%E8%A7%86%E5%9B%BE/iOS-frame%E5%92%8Cbounds%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>有时候不明白什么时候用<code>frame</code>合适什么时候用<code>bounds</code>合适，在这里记录下它们的区别。</p><h4 id="一、Frame"><a href="#一、Frame" class="headerlink" title="一、Frame"></a>一、Frame</h4><p>控件在父控件中的位置和尺寸（以父控件的左上角为坐标原点）</p><h3 id="二、Bounds"><a href="#二、Bounds" class="headerlink" title="二、Bounds"></a>二、Bounds</h3><p>控件的位置和尺寸（以自己左上角为坐标原点的，所以<code>bounds</code>的x、y一般都为0）</p><h3 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h3><p>按照下面代码创建视图，我们可以看到图1当前视图坐标系，以及图2修改view视图<code>bounds</code>后，视图的坐标系以及对现有视图大小和尺寸的影响</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> view <span class="hljs-operator">=</span> <span class="hljs-type">UIView</span>.<span class="hljs-keyword">init</span>(frame: <span class="hljs-type">CGRect</span>.<span class="hljs-keyword">init</span>(x: <span class="hljs-number">100</span>, y: <span class="hljs-number">100</span>, width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>))<br>view.backgroundColor <span class="hljs-operator">=</span> <span class="hljs-type">UIColor</span>.systemCyan<br><span class="hljs-keyword">self</span>.view.addSubview(view)<br>        <br><span class="hljs-keyword">let</span> subVeiw <span class="hljs-operator">=</span> <span class="hljs-type">UIView</span>.<span class="hljs-keyword">init</span>(frame: <span class="hljs-type">CGRect</span>.<span class="hljs-keyword">init</span>(x: <span class="hljs-number">100</span>, y: <span class="hljs-number">100</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">100</span>))<br>subVeiw.backgroundColor <span class="hljs-operator">=</span> <span class="hljs-type">UIColor</span>.systemPink<br>view.addSubview(subVeiw)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;view: frame:<span class="hljs-subst">\(view.frame)</span>---bounds:<span class="hljs-subst">\(view.bounds)</span>&quot;</span> )<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subV: frame:<span class="hljs-subst">\(subVeiw.frame)</span>---bounds:<span class="hljs-subst">\(subVeiw.bounds)</span>&quot;</span> )<br><span class="hljs-comment">// log</span><br>view: frame:(<span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">200.0</span>, <span class="hljs-number">200.0</span>)<span class="hljs-operator">---</span>bounds:(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">200.0</span>, <span class="hljs-number">200.0</span>)<br>subV: frame:(<span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>)<span class="hljs-operator">---</span>bounds:(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>) <br><br><span class="hljs-comment">//修改view的bounds</span><br>view.bounds <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>.<span class="hljs-keyword">init</span>(x: <span class="hljs-number">50</span>, y: <span class="hljs-number">50</span>, width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;view: frame:<span class="hljs-subst">\(view.frame)</span>---bounds:<span class="hljs-subst">\(view.bounds)</span>&quot;</span> )<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subV: frame:<span class="hljs-subst">\(subVeiw.frame)</span>---bounds:<span class="hljs-subst">\(subVeiw.bounds)</span>&quot;</span> )<br><span class="hljs-comment">//log</span><br>view: frame:(<span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">200.0</span>, <span class="hljs-number">200.0</span>)<span class="hljs-operator">---</span>bounds:(<span class="hljs-number">50.0</span>, <span class="hljs-number">50.0</span>, <span class="hljs-number">200.0</span>, <span class="hljs-number">200.0</span>)<br>subV: frame:(<span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>)<span class="hljs-operator">---</span>bounds:(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>)<br></code></pre></td></tr></table></figure><p>修改前坐标系：</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202201171739147.png" alt="frame坐标系" style="zoom:50%;margin-left:10px" /><p>修改后：</p><p>我们可以看到修改父控件view的<code>bounds</code>后，对父控件的位置没什么影响，影响的是子控件的位置</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202201171750616.png" alt="修改bounds后" style="zoom:50%;margin-left:10px" /><p>总结：</p><ol><li>如果是想改变当前控件的尺寸，使用当前控件的属性<code>frame</code>和<code>bounds</code>是等效的。</li><li>如果想改变当前控件的位置，可以使用当前控件的<code>frame</code>属性。</li><li>当前控件<code>bounds</code>的x、y一般为0，修改当前控件<code>bounds</code>的x、y，不会对当前控件的位置和大小有什么影响，只会影响其子视图的位置。</li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_事件</title>
    <link href="/2022/01/07/iOS/%E5%A4%87%E8%80%83/UI%E8%A7%86%E5%9B%BE/iOS%20-%E4%BA%8B%E4%BB%B6/"/>
    <url>/2022/01/07/iOS/%E5%A4%87%E8%80%83/UI%E8%A7%86%E5%9B%BE/iOS%20-%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在iOS使用过程中，会使用各种各样的事件。其可以分为三大类：</p><ol><li><p>触摸事件</p></li><li><p>加速计事件</p></li><li><p>远程控制事件</p></li></ol><p>在本篇文章中我们就这三大类事件做一个简单的介绍记录。</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><h4 id="1-响应者对象"><a href="#1-响应者对象" class="headerlink" title="1. 响应者对象"></a>1. 响应者对象</h4><p>在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件，我们称之为<code>响应者对象</code>。常见的有<code>UIApplication</code>、<code>UIViewController</code>、<code>UIView</code>。</p><p>UIResponder之所以能够处理事件是因为其内部提供以下方法：</p><ul><li><p>触摸事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;<br>- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;<br>- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;<br>- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;<br></code></pre></td></tr></table></figure></li><li><p>加速计事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)motionBegan:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event;<br>- (void)motionEnded:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event; <br>- (void)motionCancelled:(UIEventSubtype)motion withEvent:(nullable UIEvent *)event;<br></code></pre></td></tr></table></figure></li><li><p>远程控制事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)remoteControlReceivedWithEvent:(nullable UIEvent *)event;<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-UITouch"><a href="#2-UITouch" class="headerlink" title="2. UITouch"></a>2. UITouch</h4><p>​    当用户用一根手指触摸屏幕时，系统会创建一个与手指相关联的<code>UITouch</code>对象，一根手指对应一个<code>UITouch</code>对象。</p><p>​    <code>UITouch</code>对象的作用：</p><ul><li>保存跟手指相关的信息，比如触摸的位置、时间、阶段</li><li>当手指移动时，系统会更新同一个<code>UITouch</code>对象，使之能够一直保存该手指所在的触摸位置</li><li>当手指离开屏幕时，系统会销毁相应的<code>UITouch</code>对象</li></ul><h3 id="一、触摸事件"><a href="#一、触摸事件" class="headerlink" title="一、触摸事件"></a>一、触摸事件</h3><p>当发生触摸事件后，整个事件的产生、传递、响应大致流程如下：</p><ol><li>系统会将该事件加入到一个由<code>UIApplication</code>管理的事件队列中</li><li>通常<code>UIApplication</code>会从事件队列中取出事件，交给主窗口（<code>UIWindow</code>）处理</li><li>主窗口会在视图层次结构中找到一个最合适的视图控件来处理触摸事件</li><li>找到的最合适的视图控件将会调用<code>touchs</code>方法对具体事件进行处理</li><li>但如果最合适的视图控件在<code>touchs</code>方法中不对事件进行处理，则事件会沿着响应者链条向上传递</li><li>当传递给上一个响应者，就会调用上一个响应者的<code>touchs</code>方法进行处理，依次类推</li><li>如果事件传递到<code>UIApplication</code>时，事件仍不能被处理的话，事件会被丢弃</li></ol><h4 id="1-事件的传递"><a href="#1-事件的传递" class="headerlink" title="1. 事件的传递"></a>1. 事件的传递</h4><p>上面流程中前四步可以归为事件的传递过程，事件传递是从父控件传递到子控件，我们可以参考下图对其有个更直观的了解。</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202201111145794.png" alt="事件传递流程" style="zoom:50%;margin-left:10px" /><blockquote><p>注意：如果父控件不能接收触摸事件，那么子控件也不接收能触摸事件</p></blockquote><h5 id="1-1-UIView不能接受触摸事件的三种情况"><a href="#1-1-UIView不能接受触摸事件的三种情况" class="headerlink" title="1.1 UIView不能接受触摸事件的三种情况"></a>1.1 UIView不能接受触摸事件的三种情况</h5><ol><li>userInteractionEnabled = NO</li><li>hidden = YES</li><li>alpha = 0 ~ 0.01</li></ol><blockquote><p>注意： UIImageView的userInteractionEnabled默认为NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的</p></blockquote><h5 id="1-2-如何找到最合适的控件来处理事件"><a href="#1-2-如何找到最合适的控件来处理事件" class="headerlink" title="1.2. 如何找到最合适的控件来处理事件"></a>1.2. 如何找到最合适的控件来处理事件</h5><ol><li>判断自己能否接收触摸事件</li><li> 触摸点是否在自己身上</li><li>从后往前遍历子控件，重复前两步操作</li><li>如果没有符合条件的子控件，那么就自己最合适</li></ol><p>代码体现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//作用：寻找最合适的view<br>//调用时机：当一个事件传递给当前view的时候调用<br>- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;//recursively calls -pointInside:withEvent:. point is in the receiver&#x27;s<br> <br>//作用：判断当前点是不是在调用它的view上<br>//调用时机：它是在hitTest方法中调用的<br>- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;//default returns YES if point is in bounds<br></code></pre></td></tr></table></figure><p>hitTest方法的底层实现： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hitTest</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">point</span>: <span class="hljs-type">CGPoint</span>, <span class="hljs-params">with</span> <span class="hljs-params">event</span>: <span class="hljs-type">UIEvent</span>?)</span> -&gt; <span class="hljs-type">UIView</span>? &#123;<br>     <span class="hljs-comment">//1.判断自己能否接收事件</span><br>     <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isUserInteractionEnabled <span class="hljs-operator">==</span> <span class="hljs-literal">false</span> <span class="hljs-operator">||</span> <span class="hljs-keyword">self</span>.isHidden <span class="hljs-operator">==</span> <span class="hljs-literal">true</span> <span class="hljs-operator">||</span> <span class="hljs-keyword">self</span>.alpha <span class="hljs-operator">&lt;=</span> <span class="hljs-number">0.01</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>     &#125;<br>     <span class="hljs-comment">//2.判断当前点是不是在当前view</span><br>     <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span><span class="hljs-keyword">self</span>.point(inside: point, with: event) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>     &#125;<br>     <span class="hljs-comment">//3.从后往前遍历自己的子控件，让子控件重复前两步操作</span><br>     <span class="hljs-keyword">for</span> childV <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.subviews.reversed() &#123;<br>         <span class="hljs-comment">//把当前点转换成子控件坐标系上的点</span><br>         <span class="hljs-keyword">let</span> childP <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.convert(point, to: childV)<br>         <span class="hljs-keyword">let</span> fitView <span class="hljs-operator">=</span> childV.hitTest(childP, with: event)<br>         <span class="hljs-keyword">if</span> fitView <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;<br>             <span class="hljs-keyword">return</span> fitView<br>         &#125;<br>     &#125;<br>     <span class="hljs-comment">//4.没有找到比它自己更合适的view，那么它自己就是最合适的view</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><br> &#125;<br></code></pre></td></tr></table></figure><h4 id="2-事件的响应"><a href="#2-事件的响应" class="headerlink" title="2. 事件的响应"></a>2. 事件的响应</h4><p>5、6、7后三步骤我们可以归为事件的响应，事件是顺着响应链者链条向上传递的，它与事件传递的方向刚好相反。</p><h5 id="2-1-什么是响应者链条"><a href="#2-1-什么是响应者链条" class="headerlink" title="2.1 什么是响应者链条"></a>2.1 什么是响应者链条</h5><p>有多个响应者链接起来的链条</p><h5 id="2-1-如何寻找上一个响应者"><a href="#2-1-如何寻找上一个响应者" class="headerlink" title="2.1 如何寻找上一个响应者"></a>2.1 如何寻找上一个响应者</h5><ol><li>如果当前视图的<code>view</code>是控制器的<code>view</code>，那么上一个响应者就是控制器</li><li>如果当前视图的<code>view</code>不是控制器的<code>view</code>，那么它的父控件就是上一个响应者</li><li>如果当前视图是根视图，则上一个响应者是<code>Window</code></li><li><code>Window</code>的上一个响应者是<code>UIApplication</code></li></ol><h4 id="3-手势的简单使用"><a href="#3-手势的简单使用" class="headerlink" title="3. 手势的简单使用"></a>3. 手势的简单使用</h4><p>下面例子中的父视图是当前控制器的view</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">self</span>.view.addSubview(view)<br></code></pre></td></tr></table></figure><p>在这里直接上代码介绍几种触摸事件：</p><h5 id="3-1-单击"><a href="#3-1-单击" class="headerlink" title="3.1 单击"></a>3.1 单击</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 添加单击手势</span><br><span class="hljs-keyword">let</span> singleTapGesture <span class="hljs-operator">=</span> <span class="hljs-type">UITapGestureRecognizer</span>.<span class="hljs-keyword">init</span>(target: <span class="hljs-keyword">self</span>, action: #selector(onClickSingleTap))<br>view.addGestureRecognizer(singleTapGesture)<br><span class="hljs-comment">//单击手势事件</span><br><span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">onClickSingleTap</span>(<span class="hljs-params">recognizer</span>: <span class="hljs-type">UITapGestureRecognizer</span>)</span>&#123;<br>     <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;单击手势&quot;</span>)<br>  &#125;<br></code></pre></td></tr></table></figure><h5 id="3-2-双击"><a href="#3-2-双击" class="headerlink" title="3.2 双击"></a>3.2 双击</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 添加双击手势</span><br><span class="hljs-keyword">let</span> doubleTapGesture <span class="hljs-operator">=</span> <span class="hljs-type">UITapGestureRecognizer</span>.<span class="hljs-keyword">init</span>(target: <span class="hljs-keyword">self</span>, action: #selector(onClickDoubleTap))<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">numberOfTapsRequired：匹配所需的轻击数</span><br><span class="hljs-comment">numberOfTouchesRequired: 匹配所需的手指数</span><br><span class="hljs-comment">*/</span><br>doubleTapGesture.numberOfTapsRequired <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>view.addGestureRecognizer(doubleTapGesture)<br><br><span class="hljs-keyword">#warning</span> 解决单击手势和双击手势冲突<br><span class="hljs-comment">//创建一个与另一个手势识别器的关系。当第一次点击的时候，单击手势的事件暂时不处理，只有确定不是双击手势的时候，才去响应单击手势的事件</span><br>singleTapGesture.require(toFail: doubleTapGesture)<br><br><span class="hljs-comment">//双击手势的事件</span><br><span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">onClickDoubleTap</span>(<span class="hljs-params">recognizer</span>: <span class="hljs-type">UITapGestureRecognizer</span>)</span>&#123;<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;双击手势&quot;</span>)<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-平移"><a href="#3-3-平移" class="headerlink" title="3.3 平移"></a>3.3 平移</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> panGesture <span class="hljs-operator">=</span> <span class="hljs-type">UIPanGestureRecognizer</span>.<span class="hljs-keyword">init</span>(target: <span class="hljs-keyword">self</span>, action: #selector(onClickPan)<br>view.addGestureRecognizer(panGesture)<br>                                             <br><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> onClickPan(recognizer: <span class="hljs-type">UIPanGestureRecognizer</span>)&#123;<br>      <span class="hljs-comment">// 获取偏移量(相对最原始的位置)</span><br>      <span class="hljs-keyword">let</span> translation <span class="hljs-operator">=</span> recognizer.translation(in: <span class="hljs-keyword">self</span>.view)<br>      <span class="hljs-keyword">if</span>  <span class="hljs-keyword">let</span> view <span class="hljs-operator">=</span> recognizer.view &#123;<br> view.transform <span class="hljs-operator">=</span> view.transform.translatedBy(x: translation.x, y: translation.y)<br>       &#125;<br>       recognizer.setTranslation(<span class="hljs-type">CGPoint</span>.zero, in: <span class="hljs-keyword">self</span>.view)<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="3-4-长按"><a href="#3-4-长按" class="headerlink" title="3.4 长按"></a>3.4 长按</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> longPressGesture <span class="hljs-operator">=</span> <span class="hljs-type">UILongPressGestureRecognizer</span>.<span class="hljs-keyword">init</span>(target: <span class="hljs-keyword">self</span>, action: #selector(onClickLongPress))<br>view.addGestureRecognizer(longPressGesture)<br><br><span class="hljs-comment">//长按手势事件</span><br><span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">onClickLongPress</span>(<span class="hljs-params">recognizer</span>: <span class="hljs-type">UILongPressGestureRecognizer</span>)</span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;长按手势&quot;</span>)<br>  <span class="hljs-keyword">if</span> recognizer.state <span class="hljs-operator">==</span> .began &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始长按&quot;</span>)<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> recognizer.state <span class="hljs-operator">==</span> .changed &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;长按时移动&quot;</span>)<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> recognizer.state <span class="hljs-operator">==</span> .ended &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;手指离开&quot;</span>)<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h5 id="3-5-捏合"><a href="#3-5-捏合" class="headerlink" title="3.5 捏合"></a>3.5 捏合</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> pinch <span class="hljs-operator">=</span> <span class="hljs-type">UIPinchGestureRecognizer</span>.<span class="hljs-keyword">init</span>(target: <span class="hljs-keyword">self</span>, action: #selector(onClickPinch))<br>view.addGestureRecognizer(pinch)<br><br><span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">onClickPinch</span>(<span class="hljs-params">recognizer</span>: <span class="hljs-type">UIPinchGestureRecognizer</span>)</span>&#123;<br>       <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> view <span class="hljs-operator">=</span> recognizer.view &#123;<br>           view.transform <span class="hljs-operator">=</span> view.transform.scaledBy(x: recognizer.scale, y: recognizer.scale)<br>           recognizer.scale <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h5 id="3-6-轻扫"><a href="#3-6-轻扫" class="headerlink" title="3.6 轻扫"></a>3.6 轻扫</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//一个轻扫手势只能对应一个方向</span><br><span class="hljs-keyword">let</span> swipeGesture1 <span class="hljs-operator">=</span> <span class="hljs-type">UISwipeGestureRecognizer</span>.<span class="hljs-keyword">init</span>(target: <span class="hljs-keyword">self</span>, action: #selector(onClickSwipe))<br>swipeGesture1.direction <span class="hljs-operator">=</span> .right<br>view.addGestureRecognizer(swipeGesture1)<br><span class="hljs-keyword">let</span> swipeGesture2 <span class="hljs-operator">=</span> <span class="hljs-type">UISwipeGestureRecognizer</span>.<span class="hljs-keyword">init</span>(target: <span class="hljs-keyword">self</span>, action: #selector(onClickSwipe))<br>swipeGesture2.direction <span class="hljs-operator">=</span> .left<br>view.addGestureRecognizer(swipeGesture2)<br><span class="hljs-keyword">let</span> swipeGesture3 <span class="hljs-operator">=</span> <span class="hljs-type">UISwipeGestureRecognizer</span>.<span class="hljs-keyword">init</span>(target: <span class="hljs-keyword">self</span>, action: #selector(onClickSwipe))<br>swipeGesture3.direction <span class="hljs-operator">=</span> .up<br>view.addGestureRecognizer(swipeGesture3)<br><span class="hljs-keyword">let</span> swipeGesture4 <span class="hljs-operator">=</span> <span class="hljs-type">UISwipeGestureRecognizer</span>.<span class="hljs-keyword">init</span>(target: <span class="hljs-keyword">self</span>, action: #selector(onClickSwipe))<br>swipeGesture4.direction <span class="hljs-operator">=</span> .down<br>view.addGestureRecognizer(swipeGesture4)<br><br><span class="hljs-comment">//轻扫手势事件</span><br><span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">onClickSwipe</span>(<span class="hljs-params">recognizer</span>: <span class="hljs-type">UILongPressGestureRecognizer</span>)</span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;轻扫手势&quot;</span>)<br>   <span class="hljs-keyword">switch</span> recognizer.direction &#123;<br>        <span class="hljs-keyword">case</span> .left:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;向左轻扫&quot;</span>) <br>        <span class="hljs-keyword">case</span> .right:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;向右轻扫&quot;</span>)<br>        <span class="hljs-keyword">case</span> .up:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;向上轻扫&quot;</span>)<br>        <span class="hljs-keyword">case</span> .down:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;向下轻扫&quot;</span>)<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="3-7-旋转"><a href="#3-7-旋转" class="headerlink" title="3.7 旋转"></a>3.7 旋转</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> rotationGesture <span class="hljs-operator">=</span> <span class="hljs-type">UIRotationGestureRecognizer</span>.<span class="hljs-keyword">init</span>(target: <span class="hljs-keyword">self</span>, action: #selector(onClickRotation))<br>view.addGestureRecognizer(rotationGesture)<br><br><span class="hljs-comment">//旋转手势事件</span><br><span class="hljs-keyword">@objc</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">onClickRotation</span>(<span class="hljs-params">recognizer</span>: <span class="hljs-type">UIRotationGestureRecognizer</span>)</span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;旋转手势&quot;</span>)<br>        <span class="hljs-keyword">if</span>  <span class="hljs-keyword">let</span> view <span class="hljs-operator">=</span> recognizer.view &#123;<br>            view.transform <span class="hljs-operator">=</span> view.transform.rotated(by: recognizer.rotation)<br>        &#125;<br>        recognizer.rotation <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="二、加速计事件"><a href="#二、加速计事件" class="headerlink" title="二、加速计事件"></a>二、加速计事件</h3><h3 id="三、远程控制事件"><a href="#三、远程控制事件" class="headerlink" title="三、远程控制事件"></a>三、远程控制事件</h3><p>未完待续……</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li>小码哥视频UI进阶0121</li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift_Transform</title>
    <link href="/2022/01/07/Swift/Swift-Transform/"/>
    <url>/2022/01/07/Swift/Swift-Transform/</url>
    
    <content type="html"><![CDATA[<h3 id="一、相对于最原始的位置形变"><a href="#一、相对于最原始的位置形变" class="headerlink" title="一、相对于最原始的位置形变"></a>一、相对于最原始的位置形变</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 向下平移</span><br>view.transform <span class="hljs-operator">=</span> <span class="hljs-type">CGAffineTransform</span>.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: <span class="hljs-number">100</span>)<br><span class="hljs-comment">// 旋转</span><br>view.transform <span class="hljs-operator">=</span> <span class="hljs-type">CGAffineTransform</span>.<span class="hljs-keyword">init</span>(rotationAngle: <span class="hljs-number">45</span>)<br><span class="hljs-comment">// 缩放</span><br>view.transform <span class="hljs-operator">=</span> <span class="hljs-type">CGAffineTransform</span>.<span class="hljs-keyword">init</span>(scaleX: <span class="hljs-number">1.2</span>, y: <span class="hljs-number">1.2</span>)<br></code></pre></td></tr></table></figure><h3 id="二、相对于上一次形变"><a href="#二、相对于上一次形变" class="headerlink" title="二、相对于上一次形变"></a>二、相对于上一次形变</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 向右平移</span><br>view.transform <span class="hljs-operator">=</span> view.transform.translatedBy(x: <span class="hljs-number">100</span>, y: <span class="hljs-number">0</span>)<br><span class="hljs-comment">// 旋转</span><br>view.transform <span class="hljs-operator">=</span> view.transform.rotated(by: <span class="hljs-number">45</span>)<br><span class="hljs-comment">// 缩放</span><br>view.transform <span class="hljs-operator">=</span> view.transform.scaledBy(x: <span class="hljs-number">0.8</span>, y: <span class="hljs-number">0.8</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift_结构体和类</title>
    <link href="/2021/12/21/Swift/Swift_%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/"/>
    <url>/2021/12/21/Swift/Swift_%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本章节记录小码哥视频讲解，方便温故而知新。</p><h3 id="一、结构体"><a href="#一、结构体" class="headerlink" title="一、结构体"></a>一、结构体</h3><p>结构体和类是一种通用又灵活的结构，成为了人们构建代码的基础。你可以使用定义常量、变量和函数的语法，为你的结构体和类定义属性、添加方法。</p><p>在Swift标准库中，绝大多数的公开类型都是结构体，而枚举和类只占很小一部分</p><p>比如<code>Bool</code>、<code>Int</code>、<code>Double</code>、<code>String</code>、<code>Array</code>、<code>Dictionary</code>等常见类型都是结构体</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Date</span> </span>&#123;<br><span class="hljs-keyword">var</span> year: <span class="hljs-type">Int</span><br><span class="hljs-keyword">var</span> month: <span class="hljs-type">Int</span><br><span class="hljs-keyword">var</span> day: <span class="hljs-type">Int</span><br>&#125;<br><span class="hljs-keyword">var</span> date <span class="hljs-operator">=</span> <span class="hljs-type">Date</span>(year:<span class="hljs-number">2021</span>, month: <span class="hljs-number">12</span>, day: <span class="hljs-number">21</span>)<br></code></pre></td></tr></table></figure><p>所有的结构体都有一个编译器自动生成的初始化器（initializer、初始化方法、构造器、构造方法）</p><p>在第6行调用，可以传入所有成员值，用以初始化所有成员（存储属性，Stored Property）</p><h4 id="1-结构体的初始化器"><a href="#1-结构体的初始化器" class="headerlink" title="1. 结构体的初始化器"></a>1. 结构体的初始化器</h4><p>编译器会根据情况，可能会为结构体生成多个初始化器，宗旨是：<strong>保证所有成员都有初始值</strong></p><p>只有第一行生成的初始化器是对的</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112211059534.png" alt="初始化器" style="zoom: 40%;margin-left:10px" /><p>第五行和第七行生成的初始化器都是对的</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112211102717.png" alt="多个初始化器" style="zoom:40%;margin-left:10px" /><h4 id="2-自定义初始化器"><a href="#2-自定义初始化器" class="headerlink" title="2. 自定义初始化器"></a>2. 自定义初始化器</h4><p>一旦定义结构体时自定义了初始化器，编译器就不会再帮它自动生成初始化器，所以可以看到，即使成员都有初始化值，后面方法也是会报错的。</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112211117024.png" alt="自定义初始化器" style="zoom: 40%; margin-left: 10px;" /><h3 id="二、类"><a href="#二、类" class="headerlink" title="二、类"></a>二、类</h3><p>类的定义和结构体类似，但编译器并没有为类自动生成可以传入成员值的初始化器 。</p><p>如下图，如果类的所有成员都在定义的时候指定了初始值，编译器会为类生成无参的初始化器。</p><blockquote><p>成员的初始化是在这个初始化器中完成的</p></blockquote><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112211145960.png" alt="类" style="zoom:40%;margin-left:10px" /><p>如下图，如果类的成员没有都指定初始化值，无参的初始化器编译器也不会生成。</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112211151314.png" alt="类" style="zoom:40%;margin-left:10px" /><h3 id="三、结构体和类的区别"><a href="#三、结构体和类的区别" class="headerlink" title="三、结构体和类的区别"></a>三、结构体和类的区别</h3><p>结构体是值类型（枚举也是值类型），类是引用类型（指针类型）</p><p>值类型在函数里面调用的内存空间在栈里面 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> width <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">var</span> height <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-number">3</span> <br>  <span class="hljs-keyword">var</span> y <span class="hljs-operator">=</span> <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span>()</span>&#123;<br>  <span class="hljs-keyword">var</span> size <span class="hljs-operator">=</span> <span class="hljs-type">Size</span>()<span class="hljs-comment">// size是指针变量，指针变量的内存地址是在栈空间</span><br>  <span class="hljs-keyword">var</span> point <span class="hljs-operator">=</span> <span class="hljs-type">Point</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>栈空间</strong></p><table><thead><tr><th>内存地址</th><th>内存数据</th><th>说明</th></tr></thead><tbody><tr><td>0x10000</td><td>3</td><td>point.x</td></tr><tr><td>0x10008</td><td>4</td><td>point.y</td></tr><tr><td>0x10010</td><td>0x90000</td><td>Size对象的内存地址</td></tr></tbody></table><p><strong>堆空间</strong></p><table><thead><tr><th>内存地址</th><th>内存数据</th><th align="center"></th><th>说明</th></tr></thead><tbody><tr><td>09x0000</td><td>0xe41e8</td><td align="center"></td><td>指向类型信息</td></tr><tr><td>09x0008</td><td>0x20002</td><td align="center">Size对象</td><td>引用计数</td></tr><tr><td>09x0010</td><td>1</td><td align="center"></td><td>size.width</td></tr><tr><td>09x0018</td><td>2</td><td align="center"></td><td>size.height</td></tr></tbody></table><blockquote><p>以上是针对的64位环境</p></blockquote><blockquote><p>可以根据是否调用<strong>alloc、malloc</strong>函数判断是否是在堆空间</p></blockquote><h3 id="四、值类型"><a href="#四、值类型" class="headerlink" title="四、值类型"></a>四、值类型</h3><ul><li><p>值类型是这样一种类型，当它被赋值给一个变量(var)、常量(let)或者被传递给一个函数的时候，是直接将所有内容拷贝一份，属于深拷贝。</p></li><li><p>在Swift标准库中（自己定义的没有），为了提升性能，<code>String</code>、<code>Array</code>、<code>Dictionary</code>、<code>Set</code>等采用了Copy on Write技术。拷贝的时候，新集合不会立即拷贝，而是跟原集合共享一份内存，共享同样的元素。只有当有”写“等修改操作的时候，才会真正执行拷贝操作。 </p></li></ul><h3 id="五、引用类型"><a href="#五、引用类型" class="headerlink" title="五、引用类型"></a>五、引用类型</h3><p> 与值类型不同，<em>引用类型</em>在被赋予到一个变量（var）、常量(let)或者被传递到一个函数时，其值不会被拷贝，而是将内存地址拷贝一份，属于浅拷贝。 </p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://www.swift51.com/swift5.1/02_language_guide/09_Structures_And_Classes.html">Swift5.1教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>Swift学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS微信登录接入</title>
    <link href="/2021/12/17/iOS/iOS%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E6%8E%A5%E5%85%A5/"/>
    <url>/2021/12/17/iOS/iOS%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95%E6%8E%A5%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录下微信登录接入流程，加深一下印象，也方便有需要的同学借鉴。</p><h3 id="一、创建移动应用，配置Universal-Links，生成AppID和AppSecret"><a href="#一、创建移动应用，配置Universal-Links，生成AppID和AppSecret" class="headerlink" title="一、创建移动应用，配置Universal Links，生成AppID和AppSecret"></a>一、创建移动应用，配置<strong>Universal Links</strong>，生成<strong>AppID</strong>和<strong>AppSecret</strong></h3><p>接入微信登录之前，我们需要到 <a href="https://open.weixin.qq.com/cgi-bin/applist?t=manage/list&page=0&num=20&openapptype=1&lang=zh_CN&token=9244e6c7962f9dd4639de8a47754096f87defeeb">微信开放平台</a> 的管理中心创建移动应用，来获取我们之后会用到的<strong>AppID</strong>，以及给后台使用，用于获取<strong>Token</strong>的<strong>AppSecret</strong>。</p><p>创建移动应用流程如下：</p><ul><li><p>根据自身情况填写基本信息</p></li><li><p>填写我们应用相关信息，配置<strong>Universal Links</strong>（这里是以iOS应用为例的），如果不知道怎么配置可以后面补充配置</p><blockquote><p>Universal Links是苹果自iOS9.0推出的用于应用之间跳转的一种安全认证机制，支持通过传统HTTPS链接来启动APP</p></blockquote></li><li><p>提交审核，一般一到七个工作日之内过审, 审核成功后会生成<strong>AppID</strong>和<strong>AppSecret</strong></p><blockquote><p>注意：App Secret遗忘不能找回，需要重置</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112201448838.png" alt="创建应用"></p><h3 id="二、-确认微信和我们自己的App的Universal-Links能正常使用"><a href="#二、-确认微信和我们自己的App的Universal-Links能正常使用" class="headerlink" title="二、 确认微信和我们自己的App的Universal Links能正常使用"></a>二、 确认微信和我们自己的App的<strong>Universal Links</strong>能正常使用</h3><h5 id="1-确认微信Universal-Links-正常"><a href="#1-确认微信Universal-Links-正常" class="headerlink" title="1. 确认微信Universal Links 正常"></a>1. 确认微信<strong>Universal Links</strong> 正常</h5><p>Safari输入</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://help.wechat.com/app/ <br></code></pre></td></tr></table></figure><p>正常情况下会出现如下图</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112201534727.png" alt="打开微信通信正常"></p><h5 id="2-确认App的Universal-Links配置成功"><a href="#2-确认App的Universal-Links配置成功" class="headerlink" title="2. 确认App的Universal Links配置成功"></a>2. 确认App的<strong>Universal Links</strong>配置成功</h5><ul><li><p>开发者官网配置<strong>Associated Domains</strong></p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112201606848.png" alt="打开Domains选项"></p></li><li><p>服务器配置<strong>apple-app-site-association</strong></p><p>在host域名对应的服务器的.well-known目录下面新建一个json文件，命名为<strong>apple-app-site-association</strong>，不需要.json后缀</p><p><strong>apple-app-site-association</strong>格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;applinks&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;apps&quot;</span>: [],<br>        <span class="hljs-attr">&quot;details&quot;</span>: [&#123;<br>            <span class="hljs-attr">&quot;appID&quot;</span>: <span class="hljs-string">&quot;teamID.com.BundleID&quot;</span>,<span class="hljs-comment">//teamID 为开发者账户的teamID </span><br>            <span class="hljs-attr">&quot;paths&quot;</span>: [<span class="hljs-string">&quot;/app/*&quot;</span>] <span class="hljs-comment">// 如果同一host下有多个app,区分同一host下不同app的跳转</span><br>            &#125;]<br>        &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>Xcode 添加<strong>Associated Domains</strong></p><p>打开项目，在Target -&gt;Sigining&amp;Capabilities中点击左上角的**+Capability<strong>，双击添加</strong>Associated Domains**</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112201609801.png" alt="Xcode添加Domains"></p><p>假设我们的host为<code>b.cc.com</code>那么我们<strong>Associated Domains</strong>应该写成如下图applinks:开头的形式</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112201757671.png" alt="AssociatedDomains格式"></p></li></ul><p>输入Safar的Universal Links检测:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">https://b.cc.com/app/<br></code></pre></td></tr></table></figure><h3 id="三、工程设置"><a href="#三、工程设置" class="headerlink" title="三、工程设置"></a>三、工程设置</h3><ol><li><p>添加<strong>Url Scheme</strong></p><p>选中TARGETS一栏，在info标签栏的URL type添加<strong>URL scheme</strong>为你所注册的应用程序 AppId（如下图所示，图片来自<a href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Access_Guide/iOS.html">官网</a>）</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112201713114.png" alt="添加scheme"></p></li><li><p><strong>LSApplicationQueriesSchemes</strong>添加<strong>weixin</strong> 和<strong>weixinULAPI</strong></p><p>选中TARGETS一栏，在 info标签栏的<strong>LSApplicationQueriesSchemes</strong>添加<strong>weixin</strong> 和<strong>weixinULAPI</strong>（如下图所示，图片来自<a href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Access_Guide/iOS.html">官网</a>）</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112201716436.png" alt="配置QueriesScheme"></p></li></ol><h3 id="三、集成SDK"><a href="#三、集成SDK" class="headerlink" title="三、集成SDK"></a>三、集成SDK</h3><p>这里我采用的是通过Cocaopods集成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pod &#x27;WechatOpenSDK&#x27;<br></code></pre></td></tr></table></figure><h3 id="四、授权原理介绍"><a href="#四、授权原理介绍" class="headerlink" title="四、授权原理介绍"></a>四、授权原理介绍</h3><ol><li><p>第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；</p></li><li><p>通过code参数加上AppID和AppSecret等，通过API换取access_token；</p></li><li><p>通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。</p></li></ol><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112201720821.png" alt="授权流程"></p><h3 id="五、集成微信登录代码"><a href="#五、集成微信登录代码" class="headerlink" title="五、集成微信登录代码"></a>五、集成微信登录代码</h3><p>在需要用到微信登录API的地方 import WXApi.h 头文件，需要用到代理协议的地方并增加 WXApiDelegate 协议。如下图:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;UIKit/UIKit.h&gt;<br>#import &quot;WXApi.h&quot;<br><br>@interface AppDelegate : UIResponder&lt;UIApplicationDelegate, WXApiDelegate&gt;<br><br>@property (strong, nonatomic) UIWindow *window;<br><br>@end<br><br><br></code></pre></td></tr></table></figure><p>项目中微信登录需要添加的代码：</p><ol><li><p>在app微信登录点击事件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">if ([WXApi isWXAppInstalled]) &#123;<br>        SendAuthReq *req = [[SendAuthReq alloc] init];<br>        //用于保持请求和回调的状态，授权请求或原样带回<br>        req.state = @&quot;wx_auth_state&quot;;<br>        //授权作用域：获取用户个人信息<br>        req.scope = @&quot;snsapi_userinfo&quot;;<br>        //唤起微信<br>        [WXApi sendReq:req completion:^(BOOL success) &#123;<br>            if (success) &#123;<br>                NSLog(@&quot;唤醒微信成功&quot;);<br>            &#125;<br>        &#125;];<br>    &#125;else&#123;<br>        // 提醒用户安装微信<br>  NSLog(@&quot;未安装微信应用或版本过低&quot;);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>AppDelegate中</p><ul><li><p>在 AppDelegate 的 didFinishLaunchingWithOptions 函数中向微信注册 id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;<br>    //向微信注册<br>    [WXApi registerApp:APP_ID universalLink:UNIVERSAL_LINK];<br>    return YES;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>重写 AppDelegate 的 handleOpenURL 和 openURL 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// iOS 9之前<br>- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url &#123;<br>    return  [WXApi handleOpenURL:url delegate:self];<br>&#125;<br><br>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation &#123;<br>    return [WXApi handleOpenURL:url delegate:self];<br>&#125;<br>// iOS 9之后<br>- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString*, id&gt; *)options<br>&#123;<br>  if [url.host isEqualToString:@&quot;oauth&quot;])&#123;<br>        return [WXApi handleOpenURL:url delegate:self];<br>    &#125;<br>return YES;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>重写AppDelegate或SceneDelegate的continueUserActivity方法：(注意：适配了SceneDelegate的App，系统将会回调SceneDelegate的continueUserActivity方法，所以需要重写SceneDelegate的该方法。)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//AppDelegate:<br>- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void(^)(NSArray&lt;id&lt;UIUserActivityRest<br>oring&gt;&gt; * __nullable restorableObjects))restorationHandler &#123;<br>    return [WXApi handleOpenUniversalLink:userActivity delegate:self];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">//SceneDelegate:<br>- (void)scene:(UIScene *)scene continueUserActivity:(NSUserActivity *)userActivity &#123;<br>    [WXApi handleOpenUniversalLink:userActivity delegate:self];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现 WXApiDelegate 协议的两个方法，接受微信登录回调结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 是微信终端向第三方程序发起请求，要求第三方程序响应。第三方程序响应完后必须调用 sendRsp 返回。在调用 sendRsp 返回时，会切回到微信终端程序界面。<br>-(void) onReq:(BaseReq*)reqonReq&#123;<br><br>&#125;<br>// 如果第三方程序向微信发送了 sendReq 的请求，那么 onResp 会被回调。sendReq 请求调用后，会切到微信终端程序界面。<br>-(void) onResp:(BaseResp*)resp&#123;<br>if ([resp isMemberOfClass:[SendAuthResp class]]) &#123;<br>        SendAuthResp *aresp = (SendAuthResp *)resp;<br>    if (aresp.errCode != 0 ) &#123;<br>        dispatch_async(dispatch_get_main_queue(), ^&#123;<br>NSLog(@&quot;微信授权失败&quot;);<br>       &#125;);<br>         return;<br>    &#125;<br>    //授权成功获取获取code<br>    NSString *code = aresp.code;<br>     //发送通知 在需要code的界面接收通知<br>   [[NSNotificationCenter defaultCenter]postNotificationName:@&quot;WXCODE&quot; object:nil userInfo:@&#123;@&quot;code&quot;:code&#125;];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>根据上面步骤拿到code后，将code传递给后台，让后台根据微信API去获取用户相关信息等就好。</p></li></ul></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Access_Guide/iOS.html">iOS 接入指南</a></p><p><a href="https://www.jianshu.com/p/1910ea1fe8f6">iOS配置Universal Links</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Third</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Actions将Hexo自动化部署到gh-page</title>
    <link href="/2021/12/16/Hexo/%E4%BD%BF%E7%94%A8Actios%E5%B0%86Hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%88%B0gh-page/"/>
    <url>/2021/12/16/Hexo/%E4%BD%BF%E7%94%A8Actios%E5%B0%86Hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%88%B0gh-page/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前根据Hexo官网提示，使用的Travis实现的自动化部署，当时感觉很Nice，但是好景不长，最近部署的时候突然发现当代码提交后，Travis并没有部署成功。进去看了之后，Travis已经不再免费了。本来想着稍微付点钱继续使用，毕竟人家也不容易。但是看到收费标准的时候，成功把我劝退了。于是就找到了Actions替代Travis实现自动化部署。这里简单记录下Actions的使用过程。</p><blockquote><p>本文主要摘自参考文章第一篇，大神写的很完美。</p></blockquote><h3 id="一、创建GitHub仓库"><a href="#一、创建GitHub仓库" class="headerlink" title="一、创建GitHub仓库"></a>一、创建GitHub仓库</h3><p>创建两个GitHub仓库：</p><ol><li><p>私有仓库，用于存储hexo项目源代码（当然你想公开也是没问题的）</p></li><li><p>公有仓库，用于存储hexo build 后的静态文件，配置gh-page site。</p><blockquote><p>公有仓库名命名为&lt;你的GitHub名称&gt;.github.io</p></blockquote></li></ol><h3 id="二、创建Personal-access-tokens"><a href="#二、创建Personal-access-tokens" class="headerlink" title="二、创建Personal access tokens"></a>二、创建Personal access tokens</h3><p>创建一个有<code>repo</code>和<code>workflow</code>权限的<a href="https://github.com/settings/tokens/new">token</a>，注意token只有在刚生成时会显示，如遗失需重新生成。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112161809331.png" alt="创建token"></p><h3 id="三、创建repository-secret"><a href="#三、创建repository-secret" class="headerlink" title="三、创建repository secret"></a>三、创建repository secret</h3><p>进入私有仓库，使用上面生成的<code>token</code>，按照下图步骤生成<code>Secrets</code>。记下Action Secrets的名字，在后面配置<code>Action</code>中会用到。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112161830446.png" alt="创建Secrets"></p><h3 id="四、添加Actions配置文件"><a href="#四、添加Actions配置文件" class="headerlink" title="四、添加Actions配置文件"></a>四、添加Actions配置文件</h3><ol><li><p>在你的 Hexo 项目根目录下创建 <code>.github</code> 文件夹。</p></li><li><p>在 <code>.github</code> 文件夹下创建 <code>workflows</code> 文件夹。</p></li><li><p>在 <code>workflows</code> 文件夹下创建 <code>hexo-deploy.yml</code> 文件。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112162220323.png" alt="创建yml文件"></p><p>hexo-deploy.yml文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">name: deploying Hexo project to GitHub pages<br>on:<br>  push:<br>    branches:<br>      - master <span class="hljs-comment"># master 分支有 push 行为时就触发这个 action</span><br><br><span class="hljs-built_in">jobs</span>:<br>  build-and-deploy:<br>    runs-on: ubuntu-latest<br>    steps:<br>      - name: Checkout<br>        uses: actions/checkout@master<br><br>      - name: Build and Deploy<br>        uses: theme-keep/hexo-deploy-github-pages-action@master <span class="hljs-comment"># 使用专门部署 Hexo 到 GitHub pages 的 action</span><br>        env:<br>          PERSONAL_TOKEN: <span class="hljs-variable">$&#123;&#123; secrets.HEXO_DEPLOY &#125;</span>&#125; <span class="hljs-comment"># secret 名</span><br>          PUBLISH_REPOSITORY: GHTYQ/GHTYQ.github.io <span class="hljs-comment"># 公共仓库，格式：GitHub 用户名/仓库名</span><br>          BRANCH: gh-pages <span class="hljs-comment"># 分支，填 gh-pages 就行</span><br>          PUBLISH_DIR: ./public <span class="hljs-comment"># 部署 public 目录下的文件</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="五、自动化部署流程"><a href="#五、自动化部署流程" class="headerlink" title="五、自动化部署流程"></a>五、自动化部署流程</h3><ol><li><p>修改你的 Hexo 博客源代码（例如：增加文章、修改文章、更改主题、修改主题配置文件等等）。</p></li><li><p>把你修改过的 Hexo 项目内容 <code>push</code> 到 GitHub 私有仓库的 <code>master</code> 分支。</p></li><li><p>GitHub Actions 检测到 <code>master</code> 分支有内容 <code>push</code> 进来，会自动执行 action 配置文件的命令，将 Hexo 项目编译成静态页面，然后部署到公有仓库的 <code>gh-pages</code> 分支。</p><blockquote><p><code>gh-pages</code> 分支是 GitHub Pages 服务的固定分支，你只需在 <code>hexo-deploy.yml</code> 文件正确填写，会自动创建。</p></blockquote></li><li><p>在私有仓库的 Actions 可以查看到你配置的 action。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112162216689.png" alt="截屏2021-12-16 下午10.16.46"></p></li><li><p>通过 GitHub Actions 自动部署成功的效果图：</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112162222906.png" alt="截屏2021-12-16 下午10.22.17"></p></li></ol><h3 id="六、出现的问题"><a href="#六、出现的问题" class="headerlink" title="六、出现的问题"></a>六、出现的问题</h3><p>因为我使用的是<code>Custom domain</code>形式，出现了当每次push部署成功后<code>Custom domain</code>被重置空，导致用自己设置的域名无法访问。重新设置<code>Custom domain</code>好后就可以继续访问，但下次push部署成功后又会被置空。后经对比gh-page分支内文件发现，每次部署成功后<code>CNAME</code>文件就会消失,设置好<code>Custom domain</code>后<code>CNAME</code>就会出现。</p><p>解决方法：</p><p>在如下图所示source目录下创建<code>CNAME</code>文件，文件中写入自己的域名即可。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112162233029.jpg" alt="1639665205281"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://keep.xpoet.cn/2021/03/%E4%BD%BF%E7%94%A8-GitHub-Action-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-Hexo-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/">使用 GitHub Actions 自动部署 Hexo 静态博客</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xcode New build System导致的一系列问题解决</title>
    <link href="/2021/12/15/iOS/Xcode%20New%20build%20System%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <url>/2021/12/15/iOS/Xcode%20New%20build%20System%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近将xcode升级到13.1，感觉界面变化还是挺大的。还是比较喜欢这次升级后带来的体验的。但是我们也会知道，每次升级，或多或少都会带来一些问题。这里就记录下这次升级带来的几个问题吧。</p><h3 id="一、The-Legacy-Build-System-will-be-removed-in-a-future-release-You-can-configure-the-selected-build-system-and-this-deprecation-message-in-File-gt-Workspace-Settings"><a href="#一、The-Legacy-Build-System-will-be-removed-in-a-future-release-You-can-configure-the-selected-build-system-and-this-deprecation-message-in-File-gt-Workspace-Settings" class="headerlink" title="一、The Legacy Build System will be removed in a future release. You can configure the selected build system and this deprecation message in File &gt; Workspace Settings."></a>一、The Legacy Build System will be removed in a future release. You can configure the selected build system and this deprecation message in File &gt; Workspace Settings.</h3><p>这段文字将问题说的很明白* Legacy Build System*这种方式已经被遗弃（其实这个方式很早已经被遗弃了，只是之前不会报错）。这里我们只需在Xcode -&gt; file -&gt; workspace setting，找到如下图选项，将它选择为new buil system 即可。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112161500742.png" alt="New Buil system"></p><p>这里简单介绍下New Build System，它是在Xcode9发布的时候推出的，在Xcode10中，苹果将其设置为默认的构建系统。其目的是降低构建开销，尤其是降低大型项目的构建开销。具体可以看最下面第一章参考文章。</p><h3 id="二、Multiple-commands-produce"><a href="#二、Multiple-commands-produce" class="headerlink" title="二、Multiple commands produce"></a>二、Multiple commands produce</h3><p>Multiple commands produce ‘/Users/mac/Library/Developer/Xcode/DerivedData/xxxx-heiprmtxogfzwaekotgiyuncjoip/Build/Products/Debug-iphoneos/xxxx.app/Assets.car’:</p><ol><li>Target ‘xxxx’ (project ‘xxxx’) has compile command with input ‘/Users/mac/Documents/xxxx/xxxx/xxxx/Assets.xcassets’</li><li>That command depends on command in Target ‘xxxx’ (project ‘xxxx’): script phase “[CP] Copy Pods Resources”</li></ol><p>这是因为主工程里 Assets.xcassets 和 Pods 里有同名的 Assets.xcassets，在 Xcode 10 之前进行编译是不会有问题的，Xcode 只是生成 Warning，但是在 Xcode 10 之后使用了 New Build System 会生成 Errror，提示重复生成 Assets.car。</p><ul><li><p>解决方法1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">install! <span class="hljs-string">&#x27;cocoapods&#x27;</span>, :disable_input_output_paths =&gt; <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>这个方法会跳过优化，每次都从Pods下载资源，虽然解决了我们的问题，但是这样会导致构建时间增长，不是最佳的选择。</p></li><li><p>解决方法2：</p><p>在<code>target</code>-&gt;<code>Build Phases</code>下<code>[CP] Copy Pods Resource</code>的 <code>output files</code>下找到下面这段信息，将其删除即可解决上面报错问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;TARGET_BUILD_DIR&#125;</span>/<span class="hljs-variable">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>/Assets.car<br></code></pre></td></tr></table></figure><p>但这同时会带出一个新的问题：<code>当我们对项目进项pod install 或者 pod update 操作的时候，这段信息就会重新出现</code>。</p><p>针对这个问题，我们选择通过post_install hook来实现自动删除解决。(目前还有点问题)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">post_install <span class="hljs-keyword">do</span> |installer|<br>    project_path = <span class="hljs-string">&#x27;MHCB2BApp.xcodeproj&#x27;</span><br>    project = Xcodeproj::Project.open(project_path)<br>    project.targets.each <span class="hljs-keyword">do</span> |target|<br>      <span class="hljs-comment">#log target-&gt;build phases下名称</span><br>      puts target.build_phases<br>      build_phase = target.build_phases.find &#123; |bp| bp.display_name == <span class="hljs-string">&#x27;[CP] Copy Pods Resources&#x27;</span> &#125;<br>      assets_path = <span class="hljs-string">&#x27;$&#123;TARGET_BUILD_DIR&#125;/$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;/Assets.car&#x27;</span><br>      <span class="hljs-keyword">if</span> build_phase.present? &amp;&amp; build_phase.output_paths.include?(assets_path) == <span class="hljs-literal">true</span><br>         build_phase.output_paths.delete(assets_path)<br>         <span class="hljs-comment">#log output_paths查看是否真的删除成功</span><br>         puts build_phase.output_paths<br>      end<br>    end<br>  project.save(project_path)<br></code></pre></td></tr></table></figure></li><li><p>解决方法3：</p><p>这个问题的根本原因是因为在<code>podspec</code>中使用<code>s.resources = [“ your resource.xcassets”]</code>这种资源引用的方式导致的，这将会把一个 <code>assets</code> 添加到输出文件中，与 <code>Copy Bundle Resources</code> 中的<code>assets</code> 相冲突。我们可以使用CocoaPods官方推荐的<code>resource_bundles</code>这种方式引用资源来从根本上解决问题。</p><p><code>Example:</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">spec.ios.resource_bundle = &#123; <span class="hljs-string">&#x27;MapBox&#x27;</span> =&gt; <span class="hljs-string">&#x27;MapView/Map/Resources/*.png&#x27;</span> &#125;<br>spec.resource_bundles = &#123;<br>    <span class="hljs-string">&#x27;MapBox&#x27;</span> =&gt; [<span class="hljs-string">&#x27;MapView/Map/Resources/*.png&#x27;</span>],<br>    <span class="hljs-string">&#x27;MapBoxOtherResources&#x27;</span> =&gt; [<span class="hljs-string">&#x27;MapView/Map/OtherResources/*.png&#x27;</span>]<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>最后一个方法因为项目中pod太多等种种原因，没有亲自实践，只是从别的文章中了解到的，说是可以从根本上上解决的。</p></blockquote></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/TuGeLe/article/details/84885211">探究Xcode New Build System对于构建速度的提升</a></li><li><a href="https://chaosky.tech/2020/04/20/optimize-xcode-build-time/">记录一次优化 Xcode 编译的过程</a></li><li><a href="https://github.com/CocoaPods/CocoaPods/issues/8122">Xcode 10 new build system makes asset catalog invalid specified by podspec’s resource(s)</a></li><li><a href="https://dev.to/kylefoo/xcode-12-new-build-system-warns-multiple-commands-produce-assets-car-56im">Xcode 12 New Build System warns multiple commands produce Assets.car</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Question</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS推送证书过期处理</title>
    <link href="/2021/12/10/iOS/iOS%E6%8E%A8%E9%80%81%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <url>/2021/12/10/iOS/iOS%E6%8E%A8%E9%80%81%E8%AF%81%E4%B9%A6%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-推送证书过期处理"><a href="#iOS-推送证书过期处理" class="headerlink" title="iOS 推送证书过期处理"></a>iOS 推送证书过期处理</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>关于推送证书过期的处理，因为我们项目中用到的是三方推送（极光推送），这里就以极光推送为例，记录下收到苹果推送证书即将过期的邮件提醒后，怎么去重新设置证书。</p><p>这里先确认一点，就是更换证书并不会影响你线上app的正常使用。</p><h3 id="一、确定过期时间"><a href="#一、确定过期时间" class="headerlink" title="一、确定过期时间"></a>一、确定过期时间</h3><ol><li>钥匙串-&gt;我的证书中找到相应的推送证书，查看证书的有效期。</li><li>极光平台推送证书集成设置中，查看证书有效期。</li></ol><h3 id="二、重新配置推送证书"><a href="#二、重新配置推送证书" class="headerlink" title="二、重新配置推送证书"></a>二、重新配置推送证书</h3><ol><li><p>重新编辑推送证书</p><ul><li>打开<a href="https://idmsa.apple.com/IDMSWebAuth/signin?appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&path=/account/&rv=1">Developer</a>，点击Identifiers，点击搜索找到你对应项目的bundleID</li></ul><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112101542079.jpg" alt="Identifiers"></p><ul><li>点击你需要配置的bundleID，进入下图，找到push Notifications，点击编辑</li></ul><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112101541638.jpg" alt="编辑推送相关内容"></p><ul><li><p>点击<em>Create Certificate</em>，创建生产证书（因为可以选择，生产证书用于测试，我们就不创建开发证书了）</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112101547956.jpg" alt="创建生产证书"></p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112101549370.jpg" alt="证书的创建"></p></li></ul></li><li><p>生成并上传CSR文件</p><ul><li>生成CSR文件，打开钥匙串，点击如下图，选择从证书颁发机构请求证书，然后将证书存储到磁盘桌面备用。</li></ul><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112101550236.jpg" alt="生成CSR文件"></p><ul><li><p>上传CSR文件，证书创建完成</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112101553342.jpg" alt="上传CSR文件完成证书的创建"></p></li></ul></li><li><p>下载证书到钥匙串，并以p12的形式导出</p><p>点击<em>Download</em>下载证书后，双击安装证书到钥匙串，在钥匙串中找到新安装的证书，右键选择导出，导出类型选择p12的形式。</p></li><li><p>替换掉极光推送配置的证书</p><p>进入极光推送集成配置中心，选择上传我们新导出的推送证书的p12文件，完成极光平台的证书更新。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202112101555909.jpg" alt="替换即将过期的证书"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Developer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS各机型比较</title>
    <link href="/2021/12/10/iOS/iOS%E5%90%84%E6%9C%BA%E5%9E%8B%E6%AF%94%E8%BE%83/"/>
    <url>/2021/12/10/iOS/iOS%E5%90%84%E6%9C%BA%E5%9E%8B%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h3 id="常用机型比较"><a href="#常用机型比较" class="headerlink" title="常用机型比较"></a>常用机型比较</h3><table><thead><tr><th>机型</th><th>尺寸</th><th>逻辑分辨率(point)</th><th>倍数</th><th>状态栏高度</th><th>导航栏高度</th><th>底部安全距离</th><th>tabbar高度</th></tr></thead><tbody><tr><td>iPhone 8</td><td>4.7英寸</td><td>375*667</td><td>@2x</td><td>20</td><td>44</td><td>-</td><td>49</td></tr><tr><td>iPhone 8p</td><td>5.5英寸</td><td>414*736</td><td>@3x</td><td>20</td><td>44</td><td>-</td><td>49</td></tr><tr><td>iPhone X</td><td>5.8英寸</td><td>375*812</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone XS</td><td>5.8英寸</td><td>375*812</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone XS max</td><td>6.5英寸</td><td>414x896</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone XR</td><td>6.1英寸</td><td>414x896</td><td>@2x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone 11</td><td>6.1英寸</td><td>414x896</td><td>@2x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone 11 Pro</td><td>6.1英寸</td><td>375*812</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone 11 Pro Max</td><td>6.5英寸</td><td>414 x 896</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone SE</td><td>4.7英寸</td><td>375*667</td><td>@2x</td><td>20</td><td>44</td><td>-</td><td>83</td></tr><tr><td>iPhone 12</td><td>6.1英寸</td><td>390*844</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone 12 Pro</td><td>6.1英寸</td><td>390*844</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone 11 Pro Max</td><td>6.7英寸</td><td>428*926</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone 12 Mini</td><td>5.4英寸</td><td>375*812</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone 13</td><td>6.1英寸</td><td>390*844</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone 13 Pro</td><td>6.1英寸</td><td>390*844</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone 13 Pro Max</td><td>6.7英寸</td><td>428*926</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr><tr><td>iPhone 13 Mini</td><td>5.4英寸</td><td>360*780</td><td>@3x</td><td>44</td><td>44</td><td>34</td><td>83</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>适配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift_基础部分</title>
    <link href="/2021/11/30/Swift/Swift_%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
    <url>/2021/11/30/Swift/Swift_%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-常量和变量"><a href="#1-常量和变量" class="headerlink" title="1. 常量和变量"></a>1. 常量和变量</h3><p>定义：常量和变量<code>把一个名字和一个指定类型的值关联起来</code>。常量的值一旦设定就不能改变，而变量的值可以随意更改。</p><h6 id="1-1-常量和变量的声明"><a href="#1-1-常量和变量的声明" class="headerlink" title="1.1 常量和变量的声明"></a>1.1 常量和变量的声明</h6><p>用let来声明常量，var声明变量</p><p>可以在一行中声明多个常量或者多个变量，用逗号隔开</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> x <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>, y <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>, z <span class="hljs-operator">=</span> <span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><h6 id="1-2-类型注解"><a href="#1-2-类型注解" class="headerlink" title="1.2 类型注解"></a>1.2 类型注解</h6><p>例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> welcome: <span class="hljs-type">String</span><br></code></pre></td></tr></table></figure><p>“声明一个类型为String，名字为welcome的变量”</p><p>你可以在一行中定义多个同类型的变量，用逗号隔开，并在最后一个变量名称后面添加注解</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> x, y, z: <span class="hljs-type">Double</span><br></code></pre></td></tr></table></figure><h6 id="1-3-常量和变量的命名"><a href="#1-3-常量和变量的命名" class="headerlink" title="1.3 常量和变量的命名"></a>1.3 常量和变量的命名</h6><ul><li><p>常量和变量名可以包含几乎所有的字符，包括 Unicode 字符。</p></li><li><p>常量与变量名不能包含数学符号，箭头，保留的（或者非法的）Unicode 码位，连线与制表符。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。</p></li></ul><h6 id="1-4-输出常量和变量"><a href="#1-4-输出常量和变量" class="headerlink" title="1.4 输出常量和变量"></a>1.4 输出常量和变量</h6><p>可以使用<code>print(_:separator:terminator:）</code>函数来输出当前常量和变量的值，默认以<code>separator:&quot; &quot;</code>分割，以<code>terminator:&quot;\n&quot;</code>结束</p><h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h3><ol><li><p>单行注释（<code>//</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 这是单行注释</span><br></code></pre></td></tr></table></figure></li><li><p>多行注释，开始（<code>/*</code>），结束（*<code>/</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/*这是多行注释</span><br><span class="hljs-comment">多行注释*/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-分号"><a href="#3-分号" class="headerlink" title="3. 分号"></a>3. 分号</h3><p>不强求每条语句结尾处都使用分号（<code>;</code>）,看个人习惯。但是同一行内有多条独立的语句的时候，必须使用分号。</p><h3 id="4-整数"><a href="#4-整数" class="headerlink" title="4.  整数"></a>4.  整数</h3><p>整数可以是<code>有符号</code>（正、负、零）或者<code>无符号</code>（正、零）</p><p>swift提供了8、6、32、64位有符号或者无符号整数类型。</p><p>例：</p><p>​        8位无符号整数类型： <code>UInt8</code></p><p>​        32位有符号整数类型：<code>Int32</code></p><h6 id="4-1-整数范围"><a href="#4-1-整数范围" class="headerlink" title="4.1 整数范围"></a>4.1 整数范围</h6><p>你可以通过min和max属性来获取对应类型的最小值和最大值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> minValue <span class="hljs-operator">=</span> <span class="hljs-type">UInt8</span>.min  <span class="hljs-comment">// minValue 为 0，是 UInt8 类型</span><br><span class="hljs-keyword">let</span> maxValue <span class="hljs-operator">=</span> <span class="hljs-type">UInt8</span>.max  <span class="hljs-comment">// maxValue 为 255，是 UInt8 类型</span><br></code></pre></td></tr></table></figure><h6 id="4-2-Int"><a href="#4-2-Int" class="headerlink" title="4.2 Int"></a>4.2 Int</h6><p>一般来说不需要单独指定整数的长度，Swift提供了一个特殊的整数类型<code>Int</code>,长度与当前平台的原生字长相同</p><ul><li>在32位平台上，<code>Int</code>和<code>Int32</code>长度相同</li><li>在64位平台上，<code>Int</code>和I<code>nt64</code>长度相同</li></ul><h6 id="4-3-UInt"><a href="#4-3-UInt" class="headerlink" title="4.3 UInt"></a>4.3 UInt</h6><p>Swift 也提供了一个特殊的无符号类型<code>UInt</code>,长度与当前平台原生字长相同。</p><h3 id="5-浮点数"><a href="#5-浮点数" class="headerlink" title="5. 浮点数"></a>5. 浮点数</h3><p>浮点数类型比整数类型表示的范围更大，可以存储比<code>Int</code>类型更大或者更小的数字。Swift提供了两种有符号的浮点数类型：</p><ul><li><code>Double</code>表示64位浮点数。当你存储很大或者很高精度的浮点数时使用此类型。</li><li><code>Float</code>标书32位浮点数。精度要求不高的话可以使用此类型。</li></ul><h3 id="6-类型安全和类型推断"><a href="#6-类型安全和类型推断" class="headerlink" title="6. 类型安全和类型推断"></a>6. 类型安全和类型推断</h3><ol><li><p>类型安全</p><p>Swift是类型安全的，它会在编译你的代码时进行类型检查，并把不匹配的类型标记为错误。</p></li><li><p>类型推断</p><p>当你声明常量或者变量的时候赋给它们一个字面量即可触发类型推断。</p><p>例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> pi <span class="hljs-operator">=</span> <span class="hljs-number">3.14159</span><br><span class="hljs-comment">// pi 会被类型推断为Double类型</span><br></code></pre></td></tr></table></figure><p>注意：</p><p>当推断浮点数类型的时候，Swift总会选择Double而不是Float</p></li></ol><h3 id="7-数值型字面量"><a href="#7-数值型字面量" class="headerlink" title="7. 数值型字面量"></a>7. 数值型字面量</h3><ol><li><p>整数字面量</p><p>整数字面量可以被写作：</p><ul><li>一个十进制数，没有前缀</li><li>一个二进制数，前缀是<code>0b</code></li><li>一个八进制数，前缀是<code>0o</code></li><li>一个十六进制数，前缀是<code>0x</code></li></ul></li><li><p>浮点数字面量</p><p>浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是 0x ）。小数点两边必须有至少一个十进制数字（或者是十六进制的数字）。十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 e 来指定；十六进制浮点数必须有一个指数，通过大写或者小写的 p 来指定。</p></li><li><p>额外的格式</p><p>数值类字面量可以包括额外的格式来增强可读性。整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> a <span class="hljs-operator">=</span> <span class="hljs-number">000123.456</span><br><span class="hljs-keyword">let</span> b <span class="hljs-operator">=</span> <span class="hljs-number">1_000_0000</span><br><span class="hljs-keyword">let</span> c <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000.000_000_1</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="8-数值类型转换"><a href="#8-数值类型转换" class="headerlink" title="8. 数值类型转换"></a>8. 数值类型转换</h3><p>要将一种数字类型转换为另一种，你要用当前值来初始化一个期望类型的新数字，这个数字的类型就是你的目标类型。</p><p>当前值转化为期望类型值：<code>期望类型(当前值) = 期望值</code></p><h6 id="8-1-整数转化"><a href="#8-1-整数转化" class="headerlink" title="8.1 整数转化"></a>8.1 整数转化</h6><p>常量 <code>one</code> 是 <code>UInt16</code> 类型，然而常量 <code>two</code> 是 <code>UInt8</code> 类型。它们不能直接相加，因为它们类型不同。所以要调用 <code>UInt16(two)</code> 来创建一个新的 <code>UInt16</code> 数字并用 <code>two</code> 的值来初始化，然后使用这个新数字来计算。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> one: <span class="hljs-type">UInt16</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000</span><br><span class="hljs-keyword">let</span> two: <span class="hljs-type">UInt8</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> sum <span class="hljs-operator">=</span> two <span class="hljs-operator">+</span> <span class="hljs-type">UInt16</span>(two)<br></code></pre></td></tr></table></figure><p>现在两个数字的类型都是 <code>UInt16</code>，可以进行相加。目标常量 <code>sum</code> 的类型被推断为 <code>UInt16</code>，因为它是两个 <code>UInt16</code> 值的和</p><h6 id="8-2-整数和浮点数转换"><a href="#8-2-整数和浮点数转换" class="headerlink" title="8.2 整数和浮点数转换"></a>8.2 整数和浮点数转换</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> one <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> two <span class="hljs-operator">=</span> <span class="hljs-number">0.14159</span><br><span class="hljs-keyword">let</span> sum <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(one) <span class="hljs-operator">+</span> two<br></code></pre></td></tr></table></figure><p>这个例子中，常量 <code>one</code> 的值被用来创建一个 <code>Double</code> 类型的值，所以加号两边的数类型须相同。如果不进行转换，两者无法相加。</p><h3 id="9-类型别名"><a href="#9-类型别名" class="headerlink" title="9. 类型别名"></a>9. 类型别名</h3><p>类型别名：给现有的类型定义另外一个名字。你可以使用<code>typealias</code>关键字来定义类型别名。</p><h3 id="10-布尔值"><a href="#10-布尔值" class="headerlink" title="10. 布尔值"></a>10. 布尔值</h3><p>布尔值（Bool）指逻辑上的值，只能是真或者假，用布尔常量<code>true</code>和<code>false</code>表示。</p><h3 id="11-元祖"><a href="#11-元祖" class="headerlink" title="11. 元祖"></a>11. 元祖</h3><p>元祖（tuples）把多个值组合成一个复合值。元祖内的值可以是任意类型，并不要求是相同类型。</p><p>例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> http404Error <span class="hljs-operator">=</span> (<span class="hljs-number">404</span>,<span class="hljs-string">&quot;Not Found&quot;</span>) <span class="hljs-comment">//http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)</span><br></code></pre></td></tr></table></figure><ol><li><p>将元祖内容分解为单独的常量或者变量</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> (statusCode, statusMessage) <span class="hljs-operator">=</span> http404Errorprint(<span class="hljs-string">&quot;The status code is <span class="hljs-subst">\(statusCode)</span>&quot;</span>)<br><span class="hljs-comment">// 输出“The status code is 404”</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The status message is <span class="hljs-subst">\(statusMessage)</span>&quot;</span>)<br><span class="hljs-comment">// 输出“The status message is Not Found”</span><br></code></pre></td></tr></table></figure></li><li><p>只需要一部分元祖值时，分解的时候可以把要忽略的部分用下划线（_）标记</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> (justTheStatusCode, <span class="hljs-keyword">_</span>) <span class="hljs-operator">=</span> http404Errorprint(<span class="hljs-string">&quot;The status code is <span class="hljs-subst">\(justTheStatusCode)</span>&quot;</span>)<br><span class="hljs-comment">// 输出“The status code is 404”</span><br></code></pre></td></tr></table></figure></li><li><p>通过下标来访问元祖的单个元素，下标从零开始</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The status code is <span class="hljs-subst">\(http404Error.<span class="hljs-number">0</span>)</span>&quot;</span>)<br><span class="hljs-comment">// 输出“The status code is 404”</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The status message is <span class="hljs-subst">\(http404Error.<span class="hljs-number">1</span>)</span>&quot;</span>)<br><span class="hljs-comment">// 输出“The status message is Not Found”</span><br></code></pre></td></tr></table></figure></li><li><p>定义元祖的时候给单个元素命名，通过名字来获取这些元素的值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> http200Status <span class="hljs-operator">=</span> (statusCode: <span class="hljs-number">200</span>, description: <span class="hljs-string">&quot;OK&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The status code is <span class="hljs-subst">\(http200Status.statusCode)</span>&quot;</span>)<br><span class="hljs-comment">// 输出“The status code is 200”</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The status message is <span class="hljs-subst">\(http200Status.description)</span>&quot;</span>)<br><span class="hljs-comment">// 输出“The status message is OK”</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="12-可选类型"><a href="#12-可选类型" class="headerlink" title="12. 可选类型"></a>12. 可选类型</h3><p>使用可选类型（optionals）来处理值可能缺失的情况，可选类型表示两种可能：有值（可通过解析可选类型访问这个值）、无值</p><h6 id="12-1-nil"><a href="#12-1-nil" class="headerlink" title="12.1 nil"></a>12.1 nil</h6><p>你可以给可选变量赋值为<code>nil</code>，来表示它没值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> code: <span class="hljs-type">Int</span>? <span class="hljs-operator">=</span> <span class="hljs-number">404</span> <span class="hljs-comment">// code 包含一个可选的Int值404</span><br>code <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// code 现在不包含值</span><br></code></pre></td></tr></table></figure><p>如果你声明了一个可选类型的常量或者变量但是没有赋值，它们会自动被设置为nil</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> str: <span class="hljs-type">String</span>? <span class="hljs-comment">// str 被自动设置为 nil</span><br></code></pre></td></tr></table></figure><p>注意：</p><p>Swift 的<code>nil</code>和OC中的<code>nil</code>不一样，在OC中，<code>nil</code>是一个指向不存在对象的指针。在Swift中，<code>nil</code>并不是指针–它是一个确定的值，用来表示值缺失。任何类型可选状态都可以设置为nil，不只是对象类型。</p><h6 id="12-2-if语句以及强制解析"><a href="#12-2-if语句以及强制解析" class="headerlink" title="12.2 if语句以及强制解析"></a>12.2 if语句以及强制解析</h6><p>你可以使用<code>if</code>语句和<code>nil</code>比较来判断一个可选值是否有值。可以使用相等（<code>==</code>）或者不等（<code>!=</code>）来执行比较。</p><p>当你确定可选类型有值的时候，可以在可选的名称后面加个感叹号（<code>!</code>）来获取值。这个感叹号表示”我知道这个可选有值，请使用它。“这被称为可选项的<em>强制解析</em>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> possibleNumber <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span><br><span class="hljs-keyword">let</span> convertedNumber <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>(possibleNumber)<span class="hljs-comment">// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;</span><br><span class="hljs-keyword">if</span>  convertedNumber <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> &#123;    <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;convertedNumber has an integer value of <span class="hljs-subst">\(convertedNumber<span class="hljs-operator">!</span>)</span>.&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 输出“convertedNumber has an integer value of 123.”</span><br></code></pre></td></tr></table></figure><p>注意：</p><p>使用<code>！</code>进行强制解析之前，一定要确定可选项包含一个非<code>nil</code>的值。</p><h6 id="12-3-可选绑定"><a href="#12-3-可选绑定" class="headerlink" title="12.3 可选绑定"></a>12.3 可选绑定</h6><p>使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋值给一个临时的常量或者变量。</p><p>例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> actualNumber <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>(possibleNumber) &#123;    <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\&#x27;</span><span class="hljs-subst">\(possibleNumber)</span><span class="hljs-subst">\&#x27;</span> has an integer value of <span class="hljs-subst">\(actualNumber)</span>&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;  <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\&#x27;</span><span class="hljs-subst">\(possibleNumber)</span><span class="hljs-subst">\&#x27;</span> could not be converted to an integer&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 输出“&#x27;123&#x27; has an integer value of 123”</span><br></code></pre></td></tr></table></figure><p>这段代码可以被理解为：</p><p>“如果 Int(possibleNumber) 返回的可选 <code>Int</code> 包含一个值，创建一个叫做 actualNumber 的新常量并将可选包含的值赋给它。”</p><p>如果转换成功，<code>actualNumber</code>常量可以在if语句的第一个分支中使用。它已经被可选类型包含的值初始化过，所以不需要再使用<code>！</code>后缀来获取它的值。</p><p>你可以在可选绑定中使用常量和变量。如果你想在 <code>if</code> 语句的第一个分支中操作 <code>actualNumber</code> 的值，你可以改成 <code>if var actualNumber</code>，这样可选类型包含的值就会被赋给一个变量而非常量。</p><p>你可以包含多个可选绑定或多个布尔条件在一个<code>if</code>语句中，只要用逗号隔开就行。只要任意一个可选绑定的值为<code>nil</code>，或者任意一个布尔条件为<code>false</code>，则整个<code>if</code>条件判断为<code>false</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> firstNumber <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>(<span class="hljs-string">&quot;4&quot;</span>), <span class="hljs-keyword">let</span> secondNumber <span class="hljs-operator">=</span> <span class="hljs-type">Int</span>(<span class="hljs-string">&quot;42&quot;</span>), firstNumber <span class="hljs-operator">&lt;</span> secondNumber <span class="hljs-operator">&amp;&amp;</span> secondNumber <span class="hljs-operator">&lt;</span> <span class="hljs-number">100</span> &#123;   <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(firstNumber)</span> &lt; <span class="hljs-subst">\(secondNumber)</span> &lt; 100&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 输出“4 &lt; 42 &lt; 100”</span><br></code></pre></td></tr></table></figure><h6 id="12-4-隐示解析可选类型"><a href="#12-4-隐示解析可选类型" class="headerlink" title="12.4 隐示解析可选类型"></a>12.4 隐示解析可选类型</h6><p>把想要用作可选类型的后面的问号（String?）改为感叹号（String!）来声明一个隐示解析的可选类型。</p><p>一个隐示解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。</p><p>例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> possibleString: <span class="hljs-type">String</span>? <span class="hljs-operator">=</span> <span class="hljs-string">&quot;An optional string.&quot;</span><br><span class="hljs-keyword">let</span> forcedString: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> possibleString<span class="hljs-operator">!</span> <span class="hljs-comment">// 需要感叹号来获取值</span><br><span class="hljs-keyword">let</span> assumedString: <span class="hljs-type">String</span>! <span class="hljs-operator">=</span> <span class="hljs-string">&quot;An implicitly unwrapped optional string.&quot;</span><br><span class="hljs-keyword">let</span> implicitString: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> assumedString  <span class="hljs-comment">// 不需要感叹号</span><br></code></pre></td></tr></table></figure><p>注意：</p><p>当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。如果一个变量之后可能变成<code>nil</code>的话请不要使用隐示解析可选类型。如果你需要在变量的生命周期中判断是否是<code>nil</code>的话，请使用普通可选类型。</p><h3 id="13-错误处理"><a href="#13-错误处理" class="headerlink" title="13. 错误处理"></a>13. 错误处理</h3><p>你可以使用 错误处理（error handling） 来应对程序执行中可能会遇到的错误条件。</p><p>相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。</p><p>当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canThrowAnError</span>()</span> <span class="hljs-keyword">throws</span> &#123;   <br>  <span class="hljs-comment">// 这个函数有可能抛出错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个函数可以通过在声明中添加 throws 关键词来抛出错误消息。当你的函数能抛出错误消息时，你应该在表达式中前置 try 关键词。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">do</span> &#123;    <br>  <span class="hljs-keyword">try</span> canThrowAnError()   <br>  <span class="hljs-comment">// 没有错误消息抛出</span><br>&#125; <span class="hljs-keyword">catch</span> &#123;   <br>  <span class="hljs-comment">// 有一个错误消息抛出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个 do 语句创建了一个新的包含作用域，使得错误能被传播到一个或多个 catch 从句。</p><h3 id="14-断言和先决条件"><a href="#14-断言和先决条件" class="headerlink" title="14. 断言和先决条件"></a>14. 断言和先决条件</h3><p>断言和先决条件是在运行时所做的检查。你可以用他们来检查在执行后续代码之前是否一个必要的条件已经被满足了。如果断言或者先决条件中的布尔条件评估的结果为 true（真），则代码像往常一样继续执行。如果布尔条件评估结果为 false（假），程序的当前状态是无效的，则代码执行结束，应用程序中止。</p><p>断言和先决条件的不同点是，他们什么时候进行状态检测：断言仅在调试环境运行，而先决条件则在调试环境和生产环境中运行。在生产环境中，断言的条件将不会进行评估。这个意味着你可以使用很多断言在你的开发阶段，但是这些断言在生产环境中不会产生任何影响。</p><h6 id="14-1-使用断言进行调试"><a href="#14-1-使用断言进行调试" class="headerlink" title="14.1 使用断言进行调试"></a>14.1 使用断言进行调试</h6><p>你可以调用 Swift 标准库的 <code>c(_:_:file:line:)</code> 函数来写一个断言。向这个函数传入一个结果为 true 或者 false 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示。</p><p>例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> age <span class="hljs-operator">=</span> <span class="hljs-operator">-</span><span class="hljs-number">3</span><br><span class="hljs-built_in">assert</span>(age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>, <span class="hljs-string">&quot;A person&#x27;s age cannot be less than zero&quot;</span>) <span class="hljs-comment">// 因为 age &lt; 0，所以断言会触发</span><br><span class="hljs-comment">//如果不需要断言信息，可以就像这样忽略掉</span><br><span class="hljs-built_in">assert</span>(age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>如果代码已经检查了条件，你可以使用 assertionFailure(_:file:line:) 函数来表明断言失败了.</p><p>例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">if</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span> &#123;  <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;You can ride the roller-coaster or the ferris wheel.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> &#123;  <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;You can ride the ferris wheel.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;    <br>  <span class="hljs-built_in">assertionFailure</span>(<span class="hljs-string">&quot;A person&#x27;s age can&#x27;t be less than zero.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="14-2-强制执行先决条件"><a href="#14-2-强制执行先决条件" class="headerlink" title="14.2 强制执行先决条件"></a>14.2 强制执行先决条件</h6><p>你可以使用全局 precondition(<em>:</em>:file:line:) 函数来写一个先决条件。向这个函数传入一个结果为 true 或者 false 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示。</p><p>例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 在一个下标的实现里...precondition(index &gt; 0, &quot;Index must be greater than zero.&quot;)</span><br></code></pre></td></tr></table></figure><p>你可以调用 preconditionFailure(_:file:line:) 方法来表明出现了一个错误。</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>Swift学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift_基本运算符</title>
    <link href="/2021/11/30/Swift/Swift_%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/11/30/Swift/Swift_%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>运算符是检查、改变、合并值的特殊符号和短语。</p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>运算符分为一元、二元和三元运算符：</p><ul><li><p>一元运算符对单一对象操作（如<code>-a</code>）。一元运算符分为前置运算符和后置运算符，前置运算符需要紧跟在操作对象之前（如<code>!b</code>），后置运算符需要紧跟在操作对象之后（如<code>c!</code>）</p></li><li><p>二元运算符操作两个操作对象（如<code>2+3</code>），是中置的，因为它们出现在两个操作数对象之间。</p></li><li><p>三元运算符操作三个操作对象，像C语言一样，Swift只有一个三元运算符，就是三目运算符（<code>a ？b : c</code>）</p></li></ul><p>受运算符影响的值叫操作数，在表达式<code>1+2</code>中，加号<code>+</code>是二元运算符，它的两个操作数是<code>1</code>和<code>2</code>.</p><h3 id="1-赋值运算符"><a href="#1-赋值运算符" class="headerlink" title="1. 赋值运算符"></a>1. 赋值运算符</h3><p>赋值运算符（<code>a = b</code>），表示用<code>b</code>的值来初始化或者更新<code>a</code>的值。</p><p>如果赋值的右边是一个多元数组，它的元素可以马上被分解成多个常量和变量。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> (x,y) <span class="hljs-operator">=</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">// 现在x等于1，y等于2</span><br></code></pre></td></tr></table></figure><p>与C语言和OC语言不同，Swift的赋值操作并不会返回任何值。</p><h3 id="2-算数运算符"><a href="#2-算数运算符" class="headerlink" title="2. 算数运算符"></a>2. 算数运算符</h3><p>Swift中所有数值类型都支持基本的四则算术运算符：</p><ul><li>加法（<code>+</code>）</li><li>减法（<code>-</code>）</li><li>乘法（<code>*</code>）</li><li>除法（<code>/</code>）</li></ul><p>与C和OC不同的是，Swift默认情况下是不允许在数值运算中出现溢出情况。但是你可以使用Swift的溢出运算符来实现溢出运算（如<code>a &amp;+ b</code>）。</p><p>加法运算符也可以用作<code>String</code>的拼接：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-string">&quot;hello,&quot;</span><span class="hljs-operator">+</span><span class="hljs-string">&quot;world&quot;</span><span class="hljs-comment">// 等于&quot;hello,world&quot;</span><br></code></pre></td></tr></table></figure><h6 id="2-1-求余运算符"><a href="#2-1-求余运算符" class="headerlink" title="2.1 求余运算符"></a>2.1 求余运算符</h6><p>求余运算符（a % b）是计算b的多少倍刚刚好可以容入a，返回多出来的那部分（余数）。</p><p>取余运算得到余数是有正余数和负余数的区别的，具体可以看<a href="https://10.1pxeye.com/negative-remainder-operation/">负数取余运算</a>。</p><h6 id="2-2-一元负号运算符"><a href="#2-2-一元负号运算符" class="headerlink" title="2.2 一元负号运算符"></a>2.2 一元负号运算符</h6><p>数值的正负号可以使用前缀<code>-</code>（即一元负号符）来切换：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> three <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">let</span> minusThree <span class="hljs-operator">=</span> <span class="hljs-operator">-</span>three       <span class="hljs-comment">// minusThree 等于 -3</span><br><span class="hljs-keyword">let</span> plusThree <span class="hljs-operator">=</span> <span class="hljs-operator">-</span>minusThree   <span class="hljs-comment">// plusThree 等于 3, 或 &quot;负负3&quot;</span><br></code></pre></td></tr></table></figure><p>一元负号符（<code>-</code>）写在操作数之前，中间没有空格。</p><h6 id="2-3-一元正号运算符"><a href="#2-3-一元正号运算符" class="headerlink" title="2.3 一元正号运算符"></a>2.3 一元正号运算符</h6><p>一元正号符（<code>+</code>）不做任何改变地返回操作数的值。</p><h3 id="3-组合赋值运算符"><a href="#3-组合赋值运算符" class="headerlink" title="3. 组合赋值运算符"></a>3. 组合赋值运算符</h3><p>如同C语言一样，Swift也提供把其他运算符和赋值运算符（<code>=</code>）组合的组合赋值运算符。</p><p>例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>a <span class="hljs-operator">+=</span> <span class="hljs-number">2</span><br><span class="hljs-comment">// a 现在是 3</span><br></code></pre></td></tr></table></figure><h3 id="4-比较运算符"><a href="#4-比较运算符" class="headerlink" title="4. 比较运算符"></a>4. 比较运算符</h3><p>Swift支持以下的比较运算符：</p><ul><li>等于（<code>a == b</code>）</li><li>不等于（<code>a != b</code>）</li><li>大于（<code>a &gt; b</code>）</li><li>小于（<code>a &lt; b</code>）</li><li>大于等于（<code>a &gt;=b</code>）</li><li>小于等于（<code>a &lt;= b</code>）</li></ul><p>注意：</p><p>Swift 也提供恒等（===）和不恒等（!==）这两个比较符来判断两个对象是否引用同一个对象实例。</p><h3 id="5-三元运算符"><a href="#5-三元运算符" class="headerlink" title="5. 三元运算符"></a>5. 三元运算符</h3><p>三元运算符的特殊在于它是有是三个操作数的运算符，它的形式是<code>问题</code> ？<code>答案1</code> ：<code>答案2</code>。它简洁的表达根据<code>问题</code>成立与否做出二选一的操作。如果<code>问题</code>成立，返回<code>答案1</code>的结果；反之返回<code>答案2</code>的结果。</p><h3 id="6-空合运算符"><a href="#6-空合运算符" class="headerlink" title="6. 空合运算符"></a>6. 空合运算符</h3><p>空合运算符（a ?? b）将对可选类型 a 进行空判断，如果 a 包含一个值就进行解包，否则就返回一个默认值 b。表达式 a 必须是 Optional 类型。默认值 b 的类型必须要和 a 存储值的类型保持一致。</p><h3 id="7-区间运算符"><a href="#7-区间运算符" class="headerlink" title="7. 区间运算符"></a>7. 区间运算符</h3><p>Swift 提供了几种方便表达一个区间的值的区间运算符。</p><h6 id="7-1-闭区间运算符"><a href="#7-1-闭区间运算符" class="headerlink" title="7.1 闭区间运算符"></a>7.1 闭区间运算符</h6><p>闭区间运算符（a…b）定义一个包含从 a 到 b（包括 a 和 b）的所有值的区间。a 的值不能超过 b。</p><h6 id="7-2-半开区间运算符"><a href="#7-2-半开区间运算符" class="headerlink" title="7.2 半开区间运算符"></a>7.2 半开区间运算符</h6><p>半开区间运算符（a..&lt;b）定义一个从 a 到 b 但不包括 b 的区间。 之所以称为半开区间，是因为该区间包含第一个值而不包括最后的值</p><h6 id="7-3-单侧区间"><a href="#7-3-单侧区间" class="headerlink" title="7.3 单侧区间"></a>7.3 单侧区间</h6><p>闭区间操作符有另一个表达形式，可以表达往一侧无限延伸的区间 。</p><p>例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names[<span class="hljs-number">2</span><span class="hljs-operator">...</span>] &#123;<br>    <span class="hljs-built_in">print</span>(name)<br>&#125;<br><span class="hljs-comment">// Brian</span><br><span class="hljs-comment">// Jack</span><br><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names[<span class="hljs-operator">...</span><span class="hljs-number">2</span>] &#123;<br>    <span class="hljs-built_in">print</span>(name)<br>&#125;<br><span class="hljs-comment">// Anna</span><br><span class="hljs-comment">// Alex</span><br><span class="hljs-comment">// Brian</span><br></code></pre></td></tr></table></figure><h3 id="8-逻辑运算符"><a href="#8-逻辑运算符" class="headerlink" title="8. 逻辑运算符"></a>8. 逻辑运算符</h3><p>逻辑运算符的操作对象是逻辑布尔值。Swift 支持基于 C 语言的三个标准逻辑运算。</p><ul><li><p>逻辑非（<code>!a</code>）</p><p>逻辑非运算符（!a）对一个布尔值取反，使得 true 变 false，false 变 true。</p></li><li><p>逻辑与（<code>a &amp;&amp; b</code>）</p><p>逻辑与运算符（a &amp;&amp; b）表达了只有 a 和 b 的值都为 true 时，整个表达式的值才会是 true。</p></li><li><p>逻辑或（<code>a || b</code>）</p><p>逻辑或运算符（a || b）是一个由两个连续的 | 组成的中置运算符。它表示了两个逻辑表达式的其中一个为 true，整个表达式就为 true。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>Swift学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为Hexo添加Gitalk评论系统</title>
    <link href="/2021/10/11/Hexo/%E4%B8%BAHexo%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/10/11/Hexo/%E4%B8%BAHexo%E6%B7%BB%E5%8A%A0Gitalk%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>不能评论的blog是没有灵魂的，所以这篇文章主要记录了hexo blog使用fluid主题时，如何添加Gitalk评论系统。我们在<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">fluid主题配置</a>这里面可以看到它支持好多评论插件，本着不过多使用三方的原则，选择了Gitalk这个最为我们最终的方案。效果还是出乎预料的好的！</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141740185.png" alt="Gitalk评论系统效果展示"></p><h3 id="一、创建GitHub-Application"><a href="#一、创建GitHub-Application" class="headerlink" title="一、创建GitHub Application"></a>一、创建GitHub Application</h3><p>如果没有可以<a href="https://github.com/settings/applications/new">点击这里申请</a>，然后按照步骤操作即可，这里我们要用到的是<strong>ClientID</strong>和<strong>ClientSecret</strong>这两个信息。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141740790.png" alt="创建OAuthApplication"></p><h3 id="二、配置-config-fluid-yml"><a href="#二、配置-config-fluid-yml" class="headerlink" title="二、配置_config.fluid.yml"></a>二、配置_config.fluid.yml</h3><p>在_config.fluid.yml中，找到如下进行配置。非常的简单！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 评论插件</span><br><span class="hljs-meta">#</span><span class="bash"> Comment plugin</span><br>comments:<br>  enable: true<br><span class="hljs-meta">  #</span><span class="bash"> 指定的插件，需要同时设置对应插件的必要参数</span><br><span class="hljs-meta">  #</span><span class="bash"> The specified plugin needs to <span class="hljs-built_in">set</span> the necessary parameters at the same time</span><br><span class="hljs-meta">  #</span><span class="bash"> Options: utterances | disqus | gitalk | valine | waline | changyan | livere | remark42 | twikoo | cusdis</span><br>  type: gitalk<br>    <br><span class="hljs-meta">#</span><span class="bash"> Gitalk</span><br><span class="hljs-meta">#</span><span class="bash"> 基于 GitHub Issues</span><br><span class="hljs-meta">#</span><span class="bash"> Based on GitHub Issues</span><br><span class="hljs-meta">#</span><span class="bash"> See: https://github.com/gitalk/gitalk<span class="hljs-comment">#options</span></span><br>gitalk:<br>  clientID: &#x27;&#x27; # 可在第一步获取<br>  clientSecret: &#x27;&#x27; # 可在第一步获取<br>  repo: &#x27;GHTYQ.github.io&#x27; # GitHub repository <br>  owner: &#x27;GHTYQ&#x27; # GitHub repository 所有者，可以是个人或者组织<br>  admin: [&#x27;GHTYQ&#x27;] # GitHub repository 的所有者和合作者 (对这个 repository 有写权限的用户)<br>  language: zh-CN<br>  labels: [&#x27;Gitalk&#x27;] # GitHub issue 的标签<br>  perPage: 10 # 每次加载的数据大小，最多100<br>  pagerDirection: last # 评论排序方式， last为按评论创建时间倒叙，first为按创建时间正序<br>  distractionFreeMode: false # 类似Facebook评论框的全屏遮罩效果<br>  createIssueManually: true # 如果当前页面没有相应的 isssue 且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮<br><span class="hljs-meta">  #</span><span class="bash"> 默认 proxy 可能会失效，解决方法请见下方链接</span><br><span class="hljs-meta">  #</span><span class="bash"> The default proxy may be invalid, refer to the links <span class="hljs-keyword">for</span> solutions</span><br><span class="hljs-meta">  #</span><span class="bash"> https://github.com/gitalk/gitalk/issues/429</span><br><span class="hljs-meta">  #</span><span class="bash"> https://github.com/Zibri/cloudflare-cors-anywhere</span><br>  proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token<br></code></pre></td></tr></table></figure><h3 id="三、Gitalk的使用"><a href="#三、Gitalk的使用" class="headerlink" title="三、Gitalk的使用"></a>三、Gitalk的使用</h3><p>按照第二步配置好后，我们只需将其部署上去，即可完成Gitalk在hexo blog fluid主题下的添加。但是需要注意的一点是，使用的时候我们需要先初始化issue，才能使用！</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/gitalk/gitalk">Gitalk</a></li><li><a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">Fluid配置指南</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+Typora优雅的编写blog</title>
    <link href="/2021/10/09/Hexo/Hexo-Typora%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E5%86%99blog/"/>
    <url>/2021/10/09/Hexo/Hexo-Typora%E4%BC%98%E9%9B%85%E7%9A%84%E7%BC%96%E5%86%99blog/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>使用过hexo的人应该都知道它有一个不太方便的地方就是编写blog，作为一个typora的深度用户，就想着能够将这两个结合起来使用，因为typora的实时预览对于编写md文件非常友好，而且我们通过typora打开的文件，可以很好的看到目录结构，完全可以将typora当做hexo的admin。下面就看下如何将结合起来使用吧！</p><h3 id="一、Hexo-Typora编写blog"><a href="#一、Hexo-Typora编写blog" class="headerlink" title="一、Hexo+Typora编写blog"></a>一、Hexo+Typora编写blog</h3><ol><li><p>找到hexo下存放资源的source文件夹，使用typora打开，这里可以看到我我们整体的文件目录。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141754268.png" alt="打开source文件"></p></li><li><p>在终端中使用hexo new ‘title’的方式新建一篇文章，这时候在typora中_posts 文件夹下可以看到新建的文章，我们可以将这篇文章移动到我们自定义的文件夹下，方便我们分类区分。（上图是已经移动好文章位置的）（Cocoapods、Hexo、iOS这三个文件夹是我自己方便区分创建的，它们不影响hexo进行本地预览）</p></li><li><p>编写md文件的时候，如果你hexo本地预览也是打开的，command+s保存后，hexo本地资源也会实时更新，这样我们在hexo本地服务和typora中都能看到文章的展示效果。</p></li><li><p>编写完成后可以直接通过sourceTree等代码管理工具提交修改，因为我们在项目中已经添加了travis，它会自动帮我们部署，非常的方便。</p></li></ol><h3 id="二、使用本地图片"><a href="#二、使用本地图片" class="headerlink" title="二、使用本地图片"></a>二、使用本地图片</h3><p>使用的本地图片的时候你会发现，在typora和hexo中因为图片路径问题，总是有一端无法正常显示出图片，这时我们可以按照如下方法进行设置。</p><ol><li><p>typora设置图片根目录，让图片在typora中正常的显示</p><p>假如我们的图片是放在source/post_img文件夹下的，这时hexo如果想显示图片就需要通过<code>![](/post_img/image.jpg)</code>的形式去访问。而typora是无法根据这样一个路径找到我们需要显示的图片的。这就需要我们在typora中通过<code>格式-&gt;图像-&gt;设置图片的根目录</code>的设置来让typora中正常显示图片。下图是我们的目录结构，我们将source文件夹设置为根目录即。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141744961.png" alt="目录结构"></p></li><li><p>typora设置让图片在上传时复制到指定路径，让图片在hexo中正常显示</p><p>大多数时候我们的图片都是截图并保存在桌面的，要想在hexo中将图片正常显示，这时候就用到了typora提供的一个很好用的功能，插入图片时复制到指定路径。通过这个设置就很快捷的将图片放置到我们需要的指定的位置，非常的方便。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141744198.png" alt="图片插入时复制到指定路径"></p></li></ol><h3 id="三、使用网络图片"><a href="#三、使用网络图片" class="headerlink" title="三、使用网络图片"></a>三、使用网络图片</h3><p>先简单介绍下我们的图床实现方案是PicGo+github的形式搭建的，具体实现步骤可以参考<a href="https://picgo.github.io/PicGo-Doc/">PicGo</a>。配置好我们的图床后，我们只需在typro中设置下图像配置，之后就可以采用直接拖拽的形式，将图片拖拽到typora中，完成图片上传到git仓库后以链接的形式显示出来。非常的方便。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141812242.png" alt="图像配置"></p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+gh-pages+Travis搭建属于自己的blog</title>
    <link href="/2021/10/08/Hexo/Hexo-gh-pages-Travis%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84blog/"/>
    <url>/2021/10/08/Hexo/Hexo-gh-pages-Travis%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84blog/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>最近时间稍微有点空闲，就想着把之前工作中遇到的一些琐碎的问题给归纳总结下，一直在使用的是一个非常好用的工具<a href="https://www.notion.so/desktop">notion</a>！但是，不知道你们有没有这种时候，就很突然的想自己搭建一个Blog，于是就开始看一些技术方案，最终定下来用hexo+github page是因为看到hexo中<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a>这个主题，真的非常喜欢！在搭建的时候也遇到了一些小问题，在这里我把搭建的流程给简洁记录下来（具体的可以参考<a href="https://hexo.io/zh-cn/docs/">hexo官网</a>），方便自己查阅，也希望能给有需要的人提供一些帮助吧！</p><h3 id="一、Hexo-的安装"><a href="#一、Hexo-的安装" class="headerlink" title="一、Hexo 的安装"></a>一、Hexo 的安装</h3><ol><li><p>在安装hexo 之前确保自己电脑装有git、node.js</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看git、node版本</span><br>git --version<br>node -v<br></code></pre></td></tr></table></figure></li><li><p>安装hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li><li><p>建站</p><ul><li><p>创建一个文件夹，用来存放建站所需的文件</p></li><li><p>cd 到所创建的文件夹下执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br>npm install<br></code></pre></td></tr></table></figure></li><li><p>完成后可以看到_config.yml、package.json、source、themes等文件</p><table><thead><tr><th>文件名</th><th>作用</th></tr></thead><tbody><tr><td>_config.yml</td><td>网站的配置信息，基本上网站的所有配置都是通过这个文件完成的</td></tr><tr><td>source</td><td>资源文件夹，用来存储我们创建的blog文章，图片等信息</td></tr><tr><td>themes</td><td>主题文件夹</td></tr><tr><td>package.json</td><td>应用程序的信息</td></tr></tbody></table></li></ul></li></ol><p>到这里为止，hexo就算是安装完成了，还是比较简单的。</p><h3 id="二、更改Hexo主题"><a href="#二、更改Hexo主题" class="headerlink" title="二、更改Hexo主题"></a>二、更改Hexo主题</h3><ol><li><p>安装Fluid主题，具体配置可以打开<a href="https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B">Fluid主题网站</a>查看，上面讲解的非常详细</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li><p>创建_config.fluidyml文件</p><p>在博客目录下创建 <code>_config.fluid.yml</code>，将主题的_config.yml 内容复制过去。(这里我是通过复制原有的yml文件，更改名称完成的yml文件的创建)</p></li><li><p>在_config.yml中设置主题为fluid</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 默认的是landscape这个主题</span><br>theme: fluid<br></code></pre></td></tr></table></figure></li></ol><h3 id="三、使用Hexo写作"><a href="#三、使用Hexo写作" class="headerlink" title="三、使用Hexo写作"></a>三、使用Hexo写作</h3><ol><li><p>创建新文章和页面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new [layout] &#x27;title&#x27;<br></code></pre></td></tr></table></figure><p>layout 表示文章布局，默认的是post，还有draft和page两种</p><table><thead><tr><th>布局</th><th>路径</th><th></th></tr></thead><tbody><tr><td>post(默认)</td><td>source/_posts</td><td></td></tr><tr><td>draft</td><td>source/draft</td><td>默认不会再页面显示，需是哟经hexo publish [layout] ‘title’ 将草稿发布</td></tr><tr><td>page</td><td>source</td><td>创建类似关于页的时候使用</td></tr></tbody></table><p>创建文章成功后，可以在md文件中看到如下内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">title: title<br>date: 2021-09-28 19:19:55<br><span class="hljs-section">tags:</span><br><span class="hljs-section">----------------------------------------------</span><br></code></pre></td></tr></table></figure><p>我们可以按照下面的格式为文章添加tags、categories</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">tag:<br><span class="hljs-bullet">-</span> iOS<br><span class="hljs-bullet">-</span> OC<br>categories:<br><span class="hljs-bullet">-</span> iOS<br></code></pre></td></tr></table></figure><p>在这里推荐一个非常好用的md编写工具<a href="https://typora.io/">Typora</a></p></li><li><p>生成静态文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo generate <br><span class="hljs-meta">#</span><span class="bash"> 可以使用下面的方式简写</span><br>hexo g<br></code></pre></td></tr></table></figure></li><li><p>本地预览</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo sever<br><span class="hljs-meta">#</span><span class="bash"> 简写</span><br>hexo s<br></code></pre></td></tr></table></figure><p>这时候就可以通过<em><a href="http://localhost:4000/">http://localhost:4000</a></em>进行本地预览。</p></li></ol><h3 id="四、将Hexo部署到Github-Pages"><a href="#四、将Hexo部署到Github-Pages" class="headerlink" title="四、将Hexo部署到Github Pages"></a>四、将Hexo部署到Github Pages</h3><ol><li><p>创建Repository</p><p>需要注意的是你需要将仓库名命名为&lt;你的GitHub名称&gt;.github.io</p></li><li><p>将Travis CI 添加到你的GitHub账户中</p><p>点击<a href="https://github.com/marketplace/travis-ci">Travis CI</a> 将其添加到你的账户中，添加成功后可以通过Travis CI 中<a href="https://github.com/settings/installations">Configure access</a>进入下面界面</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141741568.png" alt="TravisCI添加成功"></p></li><li><p>在GitHub中配置Travis CI 权限并新建Personal Access Token</p><ul><li><p>配置权限</p><p>点击2中图片所示的Configure按钮，为我们的repository配置Travis CI access 权限</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141741122.png" alt="配置TravisCIAccess权限"></p></li><li><p>新建token</p><p>在GitHub setting中找到Developer setting，创建<a href="https://github.com/settings/tokens">Personal access tokens</a> ,创建的时候名字没有特殊含义，可以自由取。这是我创建后的界面，记住token只有在刚创建的时候显示一次，之后不会再显示，所以需要我们找个地方将token给记录下来。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141742279.png" alt="创建token"></p></li></ul></li><li><p>回到Travis CI 中，在Environment Variables下新建环境变量</p><p>配置好权限的Travis CI页面如下</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141742737.png" alt="TravisCI页面"></p><p>我们可以通过点击Settings进入下面页面，在这里配置环境变量，Name为 <em>GH-TOKEN</em>, Value 为刚才在GitHub生成的token，然后点击Add保存。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141742469.png" alt="环境配置变量"></p></li><li><p>在hexo站点文件夹下新建一个.travis.yml文件, 文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo: false<br>language: node_js<br>node_js:<br>  - 13 # use nodejs v10 LTS<br>cache: npm<br>branches:<br>  only:<br>    - master # build master branch only<br>install:<br>  - yarn # <br>script:<br>  - hexo generate # generate static files<br>deploy:<br>  provider: pages<br>  skip-cleanup: true<br>  github-token: $GH_TOKEN<br>  keep-history: true<br>  on:<br>    branch: master<br>  local-dir: public<br></code></pre></td></tr></table></figure></li><li><p>将上述修改推送到repository</p><p>可以根据创建repository时的提示git init 那些，将所有的内容推送到repository。Travis CI应该会自动开始运行，并将生成的文件推送到同一repository下gh-pages分支下。</p><p>Travis CI 运行成功的后效果如下：</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141742848.png" alt="部署成功"></p></li><li><p>访问站点</p><p>前往GitHub中repository的page界面，将GitHub pages 部署为gh-pages。然后可以通过<code>https://&lt;你的 GitHub 用户名&gt;.github.io</code> 查看你的站点是否可以访问</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141743884.png" alt="gh-pages"></p></li></ol><h3 id="五、绑定自己的域名"><a href="#五、绑定自己的域名" class="headerlink" title="五、绑定自己的域名"></a>五、绑定自己的域名</h3><p>这里以阿里云为例简单介绍</p><ol><li><p>域名解析</p><p>如果没有域名的话，可以先到进行<a href="https://wanwang.aliyun.com/?spm=5176.21213303.1158081.3.15763edawPg6qP&scm=20140722.S_card@@%E5%8D%A1%E7%89%87@@581._.ID_card@@%E5%8D%A1%E7%89%87@@581-RL_%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C-OR_ser-V_2-P0_0">域名注册</a>，有域名的先找到域名列表，如下，点击解析</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110151359624.png" alt="域名列表"></p><p>选择新手指导，记录值可以通过ping youname.github.io 获取，解析成功后会看到有两条添加记录。</p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110151404439.png" alt="新手指导" style="zoom: 50%;" /></li><li><p>添加CNAME文件</p><p>在hexo-&gt;source文件夹下创建CNAME文件，文件内容填写为你的域名，添加完成后记得重新部署。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110151410339.png" alt="截屏2021-10-15 下午2.10.08"></p></li><li><p>配置gh-pages</p><p>打开github，找到Github Pages界面，配置Custom domain。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110151415545.png" alt="配置domain"></p></li></ol><h3 id="六、遇到的问题"><a href="#六、遇到的问题" class="headerlink" title="六、遇到的问题"></a>六、遇到的问题</h3><ol><li><p>不能创建以.开头的文件，因为这些名称已被系统预留</p><p>以’.’开头的文件创建的时候，mac系统会提示‘不能创建以.开头的文件，因为这些名称已被系统预留’，</p><p>Solution：可以在终端中执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder<br></code></pre></td></tr></table></figure></li><li><p>The engine “node” is incompatible with this module. Expected version “&gt;=12.4.0”. Got “10.24.1”</p><p>S：将.travis.yml中node.js的版本改为大于12.4的，之前写的是10，现在改为了13解决了问题</p></li><li><p>error Your lockfile needs to be updated, but yarn was run with <code>--frozen-lockfile</code>.</p><p>S：在.travis.yml中增加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">install: <br>  - yarn<br></code></pre></td></tr></table></figure></li><li><p>默认主题导致的GitHub pages问题</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141743833.png" alt="gh-pages_ques"></p><p>S：删除默认主题landscape中的README.md文件</p></li><li><p>配置custom damain的时候报如下问题</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110151419584.png" alt="配置domain问题"></p><p>S: 按照要求在阿里云解析设置将修改记录中的记录类型改为<code>CNAME-将只想另外一个域名</code>，将记录值改为<code>youname.github.io</code>即可。</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p></li><li><p><a href="https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B">Fluid主题配置</a></p></li><li><p><a href="https://blog.esunr.xyz/2020/03/TravisCi%E4%BD%BF%E7%94%A8yarn%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5%E5%8E%9F%E5%9B%A0/#2-%E5%88%86%E6%9E%90">Travis Ci 出现 “eval yarn –frozen-lockfile” 构建失败解决方法</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS15 中应用跟踪弹窗不显示被拒</title>
    <link href="/2021/10/08/iOS/%E5%BA%94%E7%94%A8%E8%B7%9F%E8%B8%AA%E5%BC%B9%E7%AA%97%E5%9C%A8iOS15%E4%B8%AD%E8%A2%AB%E6%8B%92/"/>
    <url>/2021/10/08/iOS/%E5%BA%94%E7%94%A8%E8%B7%9F%E8%B8%AA%E5%BC%B9%E7%AA%97%E5%9C%A8iOS15%E4%B8%AD%E8%A2%AB%E6%8B%92/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>赶上快要国庆的时机上线，就很担心审核被拒，也可能是越担心越容易发生吧，它还是来了！哈哈！下面就简单记录下问题原因及解决方法吧！</p><h3 id="一、原因"><a href="#一、原因" class="headerlink" title="一、原因"></a>一、原因</h3><p>先看下苹果被拒原因：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs tex">Guideline 2.1 - Information Needed<br><br><br>We&#x27;re looking forward to completing our review, but we need more information to continue. Your app uses the AppTrackingTransparency framework, but we are unable to locate the App Tracking Transparency permission request when reviewed on iOS 15.0.<br><br>Since you indicated in App Store Connect that you collect data in order to track the user, we need to confirm that App Tracking Transparency has been correctly implemented.<br><br>Next Steps<br><br>Please explain where we can find the App Tracking Transparency permission request in your app. The request should appear before any data is collected that could be used to track the user.<br><br>If your app does not track users, please update your app privacy information in App Store Connect. You must have the Account Holder or Admin role to update app privacy information.<br><br>If you&#x27;ve implemented App Tracking Transparency but the permission request is not appearing on devices running the latest OS, please review the available documentation and confirm App Tracking Transparency has been correctly implemented.<br><br>Resources<br><br>- Tracking is linking data collected from your app with third-party data for advertising purposes, or sharing the collected data with a data broker. Learn more about tracking.<br>- See Frequently Asked Questions about the new requirements for apps that track users.<br>- Review developer documentation for App Tracking Transparency.<br><br><br><br>Since your App Store Connect status is Metadata Rejected, we do NOT require a new binary. To revise the metadata, visit App Store Connect to select your app and revise the desired metadata values. Once you’ve completed all changes, reply to this message in Resolution Center and we will continue the review.<br><br><br><br><br></code></pre></td></tr></table></figure><p>其实在被拒的邮件中，我们可以清楚的看到，被拒原因是因为iOS15中我们的”是否允许app跟踪请求“的弹框没有弹出，导致应用被拒。看到这个问题，我的第一反应是我在iOS14.5推出的时候就有因为收集用户信息没有给提示被拒，关于这一点我是有处理的。但是注意到这里说的是在iOS15，可能是这次升级带来了什么改变。于是尝试在iOS14、15两个不同系统中分别运营app，可以发现在iOS15中确实没有弹窗。接下来就去Google了下如何解决😁。</p><h3 id="二、解决方法"><a href="#二、解决方法" class="headerlink" title="二、解决方法"></a>二、解决方法</h3><p>将有关用户跟踪弹框提示的代码从didFinishLaunchingWithOptions下换到applicationDidBecomeActive下即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">// 将提示放到这个地方<br>- (void)applicationDidBecomeActive:(UIApplication *)application &#123;<br>    if (@available(iOS 14,*)) &#123;<br>        [ATTrackingManager requestTrackingAuthorizationWithCompletionHandler:^(ATTrackingManagerAuthorizationStatus status) &#123;<br>            if (status == ATTrackingManagerAuthorizationStatusAuthorized) &#123;<br>                NSLog(@&quot;允许&quot;);<br>            &#125;else&#123;<br>                NSLog(@&quot;不允许&quot;);<br>            &#125;<br>        &#125;];<br>    &#125;else&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.reddit.com/r/iOSProgramming/comments/pt41jz/att_prompt_not_showing_on_ios_15/">ATT prompt not showing on iOS 15?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>AppStore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift_Scheme实现应用间跳转</title>
    <link href="/2021/09/28/Swift/Swift_Scheme%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E9%97%B4%E8%B7%B3%E8%BD%AC/"/>
    <url>/2021/09/28/Swift/Swift_Scheme%E5%AE%9E%E7%8E%B0%E5%BA%94%E7%94%A8%E9%97%B4%E8%B7%B3%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="一、URL-Scheme"><a href="#一、URL-Scheme" class="headerlink" title="一、URL Scheme"></a><strong>一、URL Scheme</strong></h3><p>苹果的沙盒机制使App只能访问自己的沙盒，在保证用户的安全和隐私的同时，也阻碍了App之间的合理通信。为解决这一问题，苹果提供了可以实现App之间相互跳转的方法：URL Scheme。</p><blockquote><p>URL格式 scheme://host:port/path?query</p></blockquote><h3 id="二、实现应用A跳转到应用B（不带参数）"><a href="#二、实现应用A跳转到应用B（不带参数）" class="headerlink" title="二、实现应用A跳转到应用B（不带参数）"></a><strong>二、实现应用A跳转到应用B（不带参数）</strong></h3><ol><li><p>B应用添加URL Scheme</p><p>在要跳转的应用B的target –&gt; info 中找到URL Types，添加URL Scheme。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141746175.png" alt="应用添加URLScheme"></p><p>A应用添加白名单</p><p>iOS 9 之后只有添加白名单之后才能完成跳转。</p><p>在应用A的info.plist文件中添加LSApplicationQueriesSchemes字段，该字段是数组类型，然后添加string类型的item，item的值为要跳转的B应用的scheme。</p><p>在这里，如果我们不将scheme的值添加到白名单，会报<strong>This app is not allowed to query for scheme xxx</strong>。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141746486.png" alt="添加白名单"></p></li><li><p>在应用A需要跳转的地方实现跳转方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//这里DemoB是定义的scheme，://是实现跳转的格式</span><br><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span>  url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>.<span class="hljs-keyword">init</span>(string: <span class="hljs-string">&quot;DemoB://&quot;</span>) <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;<br><span class="hljs-keyword">if</span> <span class="hljs-type">UIApplication</span>.shared.canOpenURL(url) &#123;<br>    <span class="hljs-type">UIApplication</span>.shared.open(url, options: [:], completionHandler: <span class="hljs-literal">nil</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有此应用&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>跳转的实现必须知道要跳转应用的scheme，iOS9之后也必须将其添加到白名单中。</p></li></ol><h3 id="三、实现应用A带参数跳转到应用B"><a href="#三、实现应用A带参数跳转到应用B" class="headerlink" title="三、实现应用A带参数跳转到应用B"></a><strong>三、实现应用A带参数跳转到应用B</strong></h3><ol><li><p>同二中1.2步骤</p></li><li><p>在应用A需要跳转的地方实现跳转方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span>  url <span class="hljs-operator">=</span> <span class="hljs-type">URL</span>.<span class="hljs-keyword">init</span>(string: <span class="hljs-string">&quot;DemoB://detailPage?name=taylor&amp;age=22&quot;</span>) <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;<br><span class="hljs-keyword">if</span> <span class="hljs-type">UIApplication</span>.shared.canOpenURL(url) &#123;<br>    <span class="hljs-type">UIApplication</span>.shared.open(url, options: [:], completionHandler: <span class="hljs-literal">nil</span>)<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有此应用&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在应用B的SceneDelegate中实现监控跳转的代理方法</p><p>需要注意的是iOS13之后，需要在SceneDelegate中实现下列方法，在AppDelegate中实现openURL的监听是无效的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scene</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">scene</span>: <span class="hljs-type">UIScene</span>, <span class="hljs-params">openURLContexts</span> <span class="hljs-params">URLContexts</span>: <span class="hljs-type">Set</span>&lt;<span class="hljs-type">UIOpenURLContext</span>&gt;)</span> &#123;<br>      <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> url <span class="hljs-operator">=</span> <span class="hljs-type">URLContexts</span>.first<span class="hljs-operator">?</span>.url <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span><br>      &#125;<br>      <span class="hljs-keyword">let</span> urlComponent <span class="hljs-operator">=</span> <span class="hljs-type">URLComponents</span>.<span class="hljs-keyword">init</span>(url: url, resolvingAgainstBaseURL: <span class="hljs-literal">false</span>)<br>      <span class="hljs-comment">// 获取参数</span><br>      <span class="hljs-keyword">let</span> items :[<span class="hljs-type">URLQueryItem</span>] <span class="hljs-operator">=</span> urlComponent<span class="hljs-operator">?</span>.queryItems <span class="hljs-operator">??</span> []<br>      <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items &#123;<br>          <span class="hljs-built_in">print</span>(item.name,item.value <span class="hljs-operator">??</span> <span class="hljs-string">&quot;&quot;</span>)<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cocoapods私有库校验更新常见问题</title>
    <link href="/2021/09/26/Cocoapods/Cocoapods%E7%A7%81%E6%9C%89%E5%BA%93%E6%A0%A1%E9%AA%8C%E6%9B%B4%E6%96%B0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/09/26/Cocoapods/Cocoapods%E7%A7%81%E6%9C%89%E5%BA%93%E6%A0%A1%E9%AA%8C%E6%9B%B4%E6%96%B0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>这里记录了我在使用cocoapods私有库的时候遇到了问题，记录下来，方便以后遇到同样的问题时查阅。</p><h3 id="一、Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists"><a href="#一、Please-make-sure-you-have-the-correct-access-rights-and-the-repository-exists" class="headerlink" title="一、Please make sure you have the correct access rights and the repository exists."></a><strong>一、Please make sure you have the correct access rights and the repository exists.</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">Validating spec<br>https://www.sourcetreeapp.com<br>Cloning spec repo `aliyun-1` from `git@github.com:aliyun/aliyun-specs.git`<br>  $ /usr/bin/git <span class="hljs-built_in">clone</span> git@github.com:aliyun/aliyun-specs.git -- aliyun-1<br>  Cloning into <span class="hljs-string">&#x27;aliyun-1&#x27;</span>...<br>  git@github.com: Permission denied (publickey).<br>  fatal: Could not <span class="hljs-built_in">read</span> from remote repository.<br><br>  Please make sure you have the correct access rights<br>  and the repository exists.<br>[!] Unable to add a <span class="hljs-built_in">source</span> with url `git@github.com:aliyun/aliyun-specs.git` named `aliyun-1`.<br>(/usr/bin/git <span class="hljs-built_in">clone</span> git@github.com:aliyun/aliyun-specs.git -- aliyun-1<br><br>Cloning into <span class="hljs-string">&#x27;aliyun-1&#x27;</span>...<br>git@github.com: Permission denied (publickey).<br>fatal: Could not <span class="hljs-built_in">read</span> from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br>)<br>You can try adding it manually <span class="hljs-keyword">in</span> `/Users/mac/.cocoapods/repos` or via `pod repo add`.<br></code></pre></td></tr></table></figure><p>问题：</p><p>在执行cocoapods模块升级校验的时候出现这个问题，查看了下，是pod私有库中引用了aliyun的这个资源。</p><p>解决：</p><ol><li>在~/.cocoapods中查看了下name是aliyun-1的资源库是存在的，想着可能是重复导致的问题，就将它删除，重新校验。但是依然失败。</li><li>按照最下方的提示，使用“pod repo add name source”的方法。依然失败。</li><li>网上百度了下，说是ssh秘钥相关的问题，但是想了下aliyun这个是公共的，应该不会是这个问题吧，但是一时没有方法，于是重新生成了ssh秘钥，并在项目用的相关git库中都做了修改。依然无效。</li><li>最终解决方法，返费用重复了1.2的方法后，成功校验了！</li></ol><h3 id="二、-ERROR-iOS-unknown-Encountered-an-unknown-error"><a href="#二、-ERROR-iOS-unknown-Encountered-an-unknown-error" class="headerlink" title="二、- ERROR | [iOS] unknown: Encountered an unknown error"></a>二、- ERROR | [iOS] unknown: Encountered an unknown error</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[!] Error installing CTMediator<br> -&gt; xxxxxxxx (1.7.3)<br>    - WARN  | <span class="hljs-built_in">source</span>: Git SSH URLs will NOT work <span class="hljs-keyword">for</span> people behind firewalls configured to only allow HTTP, therefore HTTPS is preferred.<br>    - ERROR | [iOS] unknown: Encountered an unknown error ([!] /usr/bin/git <span class="hljs-built_in">clone</span> https://github.com/casatwy/CTMediator.git /var/folders/dr/y6z2zsxs4m9bxrqxwcdchsnw0000gn/T/d20220111-93058-y6ldtw --template= --single-branch --depth 1 --branch 46<br><br>Cloning into <span class="hljs-string">&#x27;/var/folders/dr/y6z2zsxs4m9bxrqxwcdchsnw0000gn/T/d20220111-93058-y6ldtw&#x27;</span>...<br>fatal: unable to access <span class="hljs-string">&#x27;https://github.com/casatwy/CTMediator.git/&#x27;</span>: Failed to connect to github.com port 443: Operation timed out<br></code></pre></td></tr></table></figure><p>解决方法：</p><p>反复尝试</p><h3 id="三、-ERROR-iOS-xcodebuild-Returned-an-unsuccessful-exit-code"><a href="#三、-ERROR-iOS-xcodebuild-Returned-an-unsuccessful-exit-code" class="headerlink" title="三、 - ERROR | [iOS] xcodebuild: Returned an unsuccessful exit code."></a>三、 - ERROR | [iOS] xcodebuild: Returned an unsuccessful exit code.</h3><p>问题1：</p><p>在对pod库进行校验执行 pod lib lint –verbose –allow-warnings 的时候报下面错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">- ERROR | [iOS] xcodebuild: Returned an unsuccessful <span class="hljs-built_in">exit</span> code. You can use `--verbose` <span class="hljs-keyword">for</span> more information.<br>- NOTE  | xcodebuild:  note: Using new build system<br>- NOTE  | [iOS] xcodebuild:  note: Planning build<br>- NOTE  | [iOS] xcodebuild:  note: Constructing build description<br><br>-----------------------------------<br><br>/Users/mac/.rvm/rubies/ruby-2.6.6/lib/ruby/gems/2.6.0/gems/cocoapods-1.10.1/lib/cocoapods/<span class="hljs-built_in">command</span>/repo/push.rb:150:<span class="hljs-keyword">in</span> `block <span class="hljs-keyword">in</span> validate_podspec_files<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/Users/mac/.rvm/rubies/ruby-2.6.6/lib/ruby/gems/2.6.0/gems/cocoapods-1.10.1/lib/cocoapods/command/repo/push.rb:135:in `each&#x27;</span><br>/Users/mac/.rvm/rubies/ruby-2.6.6/lib/ruby/gems/2.6.0/gems/cocoapods-1.10.1/lib/cocoapods/<span class="hljs-built_in">command</span>/repo/push.rb:135:<span class="hljs-keyword">in</span> `validate_podspec_files<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/Users/mac/.rvm/rubies/ruby-2.6.6/lib/ruby/gems/2.6.0/gems/cocoapods-1.10.1/lib/cocoapods/command/repo/push.rb:76:in `run&#x27;</span><br>/Users/mac/.rvm/rubies/ruby-2.6.6/lib/ruby/gems/2.6.0/gems/claide-1.0.3/lib/claide/command.rb:334:<span class="hljs-keyword">in</span> `run<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/Users/mac/.rvm/rubies/ruby-2.6.6/lib/ruby/gems/2.6.0/gems/cocoapods-1.10.1/lib/cocoapods/command.rb:52:in `run&#x27;</span><br>/Users/mac/.rvm/rubies/ruby-2.6.6/lib/ruby/gems/2.6.0/gems/cocoapods-1.10.1/bin/pod:55:<span class="hljs-keyword">in</span> `&lt;top (required)&gt;<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/usr/local/bin/pod:23:in `load&#x27;</span><br>/usr/<span class="hljs-built_in">local</span>/bin/pod:23:<span class="hljs-keyword">in</span> `&lt;main&gt;<span class="hljs-string">&#x27;</span><br><span class="hljs-string">/Users/mac/.rvm/rubies/ruby-2.6.6/bin/ruby_executable_hooks:22:in `eval&#x27;</span><br>/Users/mac/.rvm/rubies/ruby-2.6.6/bin/ruby_executable_hooks:22:<span class="hljs-keyword">in</span> `&lt;main&gt;<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>解决方法：</p><p>添加可选参数 –skip-import-validation </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">校验：<br>$ pod lib lint --use-libraries --verbose --allow-warnings --skip-import-validation<br>提交：<br>$ pod repo push repo库 xxx.podspec --allow-warnings --use-libraries --verbose --skip-import-validation<br></code></pre></td></tr></table></figure><hr><p>问题2：</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141745287.png" alt="Cocoapods_校验问题"></p><p>原因：文件引用方式不对，在我的项目中 不同组件间用CTMediator关联起来，这里我直接引用了（使用排除法定位到引用错误的文件的）</p><p>解决方法：</p><p>去掉直接引用改用CTMeditor 引用的方式（开始一直是本地校验没问题，上传继续出现之前的问题，使用pod cache list 找到自己的pod库，根据提示路径删除缓存文件，从新上传即可。</p>]]></content>
    
    
    <categories>
      
      <category>Cocoapods</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Cocoapods</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cocoapods私有库的创建使用及更新</title>
    <link href="/2021/09/26/Cocoapods/Cocoapods%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%9B%B4%E6%96%B0/"/>
    <url>/2021/09/26/Cocoapods/Cocoapods%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、创建两个远程仓库"><a href="#一、创建两个远程仓库" class="headerlink" title="一、创建两个远程仓库"></a><strong>一、创建两个远程仓库</strong></h3><p>创建两个远程仓库一个用来做仓库索引（TYQRepo），一个用来存放我们自己写的Pod库（PodTestDemo）</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141737761.png" alt="Cocoapods_远程仓库的创建"></p><h3 id="二、添加索引库到本地Repos"><a href="#二、添加索引库到本地Repos" class="headerlink" title="二、添加索引库到本地Repos"></a><strong>二、添加索引库到本地Repos</strong></h3><p>我们可以在~/.cocoapods/Repos目录下查看到一个master文件，这个master文件就是存在本地的cocoapods的官方索引库。</p><p>我们按照下面命令将TYQRepo索引库添加到本地。然后执行ls查看是否添加成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~/.cocoapods/repos<br>$ pod repo add 【索引库名称】【索引库地址】<br></code></pre></td></tr></table></figure><h3 id="三、创建并配置podspec文件"><a href="#三、创建并配置podspec文件" class="headerlink" title="三、创建并配置podspec文件"></a><strong>三、创建并配置podspec文件</strong></h3><ol><li><p>创建podspc文件</p><p>在指定的文件路径下通过<strong>pod lib create 【podspec名字】</strong>创建podspc文件，以带example的为例，创建过程输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /Users/mac/Desktop/TYQ<br>$ ls<br>$ pod lib create PodTestDemo<br>Cloning `https://github.com/CocoaPods/pod-template.git` into `PodTestDemo`.<br>Configuring PodTestDemo template.<br>security: SecKeychainSearchCopyNext: The specified item could not be found <span class="hljs-keyword">in</span> the keychain.<br><br>------------------------------<br><br>To get you started we need to ask a few questions, this should only take a minute.<br><br>If this is your first time we recommend running through with the guide:<br> - https://guides.cocoapods.org/making/using-pod-lib-create.html<br> ( hold cmd and double click links to open <span class="hljs-keyword">in</span> a browser. )<br><br>What platform <span class="hljs-keyword">do</span> you want to use?? [ iOS / macOS ]<br> &gt; ios<br><br>What language <span class="hljs-keyword">do</span> you want to use?? [ Swift / ObjC ]<br> &gt; objc<br><br>Would you like to include a demo application with your library? [ Yes / No ]<br> &gt; yes<br><br>Which testing frameworks will you use? [ Specta / Kiwi / None ]<br> &gt; none<br><br>Would you like to <span class="hljs-keyword">do</span> view based testing? [ Yes / No ]<br> &gt; yes<br><br>What is your class prefix?<br> &gt; TYQ<br>security: SecKeychainSearchCopyNext: The specified item could not be found <span class="hljs-keyword">in</span> the keychain.<br>security: SecKeychainSearchCopyNext: The specified item could not be found <span class="hljs-keyword">in</span> the keychain.<br>security: SecKeychainSearchCopyNext: The specified item could not be found <span class="hljs-keyword">in</span> the keychain.<br>security: SecKeychainSearchCopyNext: The specified item could not be found <span class="hljs-keyword">in</span> the keychain.<br>security: SecKeychainSearchCopyNext: The specified item could not be found <span class="hljs-keyword">in</span> the keychain.<br>security: SecKeychainSearchCopyNext: The specified item could not be found <span class="hljs-keyword">in</span> the keychain.<br><br>Running pod install on your new library.<br><br>Analyzing dependencies<br>Downloading dependencies<br>Installing FBSnapshotTestCase (2.1.4)<br>Installing PodTestDemo (0.1.0)<br>Generating Pods project<br>Integrating client project<br><br>[!] Please close any current Xcode sessions and use `PodTestDemo.xcworkspace` <span class="hljs-keyword">for</span> this project from now on.<br>Pod installation complete! There are 2 dependencies from the Podfile and 2 total pods installed.<br><br>[!] Your project does not explicitly specify the CocoaPods master specs repo. Since CDN is now used as the default, you may safely remove it from your repos directory via `pod repo remove master`. To suppress this warning please add `warn_for_unused_master_specs_repo =&gt; <span class="hljs-literal">false</span>` to your Podfile.<br><br> Ace! you<span class="hljs-string">&#x27;re ready to go!</span><br><span class="hljs-string"> We will start you off by opening your project in Xcode</span><br><span class="hljs-string">  open &#x27;</span>PodTestDemo/Example/PodTestDemo.xcworkspace<span class="hljs-string">&#x27;</span><br><span class="hljs-string"></span><br><span class="hljs-string">To learn more about the template see `https://github.com/CocoaPods/pod-template.git`.</span><br><span class="hljs-string">To learn more about creating a new pod, see `https://guides.cocoapods.org/making/making-a-cocoapod`.</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="四、添加组件代码"><a href="#四、添加组件代码" class="headerlink" title="四、添加组件代码"></a>四<strong>、添加组件代码</strong></h3><ol><li><p>配置podspec文件</p><p>请注意下面第一句话 <strong>Be sure to run `pod lib lint PodTestDemo.podspec’ to ensure this is a valid spec before submitting.</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Be sure to run `po&#x27; to ensure this is a</span><br><span class="hljs-comment"># valid spec before submitting.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Any lines starting with a # are optional, but their use is encouraged</span><br><span class="hljs-comment"># To learn more about a Podspec see https://guides.cocoapods.org/syntax/podspec.html</span><br><span class="hljs-comment">#</span><br><br>Pod::Spec.new <span class="hljs-keyword">do</span> |s|<br>  s.name             = <span class="hljs-string">&#x27;PodTestDemo&#x27;</span><br>  s.version          = <span class="hljs-string">&#x27;0.1.0&#x27;</span><br>  s.summary          = <span class="hljs-string">&#x27;私有库创建demo&#x27;</span>//简短描述<br><br><span class="hljs-comment"># This description is used to generate tags and improve search results.</span><br><span class="hljs-comment">#   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="hljs-comment">#   * Try to keep it short, snappy and to the point.</span><br><span class="hljs-comment">#   * Write the description between the DESC delimiters below.</span><br><span class="hljs-comment">#   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span><br><br>  s.description      = &lt;&lt;-<span class="hljs-string">DESC</span><br><span class="hljs-string">TODO: Add long description of the pod here.</span><br><span class="hljs-string">                       DESC</span><br>  //主页、需要填写可以访问的链接地址<br>  s.homepage         = <span class="hljs-string">&#x27;https://gitee.com/tian-yanqing/projects&#x27;</span><br>  <span class="hljs-comment"># s.screenshots     = &#x27;www.example.com/screenshots_1&#x27;, &#x27;www.example.com/screenshots_2&#x27;</span><br>  //开源协议<br>  s.license          = &#123; :<span class="hljs-built_in">type</span> =&gt; <span class="hljs-string">&#x27;MIT&#x27;</span>, :file =&gt; <span class="hljs-string">&#x27;LICENSE&#x27;</span> &#125;<br>  //作者信息<br>  s.author           = &#123; <span class="hljs-string">&#x27;yanqingtian&#x27;</span> =&gt; <span class="hljs-string">&#x27;913498714@qq.com&#x27;</span> &#125;<br>  //<span class="hljs-built_in">source</span>是我们组建的git地址<br>  s.source           = &#123; :git =&gt; <span class="hljs-string">&#x27;https://gitee.com/tian-yanqing/pod-test-demo.git&#x27;</span>, :tag =&gt; s.version.to_s &#125;<br>  //社交账户<br>  <span class="hljs-comment"># s.social_media_url = &#x27;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#x27;</span><br>  //使用iOS9及以上版本<br>  s.ios.deployment_target = <span class="hljs-string">&#x27;9.0&#x27;</span><br>  //源文件 提供给他人使用的源文件<br>  s.source_files = <span class="hljs-string">&#x27;PodTestDemo/Classes/**/*&#x27;</span><br>  //资源文件地址<br>  <span class="hljs-comment"># s.resource_bundles = &#123;</span><br>  <span class="hljs-comment">#   &#x27;PodTestDemo&#x27; =&gt; [&#x27;PodTestDemo/Assets/*.png&#x27;]</span><br>  <span class="hljs-comment"># &#125;</span><br>  //公共头文件地址<br>  <span class="hljs-comment"># s.public_header_files = &#x27;Pod/Classes/**/*.h&#x27;</span><br>  //以来的frameworks 多个用逗号隔开<br>  <span class="hljs-comment"># s.frameworks = &#x27;UIKit&#x27;, &#x27;MapKit&#x27;</span><br>  //依赖第三方框架<br>  <span class="hljs-comment"># s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;</span><br>end<br><br></code></pre></td></tr></table></figure><p>编写完成后执行 <strong>pod lib lint PodTestDemo.podspec</strong> 进行校验，校验成功显示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"> $ pod lib lint PodTestDemo.podspec --allow-warnings<br>a<br> -&gt; PodTestDemo (0.1.0)<br>    - NOTE  | xcodebuild:  note: Using new build system<br>    - NOTE  | xcodebuild:  note: Building targets <span class="hljs-keyword">in</span> parallel<br>    - NOTE  | xcodebuild:  note: Using codesigning identity override: -<br>    - NOTE  | [iOS] xcodebuild:  note: Planning build<br>    - NOTE  | [iOS] xcodebuild:  note: Constructing build description<br>    - NOTE  | [iOS] xcodebuild:  warning: Skipping code signing because the target does not have an Info.plist file and one is not being generated automatically. (<span class="hljs-keyword">in</span> target <span class="hljs-string">&#x27;App&#x27;</span> from project <span class="hljs-string">&#x27;App&#x27;</span>)<br><br>PodTestDemo passed validation.<br></code></pre></td></tr></table></figure><p>在PodTestDemo–&gt;Classes文件将replaceMe.m文件删除，替换成需要添加的文件。我们以TestViewController为例。</p><p><img src="https://raw.githubusercontent.com/GHTYQ/Timg/master/img/202110141739124.png" alt="Cocoapods_文件替换"></p></li></ol><h3 id="五、提交本地pod库（PodTestDemo）到远程"><a href="#五、提交本地pod库（PodTestDemo）到远程" class="headerlink" title="五、提交本地pod库（PodTestDemo）到远程"></a>五<strong>、提交本地pod库（PodTestDemo）到远程</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /Users/mac/Desktop/TYQ/PodTestDemo<br>$ git init<br>$ git add .<br>$ git commit -m <span class="hljs-string">&quot;commit&quot;</span><br>$ git tag 0.1.0<br>$ git remote add origin [PodTestDemo Git URL]<br>$ git push -u origin master --tags<br></code></pre></td></tr></table></figure><h3 id="六、将pod私有库推送到索引库里"><a href="#六、将pod私有库推送到索引库里" class="headerlink" title="六、将pod私有库推送到索引库里"></a>六<strong>、将pod私有库推送到索引库里</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /Users/mac/Desktop/TYQ/PodTestDemo<br>$ pod repo push TYQRepos PodTestDemo.podspec<br><br>执行显示<br>Validating spec<br>Username <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;https://gitee.com&#x27;</span>: tian-yanqing<br>Password <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;https://tian-yanqing@gitee.com&#x27;</span>:<br> -&gt; PodTestDemo (0.1.0)<br>    - NOTE  | xcodebuild:  note: Using new build system<br>    - NOTE  | xcodebuild:  note: Building targets <span class="hljs-keyword">in</span> parallel<br>    - NOTE  | xcodebuild:  note: Using codesigning identity override: -<br>    - NOTE  | [iOS] xcodebuild:  note: Planning build<br>    - NOTE  | [iOS] xcodebuild:  note: Constructing build description<br>    - NOTE  | [iOS] xcodebuild:  warning: Skipping code signing because the target does not have an Info.plist file and one is not being generated automatically. (<span class="hljs-keyword">in</span> target <span class="hljs-string">&#x27;App&#x27;</span> from project <span class="hljs-string">&#x27;App&#x27;</span>)<br><br>Updating the `TYQRepos<span class="hljs-string">&#x27; repo</span><br><span class="hljs-string"></span><br><span class="hljs-string">Adding the spec to the `TYQRepos&#x27;</span> repo<br><br> - [Add] PodTestDemo (0.1.0)<br><br>Pushing the `TYQRepos<span class="hljs-string">&#x27; repo</span><br></code></pre></td></tr></table></figure><h3 id="七、pod私有库的使用"><a href="#七、pod私有库的使用" class="headerlink" title="七、pod私有库的使用"></a>七<strong>、pod私有库的使用</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> <span class="hljs-string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="hljs-built_in">source</span> <span class="hljs-string">&#x27;https://gitee.com/tian-yanqing/tyqrepos.git&#x27;</span><br>platform :ios,<span class="hljs-string">&#x27;9.0&#x27;</span><br>target <span class="hljs-string">&#x27;Test&#x27;</span> <span class="hljs-keyword">do</span><br>pod <span class="hljs-string">&#x27;PodTestDemo&#x27;</span><br>end<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>Source 后面是远程索引库的地址</li><li>支持版本不能比podspec文件中配置的版本低</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">//引用的时候填写支持版本过低导致的错位<br>[!] CocoaPods could not find compatible versions <span class="hljs-keyword">for</span> pod <span class="hljs-string">&quot;PodTestDemo&quot;</span>:<br>  In Podfile:<br>    PodTestDemo<br>Specs satisfying the `PodTestDemo` dependency were found, but they required a higher minimum deployment target.<br></code></pre></td></tr></table></figure><ol><li>在制作swift 版本私有库的时候，需要暴露的方法属性等，需用public修饰。</li></ol><h3 id="八、pod库的升级"><a href="#八、pod库的升级" class="headerlink" title="八、pod库的升级"></a>八<strong>、pod库的升级</strong></h3><ol><li><p>将对pod库的修改内容推送到远程pod仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add .<br>$ git commit -m<span class="hljs-string">&quot;pod库升级到0.2.0&quot;</span><br>$ git push<br></code></pre></td></tr></table></figure></li><li><p>提交成功后重新打tag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git tag 0.2.0</span><br><span class="hljs-meta">$</span><span class="bash"> git push origin 0.2.0</span><br></code></pre></td></tr></table></figure></li><li><p>修改pod库模板工程中.podspec版本号，使s.version对应的植与最新tag值保持一致</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">s.version = <span class="hljs-string">&#x27;0.2.0&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>将pod库中.podspec推送到本地索引库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd 到pod模板库工程文件下，使用命令：<br><span class="hljs-meta">$</span><span class="bash"> pod repo push TYQRepos PodTestDemo.podspec</span><br>pod repo push 【索引库名】【pod库名.podspec】<br></code></pre></td></tr></table></figure><p>注意：</p><p>使用新升级后的pod库install的时候使用命令<strong>pod install –repo-update</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Cocoapods</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Cocoapods</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cocoapoods的安装及使用</title>
    <link href="/2021/09/26/Cocoapods/Cocoapoods%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/09/26/Cocoapods/Cocoapoods%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Cocoapods的安装"><a href="#一、Cocoapods的安装" class="headerlink" title="一、Cocoapods的安装"></a>一、Cocoapods的安装</h3><p>CocoaPods is a dependency manager for Swift and Objective-C Cocoa projects. It has over 56 thousand libraries and is used in over 3 million apps. CocoaPods can help you scale your projects elegantly.<br><a href="https://cocoapods.org/">官网地址</a></p><ol><li>替换ruby源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看当前ruby环境</span><br><span class="hljs-meta">$</span><span class="bash"> gem sources -l</span>  <br><span class="hljs-meta">#</span><span class="bash">默认情况下会返回当前Mac默认的ruby源</span><br><span class="hljs-meta">&gt;</span><span class="bash"> https://rubygems.org</span><br><span class="hljs-meta">#</span><span class="bash">替换</span><br><span class="hljs-meta">$</span><span class="bash"> gem <span class="hljs-built_in">source</span> --remove https://rubygems.org</span><br><span class="hljs-meta">$</span><span class="bash"> gem <span class="hljs-built_in">source</span> -a https://gems.ruby-china.com //这里需要注意ruby源域名已由.org替换为.com</span><br><span class="hljs-meta">#</span><span class="bash">检查是否替换成功</span><br><span class="hljs-meta">$</span><span class="bash"> gem sources -l</span> <br><span class="hljs-meta">&gt;</span><span class="bash"> https://gems.ruby-china.org //表示替换成功</span><br></code></pre></td></tr></table></figure><p>2.升级gem</p><p>升级gem的目的是避免因为gem版本过低而出现一些不必要的问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看当前gem版本</span><br><span class="hljs-meta">$</span><span class="bash"> gem -v</span><br><span class="hljs-meta">#</span><span class="bash">升级</span><br><span class="hljs-meta">$</span><span class="bash"> sudo gem update --system</span><br></code></pre></td></tr></table></figure><p>3.安装Cocoapods</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">Mac OS X 10.11前的方法</span><br><span class="hljs-meta">$</span><span class="bash"> sudo gem install cocoapods</span>　<br><span class="hljs-meta">#</span><span class="bash">Mac OS X 10.11后的方法</span>　　　　　　　　<br><span class="hljs-meta">$</span><span class="bash"> sudo gem install -n /usr/<span class="hljs-built_in">local</span>/bin cocoapods</span>  <br><span class="hljs-meta">$</span><span class="bash"> pod setup</span> <br>//执行完成后可在下面目录下查看：<br><span class="hljs-meta">$</span><span class="bash"> ~/.cocoapods/repos</span><br></code></pre></td></tr></table></figure><h3 id="二、Cocoapods的使用"><a href="#二、Cocoapods的使用" class="headerlink" title="二、Cocoapods的使用"></a>二、Cocoapods的使用</h3><p>在Terminal 下操作,cd到需要添加依赖的项目目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">第一步：创建Podfile</span><br>vi Podfile<br><span class="hljs-meta">#</span><span class="bash">第二步：编辑Podfile</span><br>platform:ios,&quot;9.0&quot;//平台，支持的最低版本号<br>target &quot;xxxxx&quot; do //xxxx项目名<br>pod “需要依赖的第三方库”,&quot;~&gt; 1.0.2&quot;<br><span class="hljs-meta">#</span><span class="bash">本地pod的引用</span><br>pod &quot;三方库名称&quot;，:path =&gt; &#x27;本地三方库库路径&#x27;<br>end<br><span class="hljs-meta">#</span><span class="bash">第三部：导入依赖</span><br><span class="hljs-meta">$</span><span class="bash"> pod install</span><br></code></pre></td></tr></table></figure><h3 id="三、Cocoapods卸载"><a href="#三、Cocoapods卸载" class="headerlink" title="三、Cocoapods卸载"></a>三、Cocoapods卸载</h3><p>执行以下命令卸载cocoapods</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo gem uninstall cocoapods</span><br></code></pre></td></tr></table></figure><p>查看本地安装cocoapods相关的东西</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> gem list --<span class="hljs-built_in">local</span> | grep cocoapods</span><br></code></pre></td></tr></table></figure><p>我的显示是这样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">cocoapods (1.5.3)<br>cocoapods-core (1.5.3)<br>cocoapods-deintegrate (1.0.5)<br>cocoapods-downloader (1.6.3)<br>cocoapods-plugins (1.0.0)<br>cocoapods-search (1.0.1)<br>cocoapods-stats (1.1.0)<br>cocoapods-trunk (1.6.0)<br>cocoapods-try (1.2.0)<br></code></pre></td></tr></table></figure><p>使用命令逐个删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo gem uninstall cocoapods-core</span><br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://stevenwuzheng.com/archives/pods">mac电脑彻底删除cocoapods并重新安装</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Cocoapods</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
      <tag>Cocoapods</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
